<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Analysis of Golang GPM Models - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This paper mainly analyzes the Golang GPM model." /><meta name="keywords" content="golang GMP" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-07/go-gmp/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Analysis of Golang GPM Models" />
<meta property="og:description" content="This paper mainly analyzes the Golang GPM model." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-07/go-gmp/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-06T13:02:34+08:00" />
<meta property="article:modified_time" content="2022-07-06T13:02:34+08:00" />

<meta itemprop="name" content="Analysis of Golang GPM Models">
<meta itemprop="description" content="This paper mainly analyzes the Golang GPM model."><meta itemprop="datePublished" content="2022-07-06T13:02:34+08:00" />
<meta itemprop="dateModified" content="2022-07-06T13:02:34+08:00" />
<meta itemprop="wordCount" content="5480">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Analysis of Golang GPM Models"/>
<meta name="twitter:description" content="This paper mainly analyzes the Golang GPM model."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Analysis of Golang GPM Models</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-07-06 13:02:34 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 5480 words </span>
          <span class="more-meta"> 11 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#differences-between-threads-kernel-threads-and-user-threads">Differences between threads, kernel threads and user threads</a></li>
        <li><a href="#reasons-for-golang-to-use-goroutine">Reasons for Golang to use goroutine</a></li>
        <li><a href="#distribution-of-goroutines-in-the-process-memory-space">Distribution of goroutines in the process memory space</a></li>
        <li><a href="#gpm-model-analysis">GPM Model Analysis</a>
          <ul>
            <li><a href="#gpm-life-cycle">GPM Life Cycle</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="differences-between-threads-kernel-threads-and-user-threads">Differences between threads, kernel threads and user threads</h2>
<ul>
<li>
<p><strong>Threads</strong>: From the kernel&rsquo;s point of view there is no such concept as threads. Linux implements all threads as processes, and the kernel has no special scheduling algorithm to handle threads. A thread is simply seen as a process that shares some resources with other processes. Like processes, each thread has its own <code>task_struct</code>, so in the kernel, a thread appears to be a normal process. Threads are also called lightweight processes. A process can have multiple threads, which have their own independent stack and are scheduled by the operating system to switch. On Linux they can be created with the <code>pthread_create()</code> method or the <code>clone()</code> system call.</p>
</li>
<li>
<p><strong>kernel threads</strong>: standard processes that run independently in kernel space. The difference between kernel threads and normal threads is that kernel threads do not have a separate address space.</p>
</li>
<li>
<p><strong>User thread</strong>: also known as a Coroutine, is a thread based on top of, but lighter than, a thread that exists and is managed by the user runtime and is not perceived by the operating system; its switching is controlled by the user program itself, but the user thread is also run by the kernel thread. coroutine in Lua and Python, Golang&rsquo;s goroutine are all user threads.</p>
</li>
</ul>
<p>The relationship between the three is shown below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/06/39d75fc4436949cdb518ec992c1b29be.png" alt="Threads/kernel threads/User thread"></p>
<p>The relationship between goroutine and threads in Golang is shown below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/06/1aefd816c9ce48fe8f9a1c875ee19aa2.png" alt="relationship between goroutine and threads in Golang"></p>
<p>When a Golang program starts, it first creates a process, then a main thread, which executes some code for runtime initialization, including scheduler initialization, and then starts the scheduler, which keeps looking for a goroutine that needs to be run to bind to a kernel thread.</p>
<h2 id="reasons-for-golang-to-use-goroutine">Reasons for Golang to use goroutine</h2>
<p>Although there are already multi-threads and multi-processes in the operating system to solve the problem of high concurrency, but in today&rsquo;s Internet mass and high concurrency scenario, the performance requirements are becoming more and more demanding, a large number of processes/threads will have the problem of high memory occupation and CPU consumption, and many services are transformed and refactored to reduce costs and increase efficiency.</p>
<p>A process can be associated with multiple threads, and the threads will share some resources of the process, such as memory address space, open files, process base information, etc. Each thread will also have its own stack and register information, etc. Threads are lighter than processes, while goroutines are lighter than threads, and multiple goroutines will be associated with one thread. Each goroutine will have its own stack space, so it will also be more lightweight. From process to thread to goroutine, it is actually a process of continuous sharing to reduce switching costs.</p>
<p>Golang uses goroutine mainly for the following reasons.</p>
<ul>
<li>The problem of too heavy kernel thread creation and switching: both creation and switching require access to the kernel state, and access to the kernel state has high overhead and high performance cost, while goroutine switching does not require access to the kernel state.</li>
<li>Too heavy thread memory usage: the default stack size for creating a kernel thread is 8M, while creating a user thread, i.e. goroutine, requires only 2K memory, which is also automatically increased when the goroutine stack is not enough.</li>
<li>goroutine scheduling is more flexible, all goroutine scheduling and switching happens in the user state, there is no overhead of creating threads, and even when a goroutine blocks, other goroutines on the thread will be scheduled to run on other threads.</li>
</ul>
<h2 id="distribution-of-goroutines-in-the-process-memory-space">Distribution of goroutines in the process memory space</h2>
<p>A goroutine is essentially a function that can be suspended and resumed. When a goroutine is created, a section of space is allocated in the heap of the process, which is used to store the goroutine stack area, and then copied from the heap when the goroutine needs to be resumed to restore the runtime state of the function.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/06/98a4edcfb3cf4220a086164f9db2cfc1.png" alt="Distribution of goroutines in the process memory space"></p>
<h2 id="gpm-model-analysis">GPM Model Analysis</h2>
<p>The commit history of Golang code shows that a lot of code is translated from C to Go. A lot of the code in the runtime before go 1.4 was implemented in C. For example, many of the scheduling-related functions implemented in the current version of <code>proc.go</code> were originally implemented in C, but later translated in Go code. If you need to know the details of Golang&rsquo;s original design, you can look at the earliest C code commits.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">commit b2cdf30eb6c4a76504956aaaad47df969274296b
</span></span><span class="line"><span class="cl">Author: Russ Cox &lt;rsc@golang.org&gt;
</span></span><span class="line"><span class="cl">Date:   Tue Nov 11 17:08:33 2014 -0500
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    [dev.cc] runtime: convert scheduler from C to Go
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">commit 15ced2d00832dd9129b4ee0ac53b5367ade24c13
</span></span><span class="line"><span class="cl">Author: Russ Cox &lt;rsc@golang.org&gt;
</span></span><span class="line"><span class="cl">Date:   Tue Nov 11 17:06:22 2014 -0500
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    [dev.cc] runtime: convert assembly files for C to Go transition
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    The main change is that #include &#34;zasm_GOOS_GOARCH.h&#34;
</span></span><span class="line"><span class="cl">    is now #include &#34;go_asm.h&#34; and/or #include &#34;go_tls.h&#34;.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Also, because C StackGuard is now Go _StackGuard,
</span></span><span class="line"><span class="cl">    the assembly name changes from const_StackGuard to
</span></span><span class="line"><span class="cl">    const__StackGuard.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    In asm_$GOARCH.s, add new function getg, formerly
</span></span><span class="line"><span class="cl">    implemented in C.
</span></span></code></pre></td></tr></table>
</div>
</div><p>This article focuses on the current GPM model in the scheduler, starting with an understanding of the roles and connections of the three components of the GPM model.</p>
<ul>
<li>G: <strong>G</strong>oroutine, the function we run in a Go program using the <code>go</code> keyword.</li>
<li>M: <strong>M</strong>achine, or worker thread, which stands for system thread, and M is an object in runtime that creates a system thread and binds to that M at the same time as each M is created.</li>
<li>P: <strong>P</strong>rocessor, similar to the concept of a CPU core, which can execute Go code only when M is associated with a P.</li>
</ul>
<p>G needs to be bound to M at runtime, and M needs to be bound to P. M is not equal in number to P. This is because M gets caught in system calls or blocks for other things while running G. New M is created in runtime when M is not enough, so the number of M may grow as the program executes, while P stays the same without user intervention, and the number of G is determined by is determined by the user code.</p>
<p>The connection between the three GPMs is shown below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/06/7647382f54804e0daeb87bd0753bf3a2.png" alt="GMP"></p>
<ul>
<li>Global queue: Holds the G&rsquo;s waiting to run.</li>
<li>P&rsquo;s local queue: Similar to the global queue, it also holds the G waiting to run, and the number of Gs stored is limited. When a new G is created, the G is added to the local queue of P. If the queue is full, a part of the G in the local queue will be moved to the global queue.</li>
<li>P list: All P&rsquo;s are created at program startup and stored in an array of up to <code>GOMAXPROCS</code> (configurable).</li>
<li>M: If a thread wants to run a task, it has to get P and then get G from P&rsquo;s local queue. When P&rsquo;s queue is empty, M will also try to get a batch of G from the global queue and put it into P&rsquo;s local queue, or steal half from other P&rsquo;s local queue and put it into its own P&rsquo;s local queue, M runs G. After G is executed, M will get the next G from P and so on.</li>
</ul>
<h3 id="gpm-life-cycle">GPM Life Cycle</h3>
<h4 id="1-life-cycle-of-p">1. Life cycle of P</h4>
<p>The structure of the P object is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">id</span>          <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">status</span>      <span class="kt">uint32</span> <span class="c1">// P 的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">link</span>        <span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// 被调度次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">syscalltick</span> <span class="kt">uint32</span>     <span class="c1">// 执行过系统调用的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysmontick</span>  <span class="nx">sysmontick</span> <span class="c1">// sysmon 最近一次运行的时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// P 关联的 M
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>    <span class="c1">// 小对象缓存,可以无锁访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pcache</span>      <span class="nx">pageCache</span>  <span class="c1">// 页缓存,可以无锁访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">raceprocctx</span> <span class="kt">uintptr</span>    <span class="c1">// race相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 与 defer 相关
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">deferpool</span>    <span class="p">[</span><span class="mi">5</span><span class="p">][]</span><span class="o">*</span><span class="nx">_defer</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">deferpoolbuf</span> <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// goroutine ids 的缓存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">goidcache</span>    <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">goidcacheend</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// P 本地 G 队列,可以无锁访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runqhead</span> <span class="kt">uint32</span>     <span class="c1">// 本地队列头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runqtail</span> <span class="kt">uint32</span>     <span class="c1">// 本地队尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span> <span class="c1">// 本地 G 队列，使用数组实现的循环队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runnext</span> <span class="nx">guintptr</span>   <span class="c1">// 待运行的 G，优先级高于 runq
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 已运行结束的 G (状态为 Gdead)会被保存在 gFree 中，方便实现对 G 的复用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gList</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sudogbuf</span>   <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">mspancache</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">len</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">        <span class="nx">buf</span> <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">mspan</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">tracebuf</span> <span class="nx">traceBufPtr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">traceSweep</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="nx">traceSwept</span><span class="p">,</span> <span class="nx">traceReclaimed</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">palloc</span> <span class="nx">persistentAlloc</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="kt">uint32</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">timer0When</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">timerModifiedEarliest</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 与 GC 相关的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcAssistTime</span>         <span class="kt">int64</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">gcFractionalMarkTime</span> <span class="kt">int64</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">gcMarkWorkerMode</span> <span class="nx">gcMarkWorkerMode</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gcMarkWorkerStartTime</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gcw</span> <span class="nx">gcWork</span>
</span></span><span class="line"><span class="cl">    <span class="nx">wbBuf</span> <span class="nx">wbBuf</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 抢占标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">preempt</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="1why-do-we-need-p">(1)Why do we need P?</h5>
<p>Before Golang 1.1, there was no P component in the scheduler. The performance of the scheduler was still poor at this time. Dmitry Vyukov of the community summarized the problems in the current scheduler and designed to introduce the P component to solve the current problems (<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.mmq8lm48qfcw">Scalable Go Scheduler Design Doc</a>), and introduced the P component in Go 1.1. The introduction of the P component not only solves several problems listed in the documentation, but also introduces some good mechanisms.</p>
<p>The documentation lists 4 main issues with the scheduler, mainly</p>
<ul>
<li>
<p>The global mutex lock (<code>sched.Lock</code>) problem: In testing, the community found that Golang programs consume 14% of their CPU usage at runtime on processing global locks. Without the P component, M could only fetch G from the global queue by adding a mutex lock, and there was a delay in the locking phase for other goroutine processing (creation, completion, rescheduling, etc.); with the introduction of the P component, there is a queue in the P object to hold the list of G. The local queue in P solves the problem of a single global lock in the old scheduler, and the G queue is split into two categories, <code>sched</code> continues to keep the global G queue, while there will be a local G queue in each P. At this time, M will run the G in P&rsquo;s local queue first, and access without locking.</p>
</li>
<li>
<p>G switching problem: frequent switching of runnable G by M will increase the latency and overhead, for example, the newly created G will be put into the global queue instead of being executed locally in M, which will cause unnecessary overhead and latency, and should be executed on the M that created the G first; after the P component is introduced, the newly created G will be put into the local queue of the G-associated P first.</p>
</li>
<li>
<p>M&rsquo;s memory cache (<code>M.mcache</code>) problem: In the version without P component, each M structure has a <code>mcache</code> field, <code>mcache</code> is a memory allocation pool, small objects will be allocated directly from <code>mcache</code>, when M is running G, G needs to request small objects will be allocated directly from M&rsquo;s <code>mcache</code>, G G can be accessed without locking, because each M will only run one G at the same time, but there will only be some active M running G at each time in runtime, the other M blocking due to system calls etc. actually do not need <code>mcache</code>, this part of <code>mcache</code> is wasted, each M&rsquo;s <code>mcache</code> has about 2M size of available memory, when there are thousands of M in the When there are thousands of M&rsquo;s in the blocking state, a lot of memory is consumed. In addition, there is the problem of poor data locality, which means that M caches the small objects needed by G when it runs G. If G is dispatched to the same M again later, then it can speed up the access, but in the actual scenario, the probability that G is dispatched to the same M is not high, so the data locality is not good. With the introduction of the P component, <code>mcache</code> is shifted from M to P, and P keeps <code>mcache</code>, which means there is no need to allocate a <code>mcache</code> for each M, avoiding excessive memory consumption. In this way, in a highly concurrent state, each G will only use memory when it is running, and each G will be bound to a P, so only the currently running G will occupy a <code>mcache</code>, for which the number of <code>mcache</code>s is the number of P, and no locks will be generated during concurrent accesses.</p>
</li>
<li>
<p>Frequent thread blocking and wake-up problems: In the original scheduler, the number of system threads is limited by <code>runtime.GOMAXPROCS()</code>. Only one system thread is opened by default. And since M performs operations such as system calls, when M blocks, it does not create a new M to perform other tasks, but waits for M to wake up, and M switches between blocking and waking frequently, which causes additional overhead. In the new scheduler, when M is in the system scheduling state, it will be disassociated from the bound P and will wake up the existing or create a new M to run other G bound to P.</p>
</li>
</ul>
<h5 id="2-new-logic-for-p">(2) New logic for P</h5>
<p>The number of P&rsquo;s is initialized at runtime startup and is by default equal to the number of logical cores of the cpu. It can be set at program startup with the environment variable <code>GOMAXPROCS</code> or the <code>runtime.GOMAXPROCS()</code> method, and the number of P&rsquo;s is fixed for the duration of the program.</p>
<p>In the IO-intensive scenario, the number of P can be adjusted appropriately, because M needs to be bound to P to run, and M will fall into the system call when executing G. At this time, P associated with M is in the waiting state, if the system call never returns, then the CPU resources are actually wasted during this time waiting for the system call, although there is a <code>sysmon</code> monitoring thread in runtime can seize G, here is to seize P associated with G, let P rebind a M to run G, but <code>sysmon</code> is periodic execution of seizure, after <code>sysmon</code> stable operation every 10ms to check whether to seize P, the operating system in 10ms can perform multiple thread switching, if P is in the state of the system call there is a need to run G, this part of G is not executed, in fact, CPU resources are wasted. In some projects, we can see the operation of modifying the number of P. The open source database project <a href="https://github.com/dgraph-io/dgraph/blob/master/dgraph/main.go">https://github.com/dgraph-io/dgraph</a> adjusts <code>GOMAXPROCS</code> to 128 to increase the IO processing power.</p>
<h5 id="3-p-destruction-logic">(3) P destruction logic</h5>
<p>If <code>GOMAXPROC</code> is not adjusted during the program run, unused P will be placed in the scheduler&rsquo;s global queue <code>schedt.pidle</code> and will not be destroyed. If <code>GOMAXPROC</code> is turned down, <code>p.destroy()</code> will reclaim the excess P-associated resources and set the P state to <code>_Pdead</code>, while there may still be M objects associated with P, so P objects will not be reclaimed.</p>
<h5 id="4-the-state-of-p">(4) The state of P</h5>
<table>
<thead>
<tr>
<th>state</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_Pidle</code></td>
<td>The state after P is initialized, when no user code or scheduler is running yet</td>
</tr>
<tr>
<td><code>_Prunning</code></td>
<td>The state of P when it is bound by M and running user code</td>
</tr>
<tr>
<td><code>_Psyscall</code></td>
<td>P will be set to this state by the associated M when a system call is required when G is executed</td>
</tr>
<tr>
<td><code>_Pgcstop</code></td>
<td>P will be set to this state by the associated M when a GC occurs during program operation</td>
</tr>
<tr>
<td><code>_Pdead</code></td>
<td>If the number of <code>GOMAXPROCS</code> is reduced while the program is running, the excess P will be set to the <code>_Pdead</code> state</td>
</tr>
</tbody>
</table>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/06/cedd4b69023346688c81bbf1758f80f3.png" alt="The state of P"></p>
<h4 id="2-life-cycle-of-m">2. Life cycle of M</h4>
<p>The structure of M object is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// g0 记录工作线程（也就是内核线程）使用的栈信息，在执行调度代码时需要使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">g0</span>      <span class="o">*</span><span class="nx">g</span>    
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">morebuf</span> <span class="nx">gobuf</span>  <span class="c1">// 堆栈扩容使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">gsignal</span>       <span class="o">*</span><span class="nx">g</span>   <span class="c1">// 用于信号处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">......</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过 tls (线程本地存储)结构体实现 m 与工作线程的绑定
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tls</span>           <span class="p">[</span><span class="nx">tlsSlots</span><span class="p">]</span><span class="kt">uintptr</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">mstartfn</span>      <span class="kd">func</span><span class="p">()</span>   <span class="c1">// 表示m启动时立即执行的函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>       <span class="c1">// 指向正在运行的 goroutine 对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">caughtsig</span>     <span class="nx">guintptr</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">p</span>             <span class="nx">puintptr</span> <span class="c1">// 当前 m 绑定的 P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nextp</span>         <span class="nx">puintptr</span> <span class="c1">// 下次运行时的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">oldp</span>          <span class="nx">puintptr</span> <span class="c1">// 在执行系统调用之前绑定的P
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">id</span>            <span class="kt">int64</span>      <span class="c1">// m 的唯一id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mallocing</span>     <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">throwing</span>      <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">preemptoff</span>    <span class="kt">string</span> <span class="c1">// 是否要保持 curg 始终在这个 m 上运行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">locks</span>         <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">dying</span>         <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">profilehz</span>     <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">spinning</span>      <span class="kt">bool</span> <span class="c1">// 为 true 时表示当前 m 处于自旋状态，正在从其他线程偷工作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">blocked</span>       <span class="kt">bool</span> <span class="c1">// m 正阻塞在 note 上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">newSigstack</span>   <span class="kt">bool</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">printlock</span>     <span class="kt">int8</span>
</span></span><span class="line"><span class="cl">    <span class="nx">incgo</span>         <span class="kt">bool</span>   <span class="c1">// 是否在执行 cgo 调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">freeWait</span>      <span class="kt">uint32</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">fastrand</span>      <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">needextram</span>    <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="nx">traceback</span>     <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// cgo 调用计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ncgocall</span>      <span class="kt">uint64</span>      
</span></span><span class="line"><span class="cl">    <span class="nx">ncgo</span>          <span class="kt">int32</span>       
</span></span><span class="line"><span class="cl">    <span class="nx">cgoCallersUse</span> <span class="kt">uint32</span>      
</span></span><span class="line"><span class="cl">    <span class="nx">cgoCallers</span>    <span class="o">*</span><span class="nx">cgoCallers</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 没有 goroutine 需要运行时，工作线程睡眠在这个 park 成员上，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 其它线程通过这个 park 唤醒该工作线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">doesPark</span>      <span class="kt">bool</span>        
</span></span><span class="line"><span class="cl">    <span class="nx">park</span>          <span class="nx">note</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span>       <span class="c1">// 记录所有工作线程的链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">......</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">startingtrace</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="nx">syscalltick</span>   <span class="kt">uint32</span>   <span class="c1">// 执行过系统调用的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">freelink</span>      <span class="o">*</span><span class="nx">m</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">......</span>
</span></span><span class="line"><span class="cl">    <span class="nx">preemptGen</span> <span class="kt">uint32</span>   <span class="c1">// 完成的抢占信号数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">......</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="1-new-creation-of-m">(1) New creation of M</h5>
<p>M is an object in runtime that represents a thread. Each M object created creates a thread bound to M. New threads are created by executing the <code>clone()</code> system call. runtime defines the maximum number of M to be 10000. The maximum number of M is defined in runtime as 10000, which can be adjusted by <code>debug.SetMaxThreads(n)</code>.</p>
<p>New M will be created in the following two scenarios.</p>
<ul>
<li>The Golang program creates the main thread when it starts, and the main thread is the first M i.e. M0.</li>
<li>When a new G is created or a G goes from <code>_Gwaiting</code> to <code>_Grunning</code> and there is a free P, <code>startm()</code> will be called, first getting an M from the global queue (<code>sched.midle</code>) and binding the free P to execute the G. If there is no free M, M will be created by <code>newm()</code>.</li>
</ul>
<h5 id="2-destruction-of-m">(2) Destruction of M</h5>
<p>M will not be destroyed, but will go to sleep by executing the <code>stopm()</code> function when no runnable G can be found or no free P can be bound, and will go to sleep by executing the <code>stopm()</code> function in the following two cases.</p>
<ul>
<li>
<p>When the P bound by M has no runnable G and cannot steal runnable G from other P, M will try to enter the spin state first (<code>spinning</code>), only some M will enter the spin state, the number of M in the spin state is at most half of the number of P in the non-idle state (<code>sched.nmspinning &lt; (procs- sched.npidle)/ 2</code>), M in the spin state will steal executable G from other P. If M does not steal G in the spin state or does not enter the spin state, it will go directly to the sleep state.</p>
</li>
<li>
<p>When the G associated with M enters the system call, M will actively unbind with the associated P. When the G associated with M executes the <code>exitsyscall()</code> function to exit the system call, M will find a free P to bind, if no free P is found then M will call <code>stopm()</code> to enter the sleep state.</p>
</li>
</ul>
<p>The <code>stopm()</code> function puts the sleeping M into the global idle queue (<code>sched.midle</code>).</p>
<h5 id="3-operation-of-m">(3) Operation of M</h5>
<p>M needs to be associated with P to run, and M has affinity with P. For example, when executing the <code>entersyscall()</code> function to enter the system call, M will actively unbind with the current P. M will record the current P in <code>m.oldp</code>, and when executing the <code>exitsyscall()</code> function to exit the system call, M will preferentially bind the P in <code>m.oldp</code>.</p>
<h5 id="4-what-is-the-role-of-m0-and-how-does-it-differ-from-the-m-associated-with-other-threads">(4) What is the role of M0 and how does it differ from the M associated with other threads?</h5>
<p>M0 is a global variable defined in <code>src/runtime/proc.go</code>, M0 does not need to allocate memory on the heap, all other M&rsquo;s are objects created by <code>new(m)</code> and their memory is allocated from the heap, M0 is responsible for performing initialization operations and starting the first G, the Golang program will start M0 first, M0 and the main thread are bound. M0 is bound to the main thread, and when M0 starts the first G, the main goroutine, it functions just like any other M.</p>
<h5 id="5-why-should-we-limit-the-number-of-ms">(5) Why should we limit the number of M&rsquo;s?</h5>
<p>Golang added a limit on the number of M&rsquo;s in version 1.2 (<a href="https://github.com/golang/go/issues/4056">runtime: limit number of operating system threads</a>), the default maximum number of M&rsquo;s is 10000, and in In version 1.17 the scheduler was initialized with a default value set in the <code>schedinit()</code> function (<code>sched.maxmcount = 10000</code>).</p>
<p>Why limit the number of M&rsquo;s? In the article on refactoring the scheduler <a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.x125et1s6ve"><strong>Potential Further Improvements</strong></a>, Dmitry Vyukov has already mentioned the need to limit the number of M&rsquo;s. In scenarios where there is high concurrency or a large number of goroutines are repeatedly created, more threads are needed to execute the goroutine, and too many threads can exhaust system resources or trigger system limitations that can cause program exceptions. The kernel also consumes additional resources when scheduling a large number of threads, so limiting the number of M threads is mainly to prevent unreasonable use of the program.</p>
<p>The default size of each thread stack on Linux is 8M. If 10,000 threads are created, 78.125 G of memory is required by default, which is already a very large amount of memory usage for ordinary programs.</p>
<ul>
<li><strong>/proc/sys/kernel/threads-max</strong>: indicates the maximum number of threads supported by the system.</li>
<li><strong>/proc/sys/kernel/pid_max</strong>: indicates the limit of the system global PID number value, every process or thread has an ID, the process or thread will fail to be created if the value of the ID exceeds this number.</li>
<li><strong>/proc/sys/vm/max_map_count</strong>: indicates a limit on the number of VMAs (virtual memory areas) a process can have.</li>
</ul>
<h5 id="6-states-of-m">(6) States of M</h5>
<p>Through the analysis of the new and destruction process of M, M has three states: running, spin, and sleep, and the transitions between these three states are shown below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/06/5f467a9b49a8421d819502b19cfedd1b.png" alt="States of M"></p>
<h4 id="3-life-cycle-of-g">3. Life cycle of G</h4>
<p>The structure information of G is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 当前 Goroutine 的栈内存范围
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stack</span>       <span class="nx">stack</span>   
</span></span><span class="line"><span class="cl">    <span class="nx">stackguard0</span> <span class="kt">uintptr</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">stackguard1</span> <span class="kt">uintptr</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">_panic</span>    <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// 当前 g 中与 panic 相关的处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_defer</span>    <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// 当前 g 中与 defer 相关的处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">m</span>         <span class="o">*</span><span class="nx">m</span>      <span class="c1">// 绑定的 m
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// 存储当前 Goroutine 调度相关的数据，上下方切换时会把当前信息保存到这里
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sched</span>     <span class="nx">gobuf</span>   
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">......</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">param</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>  <span class="c1">// 唤醒G时传入的参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">atomicstatus</span> <span class="kt">uint32</span>  <span class="c1">// 当前 G 的状态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stackLock</span>    <span class="kt">uint32</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">goid</span>         <span class="kt">int64</span>   <span class="c1">// 当前 G 的 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">schedlink</span>    <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">waitsince</span>    <span class="kt">int64</span>      <span class="c1">// G 阻塞时长
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">waitreason</span>   <span class="nx">waitReason</span> <span class="c1">// 阻塞原因
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 抢占标记
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">preempt</span>       <span class="kt">bool</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">preemptStop</span>   <span class="kt">bool</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">preemptShrink</span> <span class="kt">bool</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">    <span class="nx">asyncSafePoint</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    <span class="nx">paniconfault</span> <span class="kt">bool</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">gcscandone</span>   <span class="kt">bool</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">throwsplit</span>   <span class="kt">bool</span> 
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 表示是否有未加锁定的channel指向到了g 栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">activeStackChans</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// 表示g 是放在chansend 还是 chanrecv，用于栈的收缩
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">parkingOnChan</span> <span class="kt">uint8</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">raceignore</span>     <span class="kt">int8</span>     <span class="c1">// ignore race detection events
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysblocktraced</span> <span class="kt">bool</span>     <span class="c1">// StartTrace has emitted EvGoInSyscall about this goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tracking</span>       <span class="kt">bool</span>     <span class="c1">// whether we&#39;re tracking this G for sched latency statistics
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">trackingSeq</span>    <span class="kt">uint8</span>    <span class="c1">// used to decide whether to track this G
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runnableStamp</span>  <span class="kt">int64</span>    <span class="c1">// timestamp of when the G last became runnable, only used when tracking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">runnableTime</span>   <span class="kt">int64</span>    <span class="c1">// the amount of time spent runnable, cleared when running, only used when tracking
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sysexitticks</span>   <span class="kt">int64</span>    <span class="c1">// cputicks when syscall has returned (for tracing)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">traceseq</span>       <span class="kt">uint64</span>   <span class="c1">// trace event sequencer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tracelastp</span>     <span class="nx">puintptr</span> <span class="c1">// last P emitted an event for this goroutine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lockedm</span>        <span class="nx">muintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sig</span>            <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">    <span class="nx">writebuf</span>       <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sigcode0</span>       <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sigcode1</span>       <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sigpc</span>          <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">gopc</span>           <span class="kt">uintptr</span>         <span class="c1">// goroutine 当前运行函数的 PC 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ancestors</span>      <span class="o">*</span><span class="p">[]</span><span class="nx">ancestorInfo</span> <span class="c1">// ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">startpc</span>        <span class="kt">uintptr</span>         <span class="c1">// 触发这个 goroutine 的函数的 PC 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">racectx</span>        <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">    <span class="nx">waiting</span>        <span class="o">*</span><span class="nx">sudog</span>         <span class="c1">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">cgoCtxt</span>        <span class="p">[]</span><span class="kt">uintptr</span>      <span class="c1">// cgo traceback context
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">labels</span>         <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// profiler labels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">timer</span>          <span class="o">*</span><span class="nx">timer</span>         <span class="c1">// cached timer for time.Sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">selectDone</span>     <span class="kt">uint32</span>         <span class="c1">// are we participating in a select and did someone win the race?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">// GC 时存储当前 Goroutine 辅助标记的对象字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">gcAssistBytes</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="1-new-creation-of-g">(1) New creation of G</h5>
<p>When a Golang program starts, the main thread creates the first goroutine to execute the main function, and a new goroutine is created if the user uses the go keyword in the main function, and the user can continue to create new goroutines in the goroutine using the go keyword. goroutines are created goroutines are created by calling the <code>newproc()</code> function in the golang runtime. The number of goroutines is limited by system resources (CPU, memory, file descriptors, etc.). If there is only simple logic in a goroutine, it is theoretically fine to have as many goroutines as you want, but if there are operations such as creating network connections or opening files in a goroutine, too many goroutines may result in reports such as <strong>too many files open</strong> or <strong>Resource temporarily unavailable</strong> and so on, causing the program to execute abnormally.</p>
<p>The newly created G is placed first in the <code>runnext</code> queue of the current G association P via the <code>runqput()</code> function. only one G is kept in P&rsquo;s <code>runnext</code> queue, and if there is already a G in the <code>runnext</code> queue, it is replaced with the newly created G. Then the original G in <code>runnext</code> is placed in P&rsquo;s local queue, <code>runq</code>, and if P&rsquo;s local queue is full, half of the G in P&rsquo;s local queue is moved to the global queue <code>sched.runq</code>. The main reason for moving the newly created G to P&rsquo;s <code>runnext</code> first is to improve performance. <code>runnext</code> is a completely private queue for P. If G is placed in P&rsquo;s local queue <code>runq</code>, the G in the <code>runq</code> queue may change due to other M&rsquo;s stealing, and each time G is fetched from P&rsquo;s local queue, <code>atomic. LoadAcq</code> and <code>atomic.CasRel</code> atomic operations every time G is fetched from the P local queue, which introduces additional overhead.</p>
<h5 id="2-destruction-of-g">(2) Destruction of G</h5>
<p>When G exits, the <code>goexit()</code> function is executed and the state of G changes from <code>_Grunning</code> to <code>_Gdead</code>. However, the G object is not freed directly, but is put into the local or global idle list <code>gFree</code> of the associated P for reuse via <code>gfput()</code>. Priority is given to the P local queue, and if there are more than 64 <code>gFree</code> in the P local queue, only 32 will be kept in the P local queue, and any more than that will be put into the global idle queue <code>sched.gFree</code>.</p>
<h5 id="3-runs-of-g">(3) Runs of G</h5>
<p>G is bound to M to run, and M needs to be bound to P to run, so theoretically the number of running G at the same time is equal to the number of P. M does not keep the state of G. G keeps the state in its <code>gobuf</code> field, so G can be scheduled across M. After M finds a G to run, it switches from the g0 stack to the user G&rsquo;s stack to run via the assembly function <code>gogo()</code>.</p>
<h5 id="4-what-are-the-states-of-g">(4) What are the states of G?</h5>
<p>The states of G are defined in the <code>src/runtime/runtime2.go</code> file. There are three main types of states, one is a few states when the goroutine is running normally, then the ones related to GC, and the remaining states are unused.</p>
<p>The role of each transition state and the relationship between the states are shown below.</p>
<table>
<thead>
<tr>
<th>states</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_Gidle</code></td>
<td>has just been created and not yet initialized</td>
</tr>
<tr>
<td><code>_Grunnable</code></td>
<td>No execution code, no ownership of the stack, stored in the run queue</td>
</tr>
<tr>
<td><code>_Grunning</code></td>
<td>can execute code, has ownership of the stack, has bound M and P</td>
</tr>
<tr>
<td><code>_Gsyscall</code></td>
<td>System call being executed</td>
</tr>
<tr>
<td><code>_Gwaiting</code></td>
<td>Blocked due to runtime, not executing user code and not on the run queue</td>
</tr>
<tr>
<td><code>_Gdead</code></td>
<td>Run completed in exit state</td>
</tr>
<tr>
<td><code>_Gcopystack</code></td>
<td>The stack is being copied</td>
</tr>
<tr>
<td><code>_Gpreempted</code></td>
<td>Blocked due to preemption, waiting for wake-up</td>
</tr>
<tr>
<td><code>_Gscan</code></td>
<td>GC is scanning the stack space</td>
</tr>
</tbody>
</table>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/06/0f653992990d4f958b63287c25431a67.png" alt="What are the states of G"></p>
<h4 id="4-the-role-of-g0">4. The role of g0</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g0</span>      <span class="o">*</span><span class="nx">g</span>     <span class="c1">// goroutine with scheduling stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">......</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are two types of g0 in runtime, one is m0-associated g0 and the other is other m-associated g0. m0-associated g0 is defined as a global variable and its memory space is allocated on the system&rsquo;s stack with a size of 64K - 104 bytes, and other m-associated g0 is a stack allocated on the heap with a default size of 8K.</p>
<p><code>src/runtime/proc.go#1879</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nf">mStackIsSystemAllocated</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// sys.StackGuardMultiplier 在 linux 系统上值为 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="mi">8192</span> <span class="o">*</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">StackGuardMultiplier</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Every time an M is started, the first goroutine created is g0. Each M will have its own g0. g0 is mainly used to record the stack information used by the worker thread, and is only used to be responsible for scheduling, which needs to be used when executing the scheduling code. When executing the user goroutine code, the stack of the user goroutine is used, and the stack switch occurs when scheduling.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/06/af402ad06cae450b8a40562583118eea.png" alt="M scheduling"></p>
<p>Many functions in the runtime code are called through the <code>systemstack()</code> function when they are executed. The role of the <code>systemstack()</code> function is to switch to the g0 stack, then execute the corresponding function and finally switch back to the original stack and return. In principle, as long as a function has <code>nosplit</code> this system annotation will need to be executed on the g0 stack, because the addition of <code>nosplit</code> compiler in the compilation will not be inserted in front of the function to check the stack overflow code, these functions in the execution of the stack overflow may cause, and g0 stack is relatively large, in the compilation if each function in the runtime to do stack overflow check will affect efficiency That&rsquo;s why we cut to the g0 stack.</p>
<h2 id="summary">Summary</h2>
<p>This article mainly analyzes the Golang GPM model. In the process of reading the runtime code, we found that there are many details in the code that need a lot of time to analyze, and only some simple explanations of the general framework are given in the article, and some details are brought in by the way. In the later articles, many details will be analyzed again.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-07/go-bootstrap/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Golang program startup flow analysis</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-07/k8s-descheduler/">
            <span class="next-text nav-default">Using and Extending the Descheduler Component in Kubernetes</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
