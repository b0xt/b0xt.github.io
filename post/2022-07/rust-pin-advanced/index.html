<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Rust Pin Advanced - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article systematically composes the knowledge points related to Pin." /><meta name="keywords" content="rust, pin" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-07/rust-pin-advanced/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Rust Pin Advanced" />
<meta property="og:description" content="This article systematically composes the knowledge points related to Pin." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-07/rust-pin-advanced/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-30T12:58:47+08:00" />
<meta property="article:modified_time" content="2022-07-30T12:58:47+08:00" />

<meta itemprop="name" content="Rust Pin Advanced">
<meta itemprop="description" content="This article systematically composes the knowledge points related to Pin."><meta itemprop="datePublished" content="2022-07-30T12:58:47+08:00" />
<meta itemprop="dateModified" content="2022-07-30T12:58:47+08:00" />
<meta itemprop="wordCount" content="4508">
<meta itemprop="keywords" content="rust," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Rust Pin Advanced"/>
<meta name="twitter:description" content="This article systematically composes the knowledge points related to Pin."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Rust Pin Advanced</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-07-30 12:58:47 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4508 words </span>
          <span class="more-meta"> 22 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#pin-api-anatomy">Pin API Anatomy</a></li>
        <li><a href="#pin-additional-attributes">Pin additional attributes</a>
          <ul>
            <li><a href="#fundamental">#[fundamental]</a></li>
            <li><a href="#reprtransparent">#[repr(transparent)</a></li>
          </ul>
        </li>
        <li><a href="#traits-implemented-by-pin">Traits implemented by Pin</a>
          <ul>
            <li><a href="#unpin">Unpin</a></li>
            <li><a href="#deref-and-derefmut">Deref and DerefMut</a></li>
            <li><a href="#future">Future</a></li>
          </ul>
        </li>
        <li><a href="#unpin-and-future">Unpin and Future</a>
          <ul>
            <li><a href="#unpin-is-a-safe-trait">Unpin is a safe trait</a></li>
            <li><a href="#why-future-can-be-unpin">Why Future can be Unpin</a></li>
            <li><a href="#pins-future-implementation">Pin&rsquo;s Future implementation</a></li>
            <li><a href="#why-unpin-constraints-are-needed">Why Unpin constraints are needed</a></li>
          </ul>
        </li>
        <li><a href="#other-scenarios-that-require-pin">Other scenarios that require Pin</a>
          <ul>
            <li><a href="#intrusive-collections">Intrusive collections</a></li>
            <li><a href="#other">Other</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>The <a href="/post/2022-07/rust-pin-unpin/">last article</a> on Pin was a shallow introduction to what Pin is all about and why it is needed, but it is still not enough to master that part of knowledge, so this article hopes to systematically sort out the knowledge points related to Pin, so I named the title &ldquo;Rust Pin Advanced&rdquo;.</p>
<h2 id="pin-api-anatomy">Pin API Anatomy</h2>
<p>To understand Pin in depth, it is essential to be familiar with all of its methods. Excluding the nightly API, Pin has 13 methods in total.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="c1">// Pin&lt;P&gt; where P: Deref
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nc">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new_unchecked</span><span class="p">(</span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="n">P</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">into_inner_unchecked</span><span class="p">(</span><span class="n">pin</span>: <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">P</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">Deref</span><span class="o">&lt;</span><span class="n">Target</span>: <span class="nb">Unpin</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">into_inner</span><span class="p">(</span><span class="n">pin</span>: <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">P</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">map_unchecked</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">func</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">U</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">U</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">get_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">T</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Pin&lt;P&gt; where P: DerefMut
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">DerefMut</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">P</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">set</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">value</span>: <span class="nc">P</span>::<span class="n">Target</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>::<span class="n">Target</span>: <span class="nb">Sized</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">into_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">fn</span> <span class="nf">get_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Unpin</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nc">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_unchecked_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">map_unchecked_mut</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">func</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">U</span>: <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">F</span>: <span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">U</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>These methods can be divided into two broad categories.</p>
<ul>
<li><code>Pin&lt;P&gt; where P: Deref</code></li>
<li><code>Pin&lt;P&gt; where P: DerefMut</code></li>
</ul>
<p>As mentioned in the previous article, Pin is generally represented as <code>Pin&lt;P&lt;T&gt;&gt;</code> (P is the abbreviation for Pointer and T is the abbreviation for Type), so the content wrapped in Pin can only be a smart pointer (any type that implements the <code>Deref</code> trait can be called a smart pointer), and has no meaning for other ordinary types. Since <code>&amp;T</code> and <code>&amp;mut T</code> implement <code>Deref</code> and <code>DerefMut</code> respectively, <code>Pin&lt;&amp;'a T&gt;</code> and <code>Pin&lt;&amp;'a mut T&gt;</code> are considered special implementations of these two classes respectively.</p>
<p>At first glance, these 13 methods look a bit haphazard, but they are actually very well designed, to the point of symmetry. By function, these methods can be divided into 5 major categories, each of which is subdivided into 2 to 3 categories according to mutability or compliance with the <code>T: Unpin</code> restriction. Variable versions end in <code>mut</code>, because <code>unsafe</code> versions that do not conform to the <code>T: Unpin</code> restriction contain <code>unchecked</code>.</p>
<table>
<thead>
<tr>
<th>Functions</th>
<th>Methods</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Construct <code>Pin</code></strong></td>
<td><code>new()</code> / <code>new_unchecked()</code></td>
<td>Distinguish between safe and unsafe versions by whether they satisfy the <code>T: Unpin</code> restriction.</td>
</tr>
<tr>
<td><strong>Convert Pin type</strong></td>
<td><code>as_ref()</code> / <code>as_mut()</code></td>
<td>Converts <code>&amp;/&amp;mut Pin&lt;P&lt;T&gt;&gt;</code> to <code>Pin&lt;&amp;/&amp;mut T&gt;</code>.</td>
</tr>
<tr>
<td><strong>Get the borrow of <code>T</code> inside <code>P&lt;P&lt;T&gt;&gt;</code></strong></td>
<td><code>get_ref()</code> / <code>get_mut()</code> / <code>get_unchecked_mut()</code></td>
<td>consume ownership and get the borrow of <code>T</code> inside. There are two versions by mutability. Since <code>&amp;mut T</code> is the &ldquo;root of all evil&rdquo;, <code>get_mut</code> also distinguishes between safe and unsafe versions according to whether or not they satisfy the <code>T: Unpin</code> restriction.</td>
</tr>
<tr>
<td><strong>Consume Pin ownership and get the pointer inside P</strong></td>
<td><code>into_inner()</code> / <code>into_inner_unchecked()</code></td>
<td>Distinguish between safe and unsafe versions by whether they satisfy the <code>T: Unpin</code> restriction. Also, to avoid conflicts with <code>P</code>&rsquo;s own into class methods, these APIs are designed as static methods that must be called with <code>Pin::into_inner()</code>, not <code>pin.into_inner()</code>.</td>
</tr>
<tr>
<td><strong>Pin projection</strong></td>
<td><code>map_unchecked()</code> / <code>map_unchecked_mut()</code></td>
<td>Usually used for Pin projection.</td>
</tr>
</tbody>
</table>
<p>There are only two methods left that are not categorized in the table above, and they are also relatively simple, namely</p>
<ul>
<li><code>Pin::set()</code> - Sets the new <code>T</code> value in <code>Pin&lt;P&lt;T&gt;&gt;</code>.</li>
<li><code>Pin&lt;&amp;mut Self&gt;::into_ref()</code> - Converts <code>Pin&lt;&amp;mut T&gt;</code> to <code>Pin&lt;&amp;T&gt;</code>.</li>
</ul>
<p>It is worth noting that the implementation of <code>new()</code> and <code>new_unchecked()</code>, <code>get_mut()</code> and <code>get_unchecked_mut()</code>, <code>into_inner()</code> and <code>into_inner_unchecked()</code> are actually identical, the only difference is that the safe version has the <code>Unpin</code> restriction.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nc">Deref</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="o">&lt;</span><span class="n">P</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span>: <span class="nb">Unpin</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="n">pointer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">new_unchecked</span><span class="p">(</span><span class="n">pointer</span>: <span class="nc">P</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Pin</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nb">Unpin</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">pointer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_unchecked_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">pointer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">into_inner</span><span class="p">(</span><span class="n">pin</span>: <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">P</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nc">Deref</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">&lt;</span><span class="n">P</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">Deref</span><span class="o">&gt;</span>::<span class="n">Target</span>: <span class="nb">Unpin</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">pin</span><span class="p">.</span><span class="n">pointer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">fn</span> <span class="nf">into_inner_unchecked</span><span class="p">(</span><span class="n">pin</span>: <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">P</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">pin</span><span class="p">.</span><span class="n">pointer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Why should there be a distinction between safe and unsafe versions of the same code? To answer this question, we have to go back to the nature of <code>Pin</code>. The essence of <code>Pin</code> is to ensure that the memory address of <code>T</code> in <code>Pin&lt;P&lt;T&gt;</code> is not changed (i.e., not moved) under safe Rust unless <code>T</code> satisfies <code>T: Unpin</code>. The essence of ensuring that the memory address of <code>T</code> is not changed is to avoid exposing <code>T</code> or <code>&amp;mut T</code> (&ldquo;the root of all evil&rdquo;). If you expose <code>T</code>, you can just move it; if you expose <code>&amp;mut T</code>, the developer can call methods like <code>std::mem::swap()</code> or <code>std::mem::replace()</code> to move <code>T</code>. Another thing is that the boundary between safe and unsafe in Rust must be very clear and unambiguous. So as long as you don&rsquo;t satisfy <code>T: Unpin</code>, then any method that needs to construct <code>Pin&lt;P&lt;T&gt;&gt;</code>, expose <code>T</code> or <code>&amp;mut T</code> should be unsafe.</p>
<table>
<thead>
<tr>
<th></th>
<th>Satisfy <code>T: Unpin</code></th>
<th>Not Satisfy <code>T: Unpin</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>Construct <code>Pin</code></td>
<td>safe</td>
<td><strong>unsafe</strong></td>
</tr>
<tr>
<td>Exposure <code>T</code></td>
<td>safe</td>
<td><strong>unsafe</strong></td>
</tr>
<tr>
<td>Exposure <code>&amp;T</code></td>
<td>safe</td>
<td>safe</td>
</tr>
<tr>
<td>Exposure <code>&amp;mut T</code></td>
<td>safe</td>
<td><strong>unsafe</strong></td>
</tr>
</tbody>
</table>
<p>For example, <code>into_inner_unchecked()</code> returns <code>P</code>, but it is indirectly exposing <code>T</code> and <code>&amp;mut T</code>. Because you can easily get <code>T</code> or <code>&amp;mut T</code> with <code>*P</code> or <code>&amp;mut *P</code>. And you construct <code>Pin&lt;P&lt;T&gt;&gt;</code> as if you were promising to abide by the <strong>Pin contract</strong>, but this step is clearly a violation of that contract.</p>
<p>Why is <code>Pin::get_ref()</code> safe? Because it returns <code>&amp;T</code>, and there&rsquo;s no way to move it: the <code>std::mem::swap()</code> class method only supports <code>&amp;mut T</code>, and the compiler will error you if you dereference <code>&amp;T</code>. (Thanks again rustc) Another thing to emphasize is the type of internal mutability. For example, for <code>RefCell&lt;T&gt;</code>, <code>Pin&lt;&amp;mut RefCell&lt;T&gt;&gt;.into_ref().get_ref()</code> returns <code>&amp;RefCell&lt;T&gt;</code>, while methods like <code>RefCell&lt;T&gt;::into_inner()</code> can get <code>T</code> and move it. But that&rsquo;s okay, because the contract of <code>Pin&lt;P&lt;T&gt;&gt;</code> is to ensure that <code>T</code> inside <code>P</code> is not moved, and here <code>P</code> is <code>&amp;</code>, and <code>T</code> is <code>RefCell</code>, not <code>T</code> inside <code>RefCell&lt;T&gt;</code>. This is fine as long as there is no additional <code>Pin&lt;&amp;T&gt;</code> pointing to <code>T</code> inside <code>RefCell&lt;T&gt;</code>, but you&rsquo;ve actually eliminated that possibility automatically when you construct <code>RefCell&lt;T&gt;</code>. Because the argument to <code>RefCell::new()</code> is <code>value: T</code>, which already moves <code>T</code> in.</p>
<blockquote>
<p>Similarly, <code>Pin&lt;&amp;mut Box&lt;T&gt;&gt;</code> guarantees that <code>Box&lt;T&gt;</code> itself is not moved, not the <code>T</code> inside <code>Box</code>. To ensure that <code>T</code> inside <code>Box&lt;T&gt;</code> is not moved, just use <code>Pin&lt;Box&lt;T&gt;&gt;</code>.</p>
</blockquote>
<h2 id="pin-additional-attributes">Pin additional attributes</h2>
<h3 id="fundamental">#[fundamental]</h3>
<p>Traits marked with the <code>#[fundamental]</code> attribute are not subject to the orphan rule. So you can give <code>Pin&lt;P&lt;T&gt;&gt;</code> impl your local trait.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">pin</span>::<span class="n">Pin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">LocalTrait</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="n">LocalTrait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="reprtransparent">#[repr(transparent)</h3>
<p><code>#[repr(transparent)]</code> This property allows <code>Pin</code> to have the same ABI layout as the <code>pointer</code> field inside, which can be useful in FFI scenarios.</p>
<blockquote>
<p><a href="https://github.com/rust-lang/rust/pull/51562/">The <code>#[repr(transparent)]</code> attribute is now stable.</a> This attribute allows a Rust newtype wrapper (<code>struct NewType&lt;T&gt;(T);</code> ) to be represented as the inner type across Foreign Function Interface (FFI) boundaries.</p>
</blockquote>
<h2 id="traits-implemented-by-pin">Traits implemented by Pin</h2>
<p>Let&rsquo;s take a look at what traits <code>Pin</code> implements that are of interest.</p>
<h3 id="unpin">Unpin</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nb">Unpin</span> <span class="p">{}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Since <code>Unpin</code> is an auto trait, <code>Pin&lt;P&lt;T&gt;</code> will also achieve <code>Unpin</code> if it satisfies <code>P: Unpin</code>. And almost all <code>P</code>s will be <code>Unpin</code>, so <code>Pin&lt;P&lt;T&gt;&gt;</code> will almost always be <code>Unpin</code>. This implementation is important, especially if the <code>T</code> in question is a <code>Future</code>. It doesn&rsquo;t matter if your <code>Future</code> satisfies <code>Unpin</code> or not, after you wrap it in <code>Pin&lt;&amp;mut ... &gt;</code>, it&rsquo;s a <code>Future</code> that satisfies <code>Unpin</code> (because <code>Pin&lt;P&gt;</code> implements <code>Future</code>, as we&rsquo;ll see later). Many asynchronous methods may require your <code>Future</code> to satisfy <code>Unpin</code> before they can be called, and the <code>Future</code> returned by the <code>async fn</code> method obviously does not satisfy <code>Unpin</code>, so you often need to pin this <code>Future</code> to it. For example, use the macro <a href="https://docs.rs/tokio/latest/tokio/macro.pin.html">tokio::pin!()</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">tokio</span>::<span class="n">pin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">my_async_fn</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// async logic here
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[tokio::main]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">my_async_fn</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">pin</span><span class="o">!</span><span class="p">(</span><span class="n">future</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">future</span><span class="p">).</span><span class="k">await</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Also, it needs to be emphasized again that</p>
<ul>
<li><strong><code>Pin</code> itself is not <code>Unpin</code> has nothing to do with whether <code>T</code> is <code>Unpin</code> or not, only with <code>P</code>.</strong></li>
<li><strong><code>Pin</code> has nothing to do with whether <code>P</code> is <code>Unpin</code> or not, it has to do with <code>T</code>.</strong></li>
</ul>
<p>The above two sentences are a bit confusing, but after you figure it out, you won&rsquo;t be confused about many pin scenarios.</p>
<h3 id="deref-and-derefmut">Deref and DerefMut</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">Deref</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span>::<span class="n">Target</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">P</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Pin</span>::<span class="n">get_ref</span><span class="p">(</span><span class="n">Pin</span>::<span class="n">as_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">P</span>: <span class="nc">DerefMut</span><span class="o">&lt;</span><span class="n">Target</span>: <span class="nb">Unpin</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">P</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Pin</span>::<span class="n">get_mut</span><span class="p">(</span><span class="n">Pin</span>::<span class="n">as_mut</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>These two traits are critical to <code>Pin</code>. Only when <code>Deref</code> is implemented is <code>Pin&lt;P&gt;</code> a smart pointer, so that the developer can seamlessly call the methods of <code>P</code>. It is important to note that <code>DerefMut</code> is implemented for <code>Pin&lt;P&lt;T&gt;&gt;</code> only if <code>T: Unpin</code> is satisfied. This is because one of the responsibilities of <code>Pin&lt;P&lt;T&gt;&gt;</code> under Safe Rust is to not expose <code>&amp;mut T</code> without satisfying <code>T: Unpin</code>.</p>
<p>In addition, after implementing these two traits, you can dereference <code>&amp;T</code> and <code>&amp;mut T</code> respectively, but there is a difference between this dereference and <code>get_ref()</code> and <code>get_mut()</code>. Take <code>&amp;T</code> for example, suppose there is <code>let p = Pin::new(&amp;T);</code>, dereference <code>p</code> to get <code>&amp;T</code>: <code>let t = &amp;*p</code>;, here the lifecycle of <code>&amp;T</code> is actually equal to the lifecycle of <code>&amp;Pin::new(&amp;T)</code>. And <code>Pin::new(&amp;T).get_ref()</code> gets the lifecycle of <code>&amp;T</code> and the lifecycle of <code>Pin</code> itself are equal.</p>
<p>Why is this the case? Let&rsquo;s look at the syntactic sugar of dereferenced smart pointers after we expand it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">T</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// let t = &amp;*p; After expanding the syntactic sugar as follows.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;*</span><span class="n">Deref</span>::<span class="n">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The code for <code>Pin</code>&rsquo;s <code>Deref</code> implementation is: <code>Pin::get_ref(Pin::as_ref(self))</code>, while the code for <code>Pin::as_ref()</code> is as follows. By comparison, you can see that the lifecycle of <code>&amp;T</code> obtained by dereferencing is indeed different from that obtained by <code>get_ref()</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">P</span>: <span class="nc">Deref</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="n">P</span>::<span class="n">Target</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="o">&amp;*</span><span class="bp">self</span><span class="p">.</span><span class="n">pointer</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Compare this to the Deref implementation above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span>: <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Pin</span><span class="o">&lt;&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">fn</span> <span class="nf">get_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="o">&#39;</span><span class="na">a</span> <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">pointer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Another thing worth noting is that <code>Pin::as_ref()</code> and <code>Pin::as_mut()</code> will dereference <code>self.pointer</code>, which actually calls its <code>deref()</code> or <code>deref_mut()</code> methods. These two methods are implemented by <code>P</code> itself, so there is a possibility of a &ldquo;malicious implementation&rdquo; of <code>T</code> move here. But this &ldquo;malicious implementation&rdquo; will be ruled out by <strong>Pin&rsquo;s contract</strong>: this is caused by your own &ldquo;malicious implementation&rdquo;, not by using <code>Pin</code>.</p>
<blockquote>
<p>The documentation for <code>Pin::new_unchecked()</code> makes a point of emphasizing this point.
By using this method, you are making a promise about the P::Deref and P::DerefMut implementations, if they exist. Most importantly, they must not move out of their self arguments: Pin::as_mut and Pin::as_ref will call DerefMut::deref_mut and Deref::deref on the pinned pointer and expect these methods to uphold the pinning invariants.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">pin</span>::<span class="n">Pin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">marker</span>::<span class="n">PhantomPinned</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ptr</span>::<span class="n">NonNull</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="p">{</span><span class="n">Deref</span><span class="p">,</span><span class="w"> </span><span class="n">DerefMut</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Unmovable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">data</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">slice</span>: <span class="nc">NonNull</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">_pin</span>: <span class="nc">PhantomPinned</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Unmovable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">data</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Pin</span><span class="o">&lt;</span><span class="n">Boz</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Unmovable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">data</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">slice</span>: <span class="nc">NonNull</span>::<span class="n">dangling</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">_pin</span>: <span class="nc">PhantomPinned</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bozed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">new_unchecked</span><span class="p">(</span><span class="n">Boz</span><span class="p">(</span><span class="n">res</span><span class="p">))</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NonNull</span>::<span class="n">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bozed</span><span class="p">.</span><span class="n">data</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// we know this is safe because modifying a field doesn&#39;t move the whole struct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">mut_ref</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Pin</span>::<span class="n">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bozed</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Pin</span>::<span class="n">get_unchecked_mut</span><span class="p">(</span><span class="n">mut_ref</span><span class="p">).</span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slice</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">bozed</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Default</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Unmovable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">default</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Unmovable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">data</span>: <span class="nb">String</span>::<span class="n">new</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">slice</span>: <span class="nc">NonNull</span>::<span class="n">dangling</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">_pin</span>: <span class="nc">PhantomPinned</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Boz</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Deref</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Boz</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// &#34;Malicious&#34; implementations of DerefMut
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Default</span><span class="o">&gt;</span><span class="w"> </span><span class="n">DerefMut</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Boz</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w">  </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="bp">Self</span>::<span class="n">Target</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span>::<span class="n">mem</span>::<span class="n">take</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">unmovable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Unmovable</span>::<span class="n">new</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Malicious!!!&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">unmovable</span><span class="p">.</span><span class="n">as_mut</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>In the above example, we construct a <code>Pin&lt;Boz&lt;Unmovable&gt;&gt;</code>, and then call the <code>as_mut()</code> method to dereference this <code>Boz</code>, which has a &ldquo;malicious&rdquo; <code>DerefMut</code> implementation that moves away this <code>Unmovable</code>. But I obviously have it <code>Pin</code> in place.</p>
<h3 id="future">Future</h3>
<p><code>Pin</code> also implements <code>Future</code>, which is closely related to <code>Unpin</code>, so we&rsquo;ll cover that in the next section.</p>
<h2 id="unpin-and-future">Unpin and Future</h2>
<p>One of the big things that confuses beginners about Rust&rsquo;s pinning API is the introduction of <code>Unpin</code>, which can often be confusing, so it&rsquo;s important to get a thorough understanding of <code>Unpin</code>, and in particular its relationship to <code>Future</code>.</p>
<p>As mentioned before, <code>Unpin</code> is an auto trait, and almost all types implement <code>Unpin</code>, including some types you didn&rsquo;t realize. For example.</p>
<ul>
<li><strong>&amp;T</strong>: <code>impl&lt;'a, T: ?Sized + 'a&gt; Unpin for &amp;'a T {}</code></li>
<li><strong>&amp;mut T</strong>: <code>impl&lt;'a, T: ?Sized + 'a&gt; Unpin for &amp;'a mut T {}</code></li>
<li>*<strong>const T</strong>: <code>impl&lt;T: ?Sized&gt; Unpin for *const T {}</code></li>
<li>*<strong>mut T</strong>: <code>impl&lt;T: ?Sized&gt; Unpin for *mut T {}</code></li>
<li>Other, including <code>Box</code>, <code>Arc</code>, <code>Rc</code>, etc.</li>
</ul>
<p>Note that here they are <code>Unpin</code> regardless of whether <code>T</code> satisfies <code>T: Unpin</code> or not. The reason for this has already been stated: <strong>The ability of <code>Pin</code> to pin <code>T</code> has nothing to do with whether <code>P</code> is <code>Unpin</code> or not, but only with <code>T</code>.</strong></p>
<blockquote>
<p>As mentioned in the previous article, only <strong>std::marker::PhatomPinned</strong>, which contains the type <strong>PhatomPinned</strong>, and <code>.await</code> the structure that follows the desyntactic sugar is <code>!Unpin</code>, which is not repeated here.</p>
</blockquote>
<h3 id="unpin-is-a-safe-trait">Unpin is a safe trait</h3>
<p>Another important feature: <code>Unpin</code> is a safe trait, which means you can implement <code>Unpin</code> for any type under safe Rust, including your <code>Future</code> type.</p>
<p>We prepare two assert functions in advance, which will be used later.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">assert_future</span><span class="o">&lt;</span><span class="n">F</span>: <span class="nc">Future</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_f</span>: <span class="nc">F</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">assert_unpin</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nb">Unpin</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_t</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">future</span>::<span class="n">Future</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">pin</span>::<span class="n">Pin</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">task</span>::<span class="p">{</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="n">Poll</span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[derive(Clone)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Dummy</span><span class="p">(</span><span class="nb">String</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Dummy</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">_cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Poll</span>::<span class="n">Ready</span><span class="p">(())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Without this line, the compiler will also automatically implement Unpin for you
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">impl</span><span class="w"> </span><span class="nb">Unpin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Dummy</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">dummy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dummy</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello world!&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">assert_future</span><span class="p">(</span><span class="n">dummy</span><span class="p">.</span><span class="n">clone</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">assert_unpin</span><span class="p">(</span><span class="n">dummy</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If you want to poll this <code>Dummy</code> future in another <code>Future</code> it&rsquo;s no problem at all. The <code>futures</code> crate even provides a series of <a href="https://docs.rs/futures/latest/futures/index.html?search=unpin">unpin versions of methods</a> to help you do this, such as <a href="https://docs.rs/futures/latest/futures/future/trait.FutureExt.html#method.poll_unpin">FutureExt::poll_ unpin()</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">FutureExt</span>: <span class="nc">Future</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="sd">/// A convenience for calling `Future::poll` on `Unpin` future types.
</span></span></span><span class="line"><span class="cl"><span class="sd"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">poll_unpin</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">Self</span>: <span class="nb">Unpin</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Pin</span>::<span class="n">new</span><span class="p">(</span><span class="bp">self</span><span class="p">).</span><span class="n">poll</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>You can see that this is <code>&amp;mut self</code>, not <code>self: Pin&lt;&amp;mut Self&gt;</code>.</p>
<p>However, the pin projection scenario requires special attention, if you have a field of type <code>!Unpin</code>, you can&rsquo;t implement <code>Unpin</code> for this type. See the official website <a href="https://doc.rust-lang.org/std/pin/index.html#pinning-is-structural-for-field">Pinning <em>is</em> structural for field</a> for details.</p>
<h3 id="why-future-can-be-unpin">Why Future can be Unpin</h3>
<p>Some people may ask, &ldquo;Wasn&rsquo;t <strong>Pin</strong> originally designed to solve the problem of self-referencing structures that don&rsquo;t get moved when implementing <code>Future</code>? Why is it possible to implement <code>Unpin</code> for the <code>Future</code> type? The reason is this: if you implement <code>Future</code> as a self-referential structure, then of course it can&rsquo;t be <code>Unpin</code>, but otherwise it&rsquo;s perfectly fine to implement <code>Unpin</code>. The example above, and many third-party libraries&rsquo; <code>Future</code> types, do not have self-referential structs, so you can move with confidence, so it can be <code>Unpin</code>. Another advantage is that you can use the safe version of the <code>Pin::new()</code> method to construct <code>Pin</code> to poll future, without having to deal with unsafe.</p>
<h3 id="pins-future-implementation">Pin&rsquo;s Future implementation</h3>
<p>The reason we moved here to talk about the <code>Future</code> implementation of <code>Pin</code> is that <strong>1.56</strong> has a PR <a href="https://github.com/rust-lang/rust/pull/81363">#81363</a> that removes the <code>P: Unpin</code> restriction. Let&rsquo;s first look at why we need to implement <code>Future</code> for <code>Pin</code>, and then analyze why the <code>Unpin</code> restriction can be let go here.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl"><span class="gd">-   P: Unpin + ops::DerefMut&lt;Target: Future&gt;,
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+   P: ops::DerefMut&lt;Target: Future&gt;,
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>{
</span></span><span class="line"><span class="cl">    type Output = &lt;&lt;P as ops::Deref&gt;::Target as Future&gt;::Output;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;&#39;_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span></span><span class="line"><span class="cl"><span class="gd">-       Pin::get_mut(self).as_mut().poll(cx)
</span></span></span><span class="line"><span class="cl"><span class="gd"></span><span class="gi">+       &lt;P::Target as Future&gt;::poll(self.as_deref_mut(), cx)
</span></span></span><span class="line"><span class="cl"><span class="gi"></span>        // self.as_deref_mut() is actually unsafe { self.get_unchecked_mut() }.as_mut()
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p>The reason for implementing <code>Future</code> for <code>Pin</code> is simply to make it easier to call <code>poll()</code>, especially in the pin projection scenario. Since <code>self</code> of <code>poll()</code> is of type <code>Pin&lt;&amp;mut Self&gt;</code>, you can&rsquo;t call <code>poll()</code> directly with <code>future</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">error[E0599]: no method named `poll` found for struct `Dummy` in the current scope
</span></span><span class="line"><span class="cl">  --&gt; src/main.rs:35:20
</span></span><span class="line"><span class="cl">   |
</span></span><span class="line"><span class="cl">35 |         Dummy(String::from(&#34;hello world!&#34;)).poll(cx)
</span></span><span class="line"><span class="cl">   |                                             ^^^^ method not found in `Dummy`
</span></span></code></pre></td></tr></table>
</div>
</div><p>You have to construct a <code>Pin&lt;&amp;mut Dummy&gt;</code> before you can call <code>poll()</code>. After implementing <code>Future</code> for <code>Pin</code>, you can just write: <code>Pin::new(&amp;mut dummy).poll(ctx)</code>, otherwise you need to write <code>Future::poll(Pin::new(&amp;mut dummy), ctx)</code>.</p>
<p>Again, let&rsquo;s see why <code>P::Unpin</code> is not needed here. First, the purpose of this method is to poll <code>P::Target</code>, a <code>Future</code>, and the <code>Self</code> of the <code>poll()</code> method is <code>Pin&lt;P&lt;T&gt;&gt;</code> and <code>self</code> is <code>Pin&lt;&amp;mut Pin&lt;P&lt;T&gt;&gt;&gt;</code> (note that there are two layers of <code>Pin</code> here). We need to safely convert <code>Pin&lt;&amp;mut Pin&lt;P&lt;T&gt;&gt;&gt;</code> to <code>Pin&lt;&amp;mut T&gt;&gt;</code> in order to call <code>poll()</code> on <code>P::Target</code>. It&rsquo;s easy to get <code>Pin&lt;&amp;mut T&gt;</code>, there&rsquo;s <code>Pin::as_mut()</code>, and both versions end up calling <code>as_mut()</code>, so there&rsquo;s no problem here. But the signature of <code>as_mut()</code> is <code>&amp;mut self</code>, which means we have to get <code>&amp;mut Pin&lt;P&lt;T&gt;&gt;</code> first. If we reduce <code>Pin&lt;&amp;mut Pin&lt;P&lt;T&gt;&gt;&gt;</code> to the basic form <code>Pin&lt;P&lt;T&gt;&gt;</code>, then <code>&amp;mut</code> is the <code>P</code> and <code>Pin&lt;P&lt;T&gt;&gt;</code> is the <code>T</code>. To get <code>&amp;mut Pin&lt;P&lt;T&gt;&gt;&gt;</code> from <code>Pin&lt;&amp;mut Pin&lt;P&lt;T&gt;&gt;</code> is actually to get <code>&amp;mut T</code> from <code>Pin&lt;P&lt;T&gt;&gt;</code>. Both <code>get_mut()</code> and <code>get_unchecked_mut()</code> methods are satisfied, the only difference is the <code>Unpin</code> restriction, which is where that PR change comes in. Without the <code>Unpin</code> restriction, we would have to use the unsafe version of <code>get_unchecked_mut()</code>. But it&rsquo;s completely safe here, because we call <code>as_mut()</code> as soon as we get <code>&amp;mut Pin&lt;P&lt;T&gt;&gt;</code>, and we don&rsquo;t move it. So the previous <code>P: Unpin</code> is redundant. For more details, see the documentation and source code comments for <a href="https://doc.rust-lang.org/std/pin/struct.Pin.html#method.as_deref_mut">Pin::as_deref_mut()</a>.</p>
<h3 id="why-unpin-constraints-are-needed">Why Unpin constraints are needed</h3>
<p>As mentioned above, some asynchronous-related APIs require your type to meet <code>Unpin</code> in order to be called. As far as I can tell, these APIs fall into three general categories.</p>
<ol>
<li>Scenarios that require <code>&amp;mut future</code>. **For example, <a href="https://docs.rs/tokio/latest/tokio/macro.select.html">tokio::select!()</a>, a macro that requires your <code>Future</code> to satisfy <code>Unpin</code>.</li>
<li>The <code>AsyncRead</code> / <code>AsyncWrite</code> scenario. **For example, the method <a href="https://docs.rs/tokio/latest/tokio/io/trait.AsyncWriteExt.html">tokio::io::AsyncWriteExt</a> requires your <code>Self</code> to satisfy <code>Unpin</code>.</li>
<li><code>Future</code> itself is <code>Unpin</code> compliant and does not want to deal directly with <code>Pin</code>. **The <code>FutureExt::poll_unpin()</code> method mentioned above falls into this category.</li>
</ol>
<p>Class (2) is mainly related to <code>self</code> of <code>AsyncRead</code> / <code>AsyncWrite</code> which requires <code>Pin&lt;&amp;mut Self&gt;</code>, there are quite a few discussions about this in the community, not the focus of this article, check the following information if you are interested.</p>
<ul>
<li>futures-rs: <a href="https://github.com/rust-lang/futures-rs/issues/1454">Should AsyncRead and AsyncWrite take self by Pin?</a></li>
<li>tokio: <a href="https://github.com/tokio-rs/tokio/issues/1272">Should AsyncRead/AsyncWrite required pinned self?</a></li>
<li><a href="https://users.rust-lang.org/t/tokios-asyncreadext-and-asyncwriteext-require-self-unpin-why-and-what-to-do-about-it/64134/4">Tokio&rsquo;s AsyncReadExt and AsyncWriteExt require Self: Unpin. Why and what to do about it?</a></li>
</ul>
<p>Second, tower is also considering whether to add <code>Pin&lt;&amp;mut Self&gt;</code>: <a href="https://github.com/tower-rs/tower/issues/319">Pinning and Service</a>.</p>
<p>Regarding class (1), the main reason is that the implementation of <code>Future</code> for <code>&amp;mut Future</code> specifies the need for <code>F: Unpin</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">F</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Unpin</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">F</span>::<span class="n">poll</span><span class="p">(</span><span class="n">Pin</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">**</span><span class="bp">self</span><span class="p">),</span><span class="w"> </span><span class="n">cx</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>So it comes down to figuring out why we need <code>Unpin</code> here. Let&rsquo;s start with a scenario where we have a <code>future</code> that we need to keep polling in a <code>loop</code>, but <code>Future::poll()</code> consumes ownership of <code>self</code> every time it is called. So we need to mutably borrow this <code>future</code> to avoid consuming ownership of <code>future</code>. But after <code>&amp;mut future</code> there is a risk of moving the <code>future</code> (&ldquo;the root of all evil&rdquo;), so either your <code>future</code> is <code>Unpin</code> or you have to pin it and borrow it mutably (i.e. <code>&amp;mut Pin&lt;&amp;mut future&gt;</code>). And it just so happens that <code>Pin&lt;P&gt; where P: DerefMut</code> implements <code>Future</code>! (as mentioned in the previous section) and <code>Pin&lt;P&gt;</code> also satisfies <code>Unpin</code>! It&rsquo;s so perfect that we can just implement <code>Future</code> for <code>&amp;mut F</code>, as long as <code>F</code> satisfies <code>Future + Unpin</code>. The advantage of this is that if your <code>future</code> satisfies <code>Unpin</code>, then you can just poll it multiple times in the <code>loop</code> and not worry about the move; if your <code>future</code> doesn&rsquo;t satisfy <code>Unpin</code>, that&rsquo;s fine, just pin it. For example, in the following example, because <a href="https://docs.rs/tokio/latest/tokio/time/struct.Sleep.html">tokio::time::Sleep</a> doesn&rsquo;t satisfy <code>Unpin</code>, you need to pin it with <code>tokio::pin!()</code> before you can compile it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">tokio</span>::<span class="n">time</span>::<span class="p">{</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">Duration</span><span class="p">,</span><span class="w"> </span><span class="n">Instant</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cp">#[tokio::main]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">async</span><span class="w"> </span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">sleep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">time</span>::<span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">tokio</span>::<span class="n">pin</span><span class="o">!</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">tokio</span>::<span class="n">select</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">sleep</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;timer elapsed&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">sleep</span><span class="p">.</span><span class="n">as_mut</span><span class="p">().</span><span class="n">reset</span><span class="p">(</span><span class="n">Instant</span>::<span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Duration</span>::<span class="n">from_millis</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>By the same token, the implementation of <code>Future</code> for <code>Box&lt;F&gt;</code> also requires <code>Unpin</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="o">&lt;</span><span class="n">F</span>: <span class="o">?</span><span class="nb">Sized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">Unpin</span><span class="p">,</span><span class="w"> </span><span class="n">A</span>: <span class="nc">Allocator</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Future</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">A</span>: <span class="o">&#39;</span><span class="nb">static</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">Output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">F</span>::<span class="n">Output</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span>: <span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">cx</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;&#39;</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Poll</span><span class="o">&lt;</span><span class="bp">Self</span>::<span class="n">Output</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">F</span>::<span class="n">poll</span><span class="p">(</span><span class="n">Pin</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">),</span><span class="w"> </span><span class="n">cx</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="other-scenarios-that-require-pin">Other scenarios that require Pin</h2>
<p>I often encounter people asking questions like &ldquo;Do I need to use <code>Pin</code> to solve this scenario?&rdquo; I look at the question and see that it has nothing to do with <code>Pin</code>, so I reply with this classic quote.</p>
<blockquote>
<p>Rust Community Quote: <strong>Whenever you wonder if Pin could be the solution, it isn&rsquo;t.</strong></p>
</blockquote>
<p>The <strong>Pinning API</strong> is designed for generality, not just to solve the problem of self-referential struct move in asynchronous, but also for other scenarios where <code>Pin</code> is needed.</p>
<h3 id="intrusive-collections">Intrusive collections</h3>
<p><strong>Intrusive collections</strong> is another application scenario for <code>Pin</code>. The documentation for <code>Pin</code> mentions the example of <strong>intrusive doubly-linked list</strong>, but it is similar for other intrusive data structures (e.g. intrusive single-linked tables). However, the documentation is only a few sentences, which is not very good, so I will briefly summarize it here.</p>
<p>First of all, you need to understand what <strong>intrusive collections</strong> are. Almost all the data structures we use in collections are <strong>non-intrusive</strong>, such as the standard library <code>Vec</code>, <code>LinkedList</code> and so on. The characteristic of <strong>non-intrusive</strong> type collections is that the elements in the collection are completely decoupled from the collection itself, the collection does not need to care what type each element is, and the collection can be used to hold elements of any type. However, a collection of type <strong>intrusive</strong> is a completely intrusive collection, where the <code>prev</code> or <code>next</code> pointer is defined on top of the element.</p>
<p>Using C++ as an example, a <strong>non-intrusive</strong> doubly linked list can be defined like this</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">ListNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>And the <strong>intrusive</strong> version needs to be written like this</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Point</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Point</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The pseudo-code for the Rust version of <strong>intrusive</strong> would probably also look like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Point</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">x</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">y</span>: <span class="kt">f64</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">prev</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">next</span>: <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>You can see that the biggest difference between the two is whether the pointer is placed on top of the collection or on top of the element. The two types of collections have their own advantages and disadvantages, while the <strong>intrusive</strong> type has the advantage of better performance and the disadvantage of not being generic and requiring repeated definitions of collections for different elements. Related knowledge is not the focus of this article, for more details you can take a look at the following information.</p>
<ul>
<li><a href="https://fuchsia.dev/fuchsia-src/development/languages/c-cpp/fbl_containers_guide/introduction">Invasive containers provided by Google Fuchsia</a></li>
<li><a href="https://www.data-structures-in-practice.com/intrusive-linked-lists/">Intrusive linked lists</a></li>
<li><a href="https://www.ralfj.de/blog/2018/04/10/safe-intrusive-collections-with-pinning.html">Safe Intrusive Collections with Pinning</a></li>
</ul>
<p>So why do intrusive collections need to use <code>pins</code>? The reason is that elements have a prev or next pointer to each other, so if one element in the middle moves, the pointer address of the other elements to it will be invalid, resulting in unsafe behavior. Rust has a library called <a href="https://docs.rs/intrusive-collections">intrusive-collections</a> that provides many intrusive collection types, and Tokio also defines <a href="https://docs.rs/tokio/latest/src/tokio/util/linked_list.rs.html">intrusive collections</a>, and no doubt they all use <code>pins</code>.</p>
<h3 id="other">Other</h3>
<p>In fact, as long as we need to deal with the scenario of preventing being moved, theoretically we need to use <code>Pin</code> to solve it. I can&rsquo;t think of any other cases for now, so I&rsquo;ll add them later if I find any new ones, or if you know of others, please let me know.</p>
<h2 id="summary">Summary</h2>
<p>This article is a little long, so let&rsquo;s summarize.</p>
<ul>
<li>The API for <code>Pin</code> is very well designed, even full of symmetry, and its methods can be roughly divided into 5 categories. It involves <code>Unpin</code> and <code>&amp;mut T</code> which can be subdivided into safe and unsafe.</li>
<li><code>#[fundamental]</code> and <code>#[repr(transparent)]</code> of <code>Pin</code> are important, but you generally don&rsquo;t need to care about it.</li>
<li>The traits implemented by <code>Pin</code> need to focus on <code>Unpin</code>, <code>Deref</code> / <code>DerefMut</code> and <code>Future</code>, and understanding them will allow you to fully master <code>Pin</code>.</li>
<li><code>Unpin</code> and <code>Future</code> are very closely related. <code>Unpin</code> is a safe trait that can theoretically be implemented arbitrarily, and <code>Future</code> can also be <code>Unpin</code>. Some asynchronous APIs may require <code>Unpin</code> restrictions, and the reason for it needs to be understood, not just used.</li>
<li><code>Pin</code> is a generic API, and there will be other scenarios that require <code>Pin</code> in addition to <code>async / await</code>, such as <strong>intrusive collections</strong>.</li>
</ul>
<p>The <strong>Pin projection</strong>, mentioned several times in the article, is not expanded, so we will discuss it in detail in the next article. See you soon!</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/rust/">rust</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/floating-point-inaccurate/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Why floating-point arithmetic is inaccurate</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-07/rust-pin-unpin/">
            <span class="next-text nav-default">Pin and Unpin in Rust</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
