<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Summary of eviction strategy for k8s standalone - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In this paper, we summarize the eviction process and process selection strategies under different levels from k8s." /><meta name="keywords" content="k8s, Eviction" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-07/k8s-eviction/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Summary of eviction strategy for k8s standalone" />
<meta property="og:description" content="In this paper, we summarize the eviction process and process selection strategies under different levels from k8s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-07/k8s-eviction/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-09T17:01:34+08:00" />
<meta property="article:modified_time" content="2022-07-09T17:01:34+08:00" />

<meta itemprop="name" content="Summary of eviction strategy for k8s standalone">
<meta itemprop="description" content="In this paper, we summarize the eviction process and process selection strategies under different levels from k8s."><meta itemprop="datePublished" content="2022-07-09T17:01:34+08:00" />
<meta itemprop="dateModified" content="2022-07-09T17:01:34+08:00" />
<meta itemprop="wordCount" content="4213">
<meta itemprop="keywords" content="k8s," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Summary of eviction strategy for k8s standalone"/>
<meta name="twitter:description" content="In this paper, we summarize the eviction process and process selection strategies under different levels from k8s."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Summary of eviction strategy for k8s standalone</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-07-09 17:01:34 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4213 words </span>
          <span class="more-meta"> 20 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#kubelet-eviction-policy">Kubelet eviction policy</a>
          <ul>
            <li><a href="#eviction-manager">Eviction manager</a></li>
            <li><a href="#expulsion-control-loop">Expulsion control loop</a></li>
          </ul>
        </li>
        <li><a href="#system-eviction-policy">System Eviction Policy</a>
          <ul>
            <li><a href="#oom-killer">OOM killer</a></li>
          </ul>
        </li>
        <li><a href="#oom-killer-in-user-space">oom killer in user space</a>
          <ul>
            <li><a href="#operation-mechanism">Operation mechanism</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Process eviction: When there is resource pressure on a machine, it may be due to a malicious program that is consuming system resources, or due to overcommit. The system reduces the overall impact of a single program on the system by controlling the survival of processes on the machine. The most critical aspect of the eviction phase is to select the right process to ensure system stability by minimizing the cost. There are two types of eviction at the execution level.</p>
<ul>
<li>User-space eviction: triggered active process cleanup through mechanisms like daemons.</li>
<li>Kernel space eviction: The kernel selects processes to terminate to release resources through oom_killer when memory cannot be allocated.</li>
</ul>
<p>In this article, we summarize the eviction process and process selection strategy at different levels from k8s.</p>
<h2 id="kubelet-eviction-policy">Kubelet eviction policy</h2>
<p>k8s supports API-initiated active eviction as well as user-space pod eviction (termination of resource-intensive processes). For incompressible resources: memory, disk (nodefs), pid, kubelet monitors the corresponding metrics to trigger pod eviction. k8S evicts pods to reclaim resources based on their resource consumption and priority.</p>
<ul>
<li>If a pod&rsquo;s resource usage exceeds the resource request value, it will be evicted first.</li>
<li>Eviction based on pod priority</li>
<li>The higher the real resource usage of a pod, the higher the priority of eviction</li>
</ul>
<p>We can conclude the following.</p>
<ul>
<li>When the resource usage of BestEffort and Burstable pods exceeds the requested value, the eviction order is determined based on the pod priority and how much it exceeds the request. There is also no risk that a special case pod can be evicted without being evicted. When the usage of the Guaranteed and Busrtable pods is lower than the requested value, the eviction order is determined based on pod priority.</li>
</ul>
<p>All this logic is implemented in the eviction manager of the kubelet.</p>
<h3 id="eviction-manager">Eviction manager</h3>
<p>The interface definition of the manager contains the start function of the main process and the one provided to the kubelet to report the node status.</p>
<ul>
<li><code>Start()</code>: starts the eviction control loop, gets monitoring data, and determines if the resources reach the threshold, triggers the eviction of the pod, and updates the local node status when the node is under pressure.</li>
<li><code>IsUnderMemoryPressure()</code>: determine whether the node reaches the memory limit pressure, judged by the node status updated within the control loop.</li>
<li><code>IsUnderDiskPressure()</code>: Determines if the node has reached the disk limit pressure, judged by the node status updated within the control loop.</li>
<li><code>IsUnderPIDPressure()</code>: Determines if the node has reached the PID limit pressure, as determined by the node status updated within the control loop.</li>
</ul>
<p>The kubelet will call the above method to determine the resource pressure of the node in the tryUpdateNodeStatus reporting node status loop.</p>
<p>After initializing the evictionManager, kubelet will call evictionManager.Start() to start the eviction and then call the above pressure judgment method when synchronizing the node status. In addition to implementing the interface of Manager, it also implements the PodAdmitHandler interface which is responsible for evaluating the allowed pod execution during the pod lifecycle. evictionManager is mainly based on the nature of the pod to determine whether the container can be created on a machine that already has resource pressure.</p>
<h3 id="expulsion-control-loop">Expulsion control loop</h3>
<h4 id="initialization-phase">Initialization phase</h4>
<p>The kubelet main process parses the configuration and initializes the evictionManager, parsing the resource threshold parameter ParseThresholdConfig() for the single machine</p>
<p>The kubelet sets resource thresholds in the signal dimension, each signal identifies a resource metric that defines the resource threshold and other eviction parameters. For example, <code>memory.available</code> indicates the node&rsquo;s available memory eviction marker (memory.available = capacity - workingSet).</p>
<p>The kubelet determines the resource signal property with the following parameters to construct the threshold for the corresponding resource.</p>
<ul>
<li><code>--eviction-hard mapStringString</code>: resource eviction hard downlink, default is: imagefs.available&lt;15%,memory.available&lt;100Mi,nodefs.available&lt;10%</li>
<li><code>--eviction-soft mapStringString</code>: soft downlink of resource eviction, when triggered, pod has graceful exit time.</li>
<li><code>--eviction-soft-grace-period mapStringString</code>: graceful exit time for pod eviction when yellow line is triggered.</li>
<li><code>--eviction-minimum-reclaim mapString</code>: the minimum amount of resources to be released. Default is 0.</li>
</ul>
<p>The eviction-soft and soft-grace-period configurations for the same resource must both exist.</p>
<p>After setting the threshold for each resource signal by parsing the configuration items, the kubelet calls evictionManager.Start() to drive the evictionManager to work.</p>
<p>After setting the threshold value of each resource signal by parsing the configuration items, kubelet calls evictionManager.Start() to drive evictionManager to work.</p>
<h4 id="start-of-evictionmanager">Start of evictionManager</h4>
<p>Before starting the control loop, evictionManager adds preprocessing for cgroup memory subsystem monitoring. This preprocessing listens for mem cgroup usage through the mechanism of <strong>cgroup notifier</strong> and periodically updates the cgroup notifier threshold configuration during the control loop.</p>
<h5 id="memorythresholdnotifier">MemoryThresholdNotifier</h5>
<p>The evictionManager configures MemoryThresholdNotifier for <code>memory.available</code> and <code>allocatableMemory.available</code> signal respectively, monitoring different cgroup paths. <code>allocatableMemory.available</code> has the root cgroupRoot, which is the root cgroup of the pods on the node. <code>memory.available</code> monitors the <code>/proc/cgroups/memory</code> directory.</p>
<p>The workflow of MemoryThresholdNotifier is as follows.</p>
<ul>
<li>Initialize MemoryThresholdNotifier</li>
<li>MemoryThresholdNotifier needs to get the cgoup memory subsystem path of the cgroup directory and set evictionManager.synchronize() to the threshold processing function thresholdHandler</li>
<li>Create goroutine to start MemoryThresholdNotifier</li>
<li>In MemoryThresholdNotifier.Start() loop: listen for the event channel and call the eviction function (call synchronize)</li>
<li>UpdateThreshold() is called in the synchronize phase to update the memcg threshold and activate MemoryThresholdNotifier.</li>
<li>Calculate the cgroup memory usage threshold based on the current collection metric configuration.</li>
<li>If there is already a notifier instance of MemoryThresholdNotifier, create a new cgroupNotifier to replace it. cgroupNotifier listens for memory over threshold events by epolling the eventfd descriptor above.</li>
</ul>
<p>There are two key points here.</p>
<ol>
<li>
<p>calculate the cgroup memory usage threshold in the UpdateThreshold function</p>
<p>As mentioned above, the memory usage (not including swap) is obtained by listening to the memory.usage_in_bytes file when the memory usage threshold is reached. And the memory usage threshold <strong>memcgThreshold</strong> is obtained by monitoring the data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Set threshold on usage to capacity - eviction_hard + inactive_file,
</span></span></span><span class="line"><span class="cl"><span class="c1">// since we want to be notified when working_set = capacity - eviction_hard
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">inactiveFile</span> <span class="o">:=</span> <span class="nx">resource</span><span class="p">.</span><span class="nf">NewQuantity</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="o">*</span><span class="nx">memoryStats</span><span class="p">.</span><span class="nx">UsageBytes</span><span class="o">-*</span><span class="nx">memoryStats</span><span class="p">.</span><span class="nx">WorkingSetBytes</span><span class="p">),</span> <span class="nx">resource</span><span class="p">.</span><span class="nx">BinarySI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">capacity</span> <span class="o">:=</span> <span class="nx">resource</span><span class="p">.</span><span class="nf">NewQuantity</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="o">*</span><span class="nx">memoryStats</span><span class="p">.</span><span class="nx">AvailableBytes</span><span class="o">+*</span><span class="nx">memoryStats</span><span class="p">.</span><span class="nx">WorkingSetBytes</span><span class="p">),</span> <span class="nx">resource</span><span class="p">.</span><span class="nx">BinarySI</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">evictionThresholdQuantity</span> <span class="o">:=</span> <span class="nx">evictionapi</span><span class="p">.</span><span class="nf">GetThresholdQuantity</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">threshold</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">capacity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">memcgThreshold</span> <span class="o">:=</span> <span class="nx">capacity</span><span class="p">.</span><span class="nf">DeepCopy</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">memcgThreshold</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="o">*</span><span class="nx">evictionThresholdQuantity</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">memcgThreshold</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="o">*</span><span class="nx">inactiveFile</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The absolute value of the calculated memory usage threshold <strong>memcgThreshold</strong> is calculated by capacity - eviction_hard (based on capacity * percentage if the red line is not absolute) + inactive_file.</p>
<p>Where</p>
<ul>
<li>memory capacitycapacity = memoryStats.AvailableBytes + memoryStats.WorkingSetBytes, i.e. memory available + workload used (both values are obtained from the monitoring module)</li>
<li>Hard down eviction_hard is the parameter value</li>
<li>inactive_file = memoryStats.UsageBytes - memoryStats.WorkingSetBytes, i.e. memory used - workload used (contains recently used memory, dirty memory to be reclaimed and kernel occupied memory, both values are also obtained from the monitoring module) (both values are also obtained from the monitoring module).</li>
</ul>
</li>
<li>
<p>Create cgroupNotifier in UpdateThreshold function</p>
<p>The mechanism of <strong>cgroup notifier</strong> is to listen for events when memory usage in cgroup exceeds the threshold via eventfd.</p>
<ul>
<li>memory.usage_in_bytes: Listens for memory usage file objects.</li>
<li>cgroup.event_control: Threshold monitoring control interface, configuring event_fd, watchfd and threshold threshold based on the format <code>&lt;event_fd&gt; &lt;fd of memory.usage_in_bytes&gt; &lt;threshold&gt;</code>.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">/sys/fs/cgroup/memory
</span></span><span class="line"><span class="cl"><span class="c1"># cat memory.usage_in_bytes</span>
</span></span><span class="line"><span class="cl"><span class="m">92459601920</span>
</span></span><span class="line"><span class="cl"><span class="c1"># ls -lt cgroup.event_control</span>
</span></span><span class="line"><span class="cl">--w--w--w- <span class="m">1</span> root root <span class="m">0</span> Nov <span class="m">24</span> 12:05 cgroup.event_control     <span class="c1"># an interface for event_fd()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The cgroupNotifier presses events into the channel based on cgroup events, triggering the event consumer (evictionManager) to process them. Here the channel does not pass the specific event content, but only does the task triggering function.</p>
<p>To register the threshold of cgroup, there are 3 steps.</p>
<ul>
<li>Create eventfd using eventfd(2)</li>
<li>Create open memory.usage_in_bytes or memory.memsw.usage_in_bytes file descriptor</li>
<li>Write the message &ldquo;<code>&lt;event_fd&gt;</code>&rdquo; in cgroup.event_control</li>
</ul>
<p>Start the control loop synchronize at the end of evictionManager.Start() to periodically check if the threshold condition for eviction is met and proceed to the next action.</p>
</li>
</ol>
<h4 id="control-loop-synchronize">control loop synchronize</h4>
<p>In the control loop of evictionManager, the synchronize function is called for 10s to select pod eviction. The primary judgment of eviction is the triggering condition of eviction, by monitoring the system resources to determine whether the resource usage has hit the threshold. evictionManager has two triggering methods.</p>
<ol>
<li>
<p>eviction triggered based on cgroup (event-based): the above has described the memory CgroupNotifier mechanism</p>
</li>
<li>
<p>triggering eviction based on monitoring data (periodic check)</p>
<ol>
<li>
<p>Get the resource usage of nodes and pods through summaryProvider 2.2 Get the usage of each resource based on monitoring data in the signalObservations function signalObservations Single signalObservation records The total amount of resources and their availability.</p>
</li>
<li>
<p>Get the usage of each resource based on monitoring data in the signalObservations function signalObservations</p>
<p>A single signalObservation records the total amount of resources and the amount available.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// signalObservation is the observed resource usage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">signalObservation</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The resource capacity
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">capacity</span> <span class="o">*</span><span class="nx">resource</span><span class="p">.</span><span class="nx">Quantity</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The available resource
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">available</span> <span class="o">*</span><span class="nx">resource</span><span class="p">.</span><span class="nx">Quantity</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Time at which the observation was taken
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">time</span> <span class="nx">metav1</span><span class="p">.</span><span class="nx">Time</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Determining whether eviction is needed to release resources in the thresholdsMet function</p>
</li>
</ol>
<p>When the resource availability observed above falls below the threshold of each signal, the type of resource to be released is returned.</p>
<p>Either way, the synchronize post logic is executed to determine if the pod needs to be evicted.</p>
</li>
<li>
<p>update the state of the node, the resource pressure state updated and reported to the cluster API other components within the cluster can observe the state of the node, processed from outside the node.</p>
</li>
<li>
<p>If featuregate LocalStorageCapacityIsolation local storage is turned on, it will first try to clean up the local disk affected this is based on featuregate to control whether to turn on, it will check whether the following resource usage of pods exceeds the limit value.</p>
<ul>
<li>sizeLimit of emptyDir</li>
<li>ephemeralStorage&rsquo;s limit</li>
<li>ephemeralStorage limit of container</li>
</ul>
<p>This eviction is immediate, with no graceful exit time. When triggered to a local disk trigger condition, the eviction behavior of other resources is ignored.</p>
<p>When the eviction process goes this far, it determines if there are resource-stressed eviction resources. If thresholdsMet returns an empty array, it means no resources have hit the eviction threshold. Otherwise, it continues to perform the eviction of node resources.</p>
</li>
<li>
<p>Reclaiming node-level resources</p>
<ol>
<li>
<p>reclaimNodeLevelResource: Reclaiming node-level resources</p>
<p>First try to reclaim node resources: nodefs/imagefs, this part can be done by deleting unused containers and images without infringing on the executing pod. after calling the node resource reclaim function, collect the indicator once more. If the free resources are greater than the threshold, the subsequent process of this eviction is skipped: pod-level eviction.</p>
</li>
<li>
<p>Rank phase: Determining the priority of resources that trigger the eviction condition</p>
<p>Each synchronize will only select one resource that exceeds the threshold for recycling. When multiple resources appear to hit the threshold, the resource eviction priority is as follows.</p>
<ul>
<li>Memory resources have the highest eviction priority</li>
<li>No resource signal has the lowest priority</li>
</ul>
</li>
<li>
<p>Try to reclaim the resources of user pods</p>
<p>Based on the resource signal obtained in the previous step, the eviction priority of the active pods on the node is determined, and the pods are ordered according to the eviction priority.</p>
<p>For example, the rules for judging the eviction priority of pods based on memory resources are.</p>
<ul>
<li>Based on whether the pod exceeds the resource request value: those without resource usage indicators are evicted first. Those that exceed the requested value are evicted first.</li>
<li>Based on the spec.priority of the pod: The pods are ordered according to their configured priority, the default is 0. The higher the priority, the later the eviction sequence.</li>
<li>Based on memory resource consumption: Sorted by the portion of memory consumed by the pod that exceeds the requested value. The higher the absolute value of resources exceeded, the higher the priority of the pod to be evicted.</li>
</ul>
<p>kubelet implements the multiSorter function: sorting the active pods according to the above order. If the result of the current rule is in equal order, then the next rule will determine the pod priority. The above logic translates to finding the pods whose resource usage exceeds the requested value (including those without metrics), and then sorting them according to their spec.priority. Within the pods with the same priority, the pods with the higher absolute value of the exceeded resources are then ranked.</p>
<p>In addition to the logic of rankMemoryPressure, there are also the logic of rankPIDPressure and rankDiskPressure.</p>
</li>
<li>
<p>Eviction</p>
<p>fter sorting based on recoverable resources, only one pod deletion is performed per eviction cycle. If it is not HardEviction, MaxPodGracePeriodSeconds is also given to allow the container process inside the pod to exit. The specific eviction actions operate on sending events, deleting the pod and updating the eviction status of the pod.</p>
</li>
</ol>
</li>
</ol>
<h2 id="system-eviction-policy">System Eviction Policy</h2>
<p>The above describes the kubelet in user state to limit the node resources, pod resources by eviction. In kernel memory management, memory usage is limited at the single machine level by OOM killer.</p>
<h3 id="oom-killer">OOM killer</h3>
<p>OOM killer (Out Of Memory killer) is a kind of memory management mechanism in the Linux kernel: when the system has less memory available, the kernel will choose to end the process to free up memory resources in order to ensure that the system can still continue to run.</p>
<h4 id="running-mechanism">running mechanism</h4>
<p>Running processes require more memory than is physically available. When the kernel allocates memory by calling alloc_pages(), it selects processes to release resources by calling out_of_memory() if more memory is needed than is physically available. The OOM killer checks all running processes and chooses to end one or more live processes to free system memory.</p>
<p>out_of_memory() function: Do a partial check first to avoid releasing memory by ending processes. If it can only be freed by ending the process, then the function will continue to select the target process to reclaim. If resources cannot be freed even at this stage, kernel eventually exits with an error. The source code of the function is located at <a href="https://elixir.bootlin.com/linux/v5.17.2/source/mm/oom_kill.c#L1052">https://elixir.bootlin.com/linux/v5.17.2/source/mm/oom_kill.c#L1052</a> and the flow is as follows:</p>
<ol>
<li>First notify the subscribers of the oom_notify_list chain: Based on the notification chains mechanism, the modules registered with oom_notify_list are notified to release memory. If the subscriber is able to handle OOM, it will exit the OOM killer and will not perform subsequent operations if memory is released.</li>
<li>If the current task has a pending SIGKILL or has already exited, it will release the resources of the current process. This includes processes and threads that share the same memory descriptor mm_struct with the task will also be killed.</li>
<li>For IO-less recovery, based on gfp_mask, if 1) the allocation is a non-FS operation type allocation and 2) it is not a cgroup memory OOM -&gt; exit the oom-killer directly.</li>
<li>check the memory allocation constraints (e.g. NUMA) with CONSTRAINT_NONE, CONSTRAINT_CPUSET, CONSTRAINT_MEMORY_POLICY, CONSTRAINT_MEMCG types.</li>
<li>Check the setting of <code>/proc/sys/vm/panic_on_oom</code> and do the operation. If panic_on_oom is set to 2, the process will panic directly and force an exit.</li>
<li>if <code>/proc/sys/vm/oom_kill_allocating_task</code> is true, call oom_kill_process to kill the process that wants to allocate memory (when this process can be killed).</li>
<li>select_bad_process(), select the most suitable process and call oom_kill_process.</li>
<li>if there is no suitable process, panic force exit if non-sysrq and memcg.</li>
</ol>
<p>There are several details in the above process.</p>
<h5 id="gfp_mask-constraint">gfp_mask constraint</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">        * The OOM killer does not compensate for IO-less reclaim.
</span></span></span><span class="line"><span class="cl"><span class="cm">        * pagefault_out_of_memory lost its gfp context so we have to
</span></span></span><span class="line"><span class="cl"><span class="cm">        * make sure exclude 0 mask - all other users should have at least
</span></span></span><span class="line"><span class="cl"><span class="cm">        * ___GFP_DIRECT_RECLAIM to get here. But mem_cgroup_oom() has to
</span></span></span><span class="line"><span class="cl"><span class="cm">        * invoke the OOM killer even if it is a GFP_NOFS allocation.
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">oc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">oc</span><span class="o">-&gt;</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_FS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_memcg_oom</span><span class="p">(</span><span class="n">oc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>gfp_mask is the flag bit passed when requesting memory (get free page). The first four bits represent the memory domain modifiers (<code>___GFP_DMA</code>, <code>___GFP_HIGHMEM</code>, <code>___GFP_DMA32</code>, <code>___GFP_MOVABLE</code>), and from bit 5 onwards are the memory allocation flags. Definition: <a href="https://elixir.bootlin.com/linux/v5.17.2/source/include/linux/gfp.h#L81">https://elixir.bootlin.com/linux/v5.17.2/source/include/linux/gfp.h#L81</a>. Default is null, scan from ZONE_NORMAL, which is the default memory request type.</p>
<p>The OOM killer does not compensate for non-IO reclaims, so allocated gfp_mask is a direct exit for OOMs allocated for non-FS operation types.</p>
<h5 id="oom_constraint-constraints">oom_constraint constraints</h5>
<p>Check if the memory allocation is constrained, there are several different constraint strategies. Only for NUMA and memcg scenarios. oom_constraint can be: CONSTRAINT_NONE,CONSTRAINT_CPUSET,CONSTRAINT_MEMORY_POLICY,CONSTRAINT_MEMCG type. For UMA architecture, the oom_constraint is always CONSTRAINT_NONE, which means that the system does not have the OOM generated by the constraint, while in NUMA architecture, it is possible to attach other constraints to cause the OOM situation.</p>
<p>Then call <code>check_panic_on_oom(oc)</code> to check if /proc/sys/kernel/panic_on_oom is configured, and if so, trigger panic directly.</p>
<p>When it comes to this step, the oom killer needs to select the process to terminate, and there are two selection logics to choose the appropriate process to pass.</p>
<ul>
<li>Terminate whoever triggers OOM: controlled by sysctl_oom_kill_allocating_task, whether to kill the process currently requesting memory</li>
<li>Stop whoever is the &ldquo;baddest&rdquo;: determine the &ldquo;baddest&rdquo; process by scoring it</li>
</ul>
<p>sysctl_oom_kill_allocating_task from <code>/proc/sys/vm/oom_kill_allocating_task</code>. When the argument is true, the call to oom_kill_process directly kills the process that is currently trying to allocate memory.</p>
<h5 id="select_bad_process-selects-the-worst-process">select_bad_process: selects the &ldquo;worst&rdquo; process</h5>
<p>In normal scenarios, the oom_evaluate_task function is used to evaluate the process score and select the process to be terminated. In the case of a memory cgroup, mem_cgroup_scan_tasks is called. First look at the logic of oom_evaluate_task</p>
<ul>
<li>processes with mm-&gt;flags of MMF_OOM_SKIP are skipped and the next process is evaluated</li>
<li>oom_task_origin has the highest score, this flag indicates that the task has been allocated a lot of memory and marked as a potential cause of oom, so it is killed first.</li>
<li>Processes in other cases have their scores calculated by the oom_badness function</li>
</ul>
<p>The process with the highest final score is terminated with the highest priority.</p>
<p>The process termination priority <strong>score</strong> calculated by the oom_badness function consists of two parts and is provided by the following two parameters.</p>
<p>Parameters.</p>
<ul>
<li>oom_score_adj: OOM kill score adjustment, the adjustment value is scored by the user. The range is from OOM_SCORE_ADJ_MIN (-1000) to OOM_SCORE_ADJ_MAX (1000). The higher the value, the higher the priority of the process to be terminated. The user can use this value to protect a process.</li>
<li>totalpages: The current upper limit of allocatable memory, which provides the basis for system scoring.</li>
</ul>
<p>Calculation formula.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">    * The baseline for the badness score is the proportion of RAM that each
</span></span></span><span class="line"><span class="cl"><span class="cm">    * task&#39;s rss, pagetable and swap space use.
</span></span></span><span class="line"><span class="cl"><span class="cm">    */</span>
</span></span><span class="line"><span class="cl"><span class="n">points</span> <span class="o">=</span> <span class="n">get_mm_rss</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="o">+</span> <span class="n">get_mm_counter</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">MM_SWAPENTS</span><span class="p">)</span> <span class="o">+</span>
</span></span><span class="line"><span class="cl">    <span class="n">mm_pgtables_bytes</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">adj</span> <span class="o">*=</span> <span class="n">totalpages</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">points</span> <span class="o">+=</span> <span class="n">adj</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The base fraction process_pages consists of 3 parts.</p>
<ul>
<li>get_mm_rss(p-&gt;mm): rss part</li>
<li>get_mm_counter(p-&gt;mm, MM_SWAPENTS): swap occupied memory</li>
<li>mm_pgtables_bytes(p-&gt;mm) / PAGE_SIZE: memory occupied by page tables</li>
</ul>
<p>Add up the 3 parts and combine them with oom_score_adj: the normalized adj and points are summed up and used as the current process score.</p>
<p>So process score points = process_pages + oom_score_adj*totalpages/1000</p>
<p>Older versions of the kernel also had some complex calculation logic to consider, such as the treatment of privileged processes. In the case of root privileged processes, there was a 3% memory usage privilege. <code>points=process_pages*0.97 + oom_score_adj*totalpages/1000</code>. v4.17 removes this, making the calculation logic more concise and predictable.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">* Root processes get 3% bonus, just like the __vm_enough_memory()
</span></span></span><span class="line"><span class="cl"><span class="cm">* implementation used by LSMs.
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">has_capability_noaudit</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="n">points</span> <span class="o">-=</span> <span class="p">(</span><span class="n">points</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>mem_cgroup_scan_tasks: memory cgroup cgroup processing will require traversing the cgroup hierarchy and calling oom_evaluate_task to calculate the task&rsquo;s score. Reclaiming the memory of the parent process will also reclaim the memory of the child processes.</p>
<h6 id="oom_kill_process">oom_kill_process</h6>
<p>The next step is to enter the logic of terminating the process. <code>oom_kill_process</code> function checks whether the task has exited before terminating the process and the occupied memory will be freed to prevent duplicate processing; it gets the memory cgroup message and determines whether all the tasks under the cgroup need to be deleted. then there is a dump message that prints out the cause of the OOM print out and keep the clues of OOM.</p>
<p>After that, call <code>put_task_struct</code> inside <code>__oom_kill_process</code> function to free kernel stack and release system resources. Wake up the oom_reaper kernel thread to reap wake_oom_reaper(victim).</p>
<p>oom_reaper will remain dormant until there is a cleanup task. wake_oom_reaper will press the task into the <code>oom_reaper_list</code> chain, and oom_reaper will use the oom_reaper_list chain to determine the need to call <code>oom_reap_task_mm</code> to clean up the address space. The cleanup will traverse the vma and skip the VMA area of VM_LOCKED|VM_HUGETLB|VM_PFNMAP. The specific release operation is done by unmap_page_range.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span> <span class="p">;</span> <span class="n">vma</span><span class="p">;</span> <span class="n">vma</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">can_madv_lru_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">        * Only anonymous pages have a good chance to be dropped
</span></span></span><span class="line"><span class="cl"><span class="cm">        * without additional steps which we cannot afford as we
</span></span></span><span class="line"><span class="cl"><span class="cm">        * are OOM already.
</span></span></span><span class="line"><span class="cl"><span class="cm">        *
</span></span></span><span class="line"><span class="cl"><span class="cm">        * We do not even care about fs backed pages because all
</span></span></span><span class="line"><span class="cl"><span class="cm">        * which are reclaimable have already been reclaimed and
</span></span></span><span class="line"><span class="cl"><span class="cm">        * we do not want to block exit_mmap by keeping mm ref
</span></span></span><span class="line"><span class="cl"><span class="cm">        * count elevated without a good reason.
</span></span></span><span class="line"><span class="cl"><span class="cm">        */</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">vma_is_anonymous</span><span class="p">(</span><span class="n">vma</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">mmu_notifier_range</span> <span class="n">range</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">mmu_gather</span> <span class="n">tlb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">mmu_notifier_range_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span> <span class="n">MMU_NOTIFY_UNMAP</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">vma</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">tlb_gather_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">mm</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">mmu_notifier_invalidate_range_start_nonblock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tlb_finish_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">unmap_page_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">,</span> <span class="n">vma</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="n">range</span><span class="p">.</span><span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">mmu_notifier_invalidate_range_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">tlb_finish_mmu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://elixir.bootlin.com/linux/v5.17.2/source/mm/oom_kill.c#L528">https://elixir.bootlin.com/linux/v5.17.2/source/mm/oom_kill.c#L528</a></p>
<h5 id="controls-the-behavior-of-the-oom-killer">controls the behavior of the oom killer</h5>
<p>There are several file parameters mentioned above to control the behavior of the control oom killer.</p>
<ol>
<li>
<p>/proc/sys/vm/panic_on_oom, which sets the value to allow or disallow kernel panic when oom occurs (default is 0)</p>
<ul>
<li><code>0</code>: When oom occurs, the kernel will choose to call oom-killer to select the process to delete</li>
<li><code>1</code>: When oom occurs, the kernel will normally panic directly, except for certain conditions: processes restricted by mempolicy/cpusets will be deleted by oom-killer without panic</li>
<li><code>2</code>: When oom occurs, the kernel panic unconditionally</li>
</ul>
</li>
<li>
<p>/proc/sys/vm/oom_kill_allocating_task, can take the value of 0 or non-0 (default is 0), 0 means that when sending oom, it will traverse the task chain and select a process to kill, while non-0 means that when sending oom, it will directly kill the process that caused oom, and will not traverse the task chain.</p>
</li>
<li>
<p>/proc/sys/vm/oom_dump_tasks: can take a value of 0 or non-0 (default is 1), indicating whether to print information about the task when sending an oom killer.</p>
</li>
<li>
<p>/proc//oom_score_adj: Configure the scoring adjustment score of a process to protect a process from being killed or to kill a process every time by using this value. The range of values is -1000 to 1000.</p>
</li>
<li>
<p>/proc/sys/vm/overcommit_memory: control memory overcommit, oom-killer function, default is 0</p>
<ul>
<li><code>0</code>: <strong>heuristic policy</strong> , more serious Overcommit will not be allowed, for example, you suddenly request 128TB of memory. And minor overcommits will be allowed. Also, root can Overcommit slightly more values than normal users. Default</li>
<li><code>1</code>: <strong>Always allow overcommit</strong> , this policy is suitable for applications that cannot afford memory allocation failures, such as certain scientific computing applications.</li>
<li><code>2</code>: <strong>Always disallow overcommit</strong>, in which case the system can allocate no more memory than <em><em>swap+RAM</em> factor</em>* (/proc/sys/vm/overcmmit_ratio, default 50%, you can adjust it), and if this much resource has been used up, then any later attempts to request memory will This usually means that no new programs can be run at this point.</li>
</ul>
</li>
</ol>
<p>Control of Memory cgroup subsystem.</p>
<ol>
<li>
<p>memory.use_hierarchy: Specify the cgroup hierarchy. (default is 0)</p>
<ul>
<li><code>0</code>: The parent process does not reclaim memory from child processes</li>
<li><code>1</code>: it will reclaim memory from child processes that exceed the memory limit</li>
</ul>
</li>
<li>
<p>memory.oom_control: oom control, (default is 0: per cgroup memory subsystem)</p>
<ul>
<li><code>0</code>: process will be killed by oom_killer when it consumes more memory</li>
<li><code>1</code>: turn off oom_killer, when task tries to use more memory, it will be stuck until memory is sufficient.</li>
<li>When reading a file, describe the state of oom: oom_kill_disable (whether it is on), under_oom (whether it is in oom state)</li>
</ul>
</li>
</ol>
<h2 id="oom-killer-in-user-space">oom killer in user space</h2>
<p>One last brief introduction to the user-space oom killer: <a href="https://github.com/facebookincubator/oomd">https://github.com/facebookincubator/oomd</a>. oomd is targeted at user space, solving memory resource usage.</p>
<h3 id="operation-mechanism">Operation mechanism</h3>
<ul>
<li>Use PSI, cgroupv2 to monitor memory usage on the system and oomd to free memory resources before kernel&rsquo;s oom_killer processing.</li>
<li>Monitor the memory pressure on the system and cgroup.</li>
</ul>
<p>And it can be configured so that the eviction policy.</p>
<ul>
<li>When workload has memory pressure/system has memory pressure, select a memory hog (resource hog) to delete by memory size or growth rate.</li>
<li>When the system is under memory pressure, select a memory hog to delete by memory size or growth rate.</li>
<li>When the system is under swap pressure, select the cgroup that uses the most swap to delete.</li>
</ul>
<p>As you can see, oomd acts as a kubelet and is the agent for oom management on a single machine.</p>
<h2 id="summary">Summary</h2>
<p>You can see the difference between user-space and kernel-space eviction policies. User space triggers the eviction process by monitoring system resources, while kernel space triggers the eviction process when allocating memory. Because user-space eviction needs to come before kernel eviction</p>
<p>In addition to process eviction, there are other means to achieve resource security and stability, such as resource suppression and recycling. Through cgroup v2&rsquo;s Memory Qos capability</p>
<ul>
<li>Guarantee the memory allocation performance of container and reduce its memory allocation latency when the whole machine memory is under pressure</li>
<li>Suppressing and quickly reclaiming the over-requested memory containers to reduce the pressure of memory usage of the whole machine</li>
<li>Protects the entire machine&rsquo;s reserved memory</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/k8s/">k8s</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-07/mac-homebrew/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">MacOS installation and configuration of Homebrew</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-07/harbor/">
            <span class="next-text nav-default">Containerd Docking Private Image Repository Harbor</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
