<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>VXLAN Protocol for Cloud-Native Virtual Networks - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore the VXLAN protocol used for virtual networks under cloud-native." /><meta name="keywords" content="VXLAN, Virtual Networks" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-07/vxlan/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="VXLAN Protocol for Cloud-Native Virtual Networks" />
<meta property="og:description" content="Explore the VXLAN protocol used for virtual networks under cloud-native." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-07/vxlan/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-25T10:44:02+08:00" />
<meta property="article:modified_time" content="2022-07-25T10:44:02+08:00" />

<meta itemprop="name" content="VXLAN Protocol for Cloud-Native Virtual Networks">
<meta itemprop="description" content="Explore the VXLAN protocol used for virtual networks under cloud-native."><meta itemprop="datePublished" content="2022-07-25T10:44:02+08:00" />
<meta itemprop="dateModified" content="2022-07-25T10:44:02+08:00" />
<meta itemprop="wordCount" content="2464">
<meta itemprop="keywords" content="cloud-native," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="VXLAN Protocol for Cloud-Native Virtual Networks"/>
<meta name="twitter:description" content="Explore the VXLAN protocol used for virtual networks under cloud-native."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">VXLAN Protocol for Cloud-Native Virtual Networks</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-07-25 10:44:02 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2464 words </span>
          <span class="more-meta"> 12 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#vxlan-protocol">VXLAN Protocol</a>
          <ul>
            <li><a href="#protocol-messages">Protocol messages</a></li>
            <li><a href="#working-model">Working model</a></li>
            <li><a href="#communication-process">Communication process</a></li>
            <li><a href="#an-example">An example</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>The first time I got to know VXLAN was when I looked at a network plugin called flannel used in k8s that has a VXLAN mode, which implements an Overlay Network that connects all containers together. So in this article, let&rsquo;s take a look at how VXLAN connects the networks between different containers.</p>
<h2 id="overview">Overview</h2>
<p>Before we look at VXLAN, let&rsquo;s take a look at its predecessor, VLAN, whose full name is Virtual Local Area Network, a layer 2 (data link layer) network used to partition broadcast domains. Because with more computers, if there is only one broadcast domain, there will be a lot of broadcast frames (e.g. ARP requests, DHCP, RIP all generate broadcast frames) forwarded to all clients in the same network.</p>
<p>This results in unnecessary waste. On the one hand, the broadcast message consumes the overall bandwidth of the network, and on the other hand, the computer receiving the broadcast message consumes some CPU time to process it. This results in a significant and unnecessary consumption of network bandwidth and CPU computing power.</p>
<p>In this case, VLAN technology emerged. This technology can divide a LAN into multiple logical VLANs, each VLAN is a broadcast domain, and the communication between hosts within a VLAN is the same as within a LAN, while inter-VLANs cannot interoperate directly, and broadcast messages are restricted to a VLAN. As shown in the figure below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/25/8a139fcedf45400e8a11f06f7e6773d3.png" alt="VLAN"></p>
<p>However, VLANs have two obvious flaws, the first one is the design of VLAN Tag, the 802.1Q specification that defines VLANs was proposed in 1998, and only 32 Bits of storage space is reserved for VLAN Tag, of which only 12 Bits can be used to store VLAN IDs. When the cloud computing data center emerges, even without considering the demand of virtualization, the physical devices that need to assign IPs alone may be tens of thousands or even hundreds of thousands, so 4096 VLANs are definitely not enough.</p>
<p>The second drawback of VLAN is that it is itself a Layer 2 network technology. However, information between two independent data centers can only be passed through the Layer 3 network. The development of cloud computing has popularized the demand of many businesses to operate across data centers, so passing VLAN tags between data centers is another troublesome task; and in the virtual network, a physical machine will have multiple containers, and the number of containers and VMs is also increasing by orders of magnitude, and each VM has its own IP address and MAC address, so the pressure on the switch is also multiplied.</p>
<p>For all the above reasons, VXLAN also comes into play.</p>
<h2 id="vxlan-protocol">VXLAN Protocol</h2>
<h3 id="protocol-messages">Protocol messages</h3>
<p>VXLAN (Virtual eXtensible LAN) uses the L2 over L4 (MAC in UDP) packet encapsulation mode, which puts the Ethernet frames originally transmitted at Layer 2 into the packet body of Layer 4 UDP protocol, and adds its own defined VXLAN Header.</p>
<p>The VXLAN Header directly contains 24 Bits of VLAN IDs, which can also store 16.77 million different values. VXLAN allows Layer 2 networks to scale within Layer 3 and is no longer limited by the transmission between data centers.</p>
<p>VXLAN works on Layer 2 networks (IP network layer) and can be deployed on any network that is Layer 3 reachable (capable of communicating with each other over IP.) The entire message structure of VXLAN is shown in Figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/25/0b6be1808cb0456cb34ae00523d12d6d.png" alt="VXLAN Protocol"></p>
<p>Above we can see that the VXLAN message wraps the Original Layer2 Frame.</p>
<ul>
<li>VXLAN Header 8 bytes, which contains the 24Byte VNI field used to define the different tenants in the VXLAN network and can store 16.77 million different fetch values.</li>
<li>UDP Header, where the VXLAN header is used as data for the UDP along with the original Ethernet frame, the destination port number (VXLAN Port) in the header is fixed at 4789 and the source port is randomly assigned by flow (hash operation by MAC, IP, Layer 4 port number), which allows better ECMP.</li>
<li>Outer IP Header encapsulates the outer IP header, encapsulating the destination IP address and source IP address, where IP refers to the IP address of the host.</li>
<li>Outer MAC Header encapsulates the outer Ether header, encapsulating the source MAC address, the destination MAC address, where MAC address refers to the host MAC address.</li>
</ul>
<h3 id="working-model">Working model</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/25/b964176caf9f4e2180cda2e08183f0d3.png" alt="Working model"></p>
<p>From the above diagram VXLAN network network model we can find the following components appearing in the VXLAN network.</p>
<ul>
<li>VTEP (VXLAN Tunnel Endpoints): An edge device of a VXLAN network that is the starting and ending point of a VXLAN tunnel and is responsible for the <strong>encapsulation and unencapsulation</strong> of VXLAN protocol messages, i.e., encapsulating the message headers of VTEP traffic on virtual messages. VTEP can be a network device (e.g., a switch) or a machine (e.g., a host in a virtualized cluster).</li>
<li>VNI (VXLAN Network Identifier): As mentioned earlier, VLANs only take up 12 bits of space in Ethernet data frames, which makes the isolation capability of VLANs overwhelming in data center networks. The emergence of VNI is specifically to solve this problem. Generally each VNI corresponds to <strong>one tenant</strong> and it is a 24-bit integer, meaning that a public cloud built using VXLAN can theoretically support up to <strong>16.77 million levels of tenants</strong>.</li>
<li>VXLAN tunneling: Tunneling is a logical concept that has no specific physical entity trying to correspond in the VXLAN model. A tunnel can be thought of as a virtual channel where both sides of the VXLAN communication (the VMs in the diagram) think they are communicating directly and are unaware of the existence of the underlying network. As a whole, each VXLAN network looks like a separate communication channel, or tunnel, for the communicating VMs.</li>
</ul>
<h3 id="communication-process">Communication process</h3>
<p>Usually VTEPs in VXLAN networks may have multiple tunnels. VTEPs determine the destination VTEP address before communicating by querying the forwarding table FDB, which is used to store the MAC address of the remote VM/container, the remote VTEP IP, and the VNI mapping relationship, and the forwarding table is constructed by flooding and learning mechanisms. Traffic whose destination MAC address does not exist in the forwarding table is called Unknown unicast. the VXLAN specification requires flooding using IP multicast to send packets to all VTEPs except the source VTEP. when the destination VTEP sends back response packets, the source VTEP learns the mapping relationships of MAC address, VNI, and VTEP from them and adds to the forwarding table.</p>
<p>Let&rsquo;s take a look at the first communication process to see how VTEP learns.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/25/67ae7dda287a451f9468db4f1d30acdc.png" alt="how VTEP learns"></p>
<ol>
<li>Since this is the first time we are communicating, VM-A does not have the MAC address of VM-B on it. VM-A sends an ARP broadcast message requesting the MAC address of VM-B. VM-A sends an ARP broadcast message with source MAC of VM-B, destination MAC of full F, source IP of IP-A, and destination IP of IP-B to request the MAC address of VM-B.</li>
<li>After VTEP-1 receives an ARP request, it determines that the message needs to enter the VXLAN tunnel according to the configuration on the Layer 2 sub-interface. VTEP-1 will encapsulate the message, and the outer source IP address of the encapsulation is the IP address of the local VTEP (VTEP-1). The outer destination IP address is the IP address of the peer VTEP (VTEP-2 and VTEP-3); the outer source MAC address is the MAC address of the local VTEP, and the outer destination MAC address is the MAC address of the next-hop device in the network going to the destination IP.</li>
<li>After the message arrives at VTEP-2 and VTEP-3, VTEP decapsulates the message to obtain the original message sent by VM-A. Then VTEP-2 and VTEP-3 process the message accordingly and broadcast it in the corresponding Layer 2 domain. VM-B and VM-C receive the ARP request and compare whether the destination IP address in the message is the local IP address. VM-C discards the message if it finds that the destination IP is not the local IP. The VM-B finds that the destination IP is the local IP, and then responds to the ARP request.</li>
<li>The VM-B will answer the ARP packet based on the requested ARP packet as a unicast message with MAC-B as the source MAC and MAC-A as the destination MAC, IP-B as the source IP and IP-A as the destination IP.</li>
<li>After receiving the ARP reply message from VM-B, VTEP-2 identifies the VNI to which the message belongs, and VTEP-2 encapsulates the message. The outer source IP address of the encapsulation is the IP address of the local VTEP (VTEP-2), and the outer destination IP address is the IP address of the counterpart VTEP (VTEP-1); the outer source MAC address is the MAC address of the local VTEP, and the outer destination MAC address is the MAC address of the next-hop device in the network going to the destination IP.</li>
<li>After the message arrives at VTEP-1, VTEP-1 decapsulates the message to get the original message sent by VM_B. At the same time, VTEP-1 learns the correspondence between the MAC address of VM_B, VNI and the IP address (IP-2) of the remote VTEP, and records it in the local MAC table. Afterwards, VTEP-1 sends the decapsulated message to VM-A.</li>
<li>At this point, VM-A has received the MAC address of VM-B in response to the ARP broadcast message.</li>
</ol>
<p>In addition to the above multicast learning method to obtain <code>MAC &lt;--&gt; VNI &lt;--&gt; VTEP IP</code> this set of mapping relations there is another way, is a distributed control center.</p>
<p>For example, the MAC addresses of VTEPs in a Flannel&rsquo;s VXLAN mode network are not learned through multicast, but are synchronized (or etcd) through the apiserver. When each node creates a Flannel, each node will report its VTEP information to apiserver, and apiserver will then synchronize to the listener (Flanneld) who is watching the node api on each node, and after Flanneld gets the update message, it will send it down to the Flanneld gets the update message and then sends it down to the kernel via netlink to update the FDB (query forwarding table) table entries, thus synchronizing the whole cluster. This apiserver plays the role of a distributed control center, and no longer needs to send extra requests to the full network to get the corresponding mapping information.</p>
<h3 id="an-example">An example</h3>
<p>Here, we make a VXLAN network by ourselves, and then analyze its packets, whether it is consistent with the conclusions we have told at length above. Note that when experimenting on your own virtual machine, to avoid unnecessary trouble, remember to turn off the firewall, centos command is: <code>systemctl stop firewalld</code>.</p>
<p>Here we are going to experiment with docker, the idea is to create a VXLAN interface on each of the two container hosts and connect the VXLAN interface to the port of the docker bridge as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/25/d8f951133e1943ae926316eab3506972.png" alt="VXLAN"></p>
<p>For docker, it is not possible to communicate directly across nodes, so we use VXLAN here to simulate cross-node communication.</p>
<p>By default, docker uses the 172.17.0.0/16 network segment, and the IP addresses of docker containers are assigned starting from 172.17.0.2. In order to take advantage of the -ip parameter for custom IP addresses, you need to create a custom network first, specifying the network segment 172.18.0.0/16.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker network create --subnet 172.18.0.0/16 mynetwork</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## mynetwork A new bridge network is created</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker network ls</span>
</span></span><span class="line"><span class="cl">NETWORK ID     NAME        DRIVER    SCOPE
</span></span><span class="line"><span class="cl">eb07bfe03ee3   bridge      bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">7014433d34cf   host        host      <span class="nb">local</span>
</span></span><span class="line"><span class="cl">87133e370c6c   mynetwork   bridge    <span class="nb">local</span>
</span></span><span class="line"><span class="cl">82472e531205   none        null      <span class="nb">local</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can also see that docker has created a new bridge for our new network.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># brctl show</span>
</span></span><span class="line"><span class="cl">bridge name     bridge id               STP enabled     interfaces
</span></span><span class="line"><span class="cl">br-87133e370c6c         8000.0242233b251a       no              veth385f866
</span></span><span class="line"><span class="cl">                                                        vxlan_docker
</span></span><span class="line"><span class="cl">docker0         8000.024213087f4b       no
</span></span></code></pre></td></tr></table>
</div>
</div><p>Create a new container as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1">## VM1</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker run -itd --net mynetwork --ip 172.18.0.10 centos</span>
</span></span><span class="line"><span class="cl"><span class="c1">## VM2</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># docker run -itd --net mynetwork --ip 172.18.0.11 centos</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--net specifies a custom network
</span></span><span class="line"><span class="cl">--ip specifies the IP address
</span></span><span class="line"><span class="cl">centos specifies the image
</span></span></code></pre></td></tr></table>
</div>
</div><p>Above we have created the network, but we can&rsquo;t communicate by going in directly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#  docker exec -it 5a2e519610bb /bin/bash</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@5a2e519610bb /<span class="o">]</span><span class="c1"># ping  172.18.0.11</span>
</span></span><span class="line"><span class="cl">PING 172.18.0.11 <span class="o">(</span>172.18.0.11<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
</span></span><span class="line"><span class="cl">From 172.18.0.10 <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> Destination Host Unreachable
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">--- 172.18.0.11 ping statistics ---
</span></span><span class="line"><span class="cl"><span class="m">11</span> packets transmitted, <span class="m">0</span> received, +8 errors, 100% packet loss, <span class="nb">time</span> 10007ms
</span></span><span class="line"><span class="cl">pipe <span class="m">4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here we create a VXLAN interface on each of the two container hosts and connect the VXLAN interface to the port of the docker bridge.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1">## VM1</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#  ip link add vxlan_docker type vxlan id 200 remote 192.168.13.132 dstport 4789 dev ens33</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#  ip link set vxlan_docker up</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#  brctl addif br-87133e370c6c vxlan_docker</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">## VM2</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#  ip link add vxlan_docker type vxlan id 200 remote 192.168.13.131 dstport 4789 dev ens33</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#  ip link set vxlan_docker up</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#  brctl addif br-26d918129b18 vxlan_docker</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Above we used <code>ip link add</code> to create a VXLAN network interface with VNI 200 for VM1 and VM2 respectively, with the name vxlan_docker; then we used <code>brctl addif</code> to connect the newly created VXLAN interface vxlan_docker to the docker bridge.</p>
<p>Then we go into the container and find that we can ping through.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@5a2e519610bb /<span class="o">]</span><span class="c1"># ping  172.18.0.11</span>
</span></span><span class="line"><span class="cl">PING 172.18.0.11 <span class="o">(</span>172.18.0.11<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 172.18.0.11: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">1</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>1.14 ms
</span></span><span class="line"><span class="cl"><span class="m">64</span> bytes from 172.18.0.11: <span class="nv">icmp_seq</span><span class="o">=</span><span class="m">2</span> <span class="nv">ttl</span><span class="o">=</span><span class="m">64</span> <span class="nv">time</span><span class="o">=</span>0.620 ms
</span></span><span class="line"><span class="cl">^C
</span></span><span class="line"><span class="cl">--- 172.18.0.11 ping statistics ---
</span></span><span class="line"><span class="cl"><span class="m">2</span> packets transmitted, <span class="m">2</span> received, 0% packet loss, <span class="nb">time</span> 1002ms
</span></span><span class="line"><span class="cl">rtt min/avg/max/mdev <span class="o">=</span> 0.620/0.879/1.139/0.261 ms
</span></span></code></pre></td></tr></table>
</div>
</div><p>Analyze packets on the host.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1">#  tcpdump -i ens33 host 192.168.13.131 -s0 -v -w vxlan_vni_1.pcap</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/25/920e0e5694ca4366b0585b386a80518b.png" alt="tcpdump"></p>
<p>Above we see that the first is to send out an ARP request for a MAC address, the outer layer is a UDP message, the destination port is 4789, the destination IP is the IP of the host VM2; the VXLAN message header VNI is 200; the source MAC address of the ARP request is the MAC address of the container sending the message inside VM1, the destination address is not obtained, it is <code>ff:ff:ff:ff: ff:ff</code>.</p>
<p>After receiving the return packet, 172.18.0.11 replies with an ARP response packet informing that the MAC address is <code>02:42:ac:12:00:0b</code>, and then it can send ICMP packets normally.</p>
<h2 id="summary">Summary</h2>
<p>This article, starting from the introduction of VLAN, tells what are the disadvantages of VLAN and why there is VXLAN, then tells how the protocol messages of VXLAN are encapsulated, how the overall working model is, and how the VXLAN communication process is familiar with how it works, and finally, through an example of hands-on implementation of mutual communication between containers on two nodes. I believe that by this point, you should have a lot of understanding of VXLAN.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/cloud-native/">cloud-native</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-07/serde/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">serde custom serialization</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-07/go-eventbus/">
            <span class="next-text nav-default">Golang Event Bus</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
