<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Implementing bidirectional data exchange between kernel and user states of eBPF programs using Golang - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore how to implement bi-directional data exchange between the kernel and user states of eBPF programs using Golang based BPF MAP." /><meta name="keywords" content="golang, Ebpf, BPF MAP" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-07/go-ebpf-03/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Implementing bidirectional data exchange between kernel and user states of eBPF programs using Golang" />
<meta property="og:description" content="Explore how to implement bi-directional data exchange between the kernel and user states of eBPF programs using Golang based BPF MAP." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-07/go-ebpf-03/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-26T09:22:57+08:00" />
<meta property="article:modified_time" content="2022-07-26T09:22:57+08:00" />

<meta itemprop="name" content="Implementing bidirectional data exchange between kernel and user states of eBPF programs using Golang">
<meta itemprop="description" content="Explore how to implement bi-directional data exchange between the kernel and user states of eBPF programs using Golang based BPF MAP."><meta itemprop="datePublished" content="2022-07-26T09:22:57+08:00" />
<meta itemprop="dateModified" content="2022-07-26T09:22:57+08:00" />
<meta itemprop="wordCount" content="2881">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Implementing bidirectional data exchange between kernel and user states of eBPF programs using Golang"/>
<meta name="twitter:description" content="Explore how to implement bi-directional data exchange between the kernel and user states of eBPF programs using Golang based BPF MAP."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Implementing bidirectional data exchange between kernel and user states of eBPF programs using Golang</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-07-26 09:22:57 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2881 words </span>
          <span class="more-meta"> 14 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#1-why-bpf-map">1. Why BPF MAP?</a></li>
            <li><a href="#2-bpf-map-is-not-a-narrowly-defined-map-data-structure">2. BPF MAP is not a narrowly defined map data structure</a></li>
            <li><a href="#3-example-of-using-map-based-on-libbpf-using-c">3. Example of using map based on libbpf using C</a></li>
            <li><a href="#4-example-of-using-go-to-implement-execve-counter-based-on-ciliumebpf">4. Example of using Go to implement execve-counter based on cilium/ebpf</a></li>
            <li><a href="#5-summary">5. Summary</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/26/e892d96a7de541029e3a1bc6b873e9ed.png" alt="go ebpf"></p>
<p>In the previous two articles, both &ldquo;<a href="/post/2022-07/c-ebpf/">Developing eBPF programs in C</a>&rdquo; and &ldquo;<a href="http://localhost:1313/post/2022-07/go-ebpf/">Developing eBPF programs in Go</a>&rdquo; are hello world level, which may be useful, but not very practical.</p>
<p>Generally speaking, a practical eBPF program has data exchange between its kernel state part and user state part, and with this data exchange, eBPF can play a more powerful role. And to make an eBPF program more practical, <strong>eBPF MAP is the mechanism that cannot be bypassed</strong>.</p>
<p>In this article about eBPF program development, let&rsquo;s see <strong>how to use Go based on BPF MAP to implement bi-directional data exchange between the kernel state and user state of eBPF programs</strong>.</p>
<h3 id="1-why-bpf-map">1. Why BPF MAP?</h3>
<p>Never forget that BPF bytecode is code that runs in the OS kernel state, which means that it is &ldquo;distinct&rdquo; from the user state. We know that the only way for user state to access kernel state data is to make a system call into the kernel state. Therefore, the various variable instances created in a BPF kernel-state program can only be accessed by the kernel-state code.</p>
<p>How do we return useful data obtained by the BPF code in the kernel state to the user state for monitoring, computing, decision making, presentation, and storage? And how does the user state code pass data to the kernel state at runtime to change the BPF code&rsquo;s runtime policy?</p>
<p>The Linux kernel BPF developers then introduced the <a href="https://www.kernel.org/doc/html/latest/bpf/maps.html">BPF MAP mechanism</a>. <strong>BPF MAP provides a channel for bidirectional data exchange between the kernel state and the user state of a BPF program</strong> . At the same time, since the bpf map is stored in the kernel-allocated memory space in the kernel state, it can be shared by multiple BPF programs running in the kernel state, and can also be used as a mechanism for multiple BPF programs to exchange and share data.</p>
<h3 id="2-bpf-map-is-not-a-narrowly-defined-map-data-structure">2. BPF MAP is not a narrowly defined map data structure</h3>
<p>What exactly is BPF MAP? It is not a data structure that we narrowly understand as a hash map table, but <a href="https://man7.org/linux/man-pages/man2/bpf.2.html">a generic data structure that can store different types of data</a>. In the words of <a href="https://nakryiko.com/posts/libbpf-bootstrap/#bpf-maps">Andrii Nakryiko</a>, a famous kernel BPF developer, MAP is a concept representing <a href="https://nakryiko.com/posts/libbpf-bootstrap/#bpf-maps">abstract data container</a> in BPF.</p>
<p>So far, there are 20+ MAP types supported by the kernel BPF, the following are the currently supported MAP types listed in bpf.h in libbpf.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="line"><span class="cl"><span class="c1">// libbpf/include/uapi/linux/bpf.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">enum</span> <span class="n">bpf_map_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_UNSPEC</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_HASH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_ARRAY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_PROG_ARRAY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_PERF_EVENT_ARRAY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_PERCPU_HASH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_PERCPU_ARRAY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_STACK_TRACE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_CGROUP_ARRAY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_LRU_HASH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_LRU_PERCPU_HASH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_LPM_TRIE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_ARRAY_OF_MAPS</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_HASH_OF_MAPS</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_DEVMAP</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_SOCKMAP</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_CPUMAP</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_XSKMAP</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_SOCKHASH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_CGROUP_STORAGE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_REUSEPORT_SOCKARRAY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_QUEUE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_STACK</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_SK_STORAGE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_DEVMAP_HASH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_STRUCT_OPS</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_RINGBUF</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_INODE_STORAGE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_TASK_STORAGE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">BPF_MAP_TYPE_BLOOM_FILTER</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are many types of data structures here, but they are not the focus of this article, so we won&rsquo;t introduce them one by one. The BPF_MAP_TYPE_HASH type is the first type of MAP data structure supported by BPF. This type can be understood as the hash table that we come into contact with everyday, indexing data in the form of key-value pairs. We will use this type of MAP in the subsequent examples.</p>
<p>So how can BPF MAP share data between the kernel state and the user state? What is the principle?</p>
<p>We can find out from the <a href="https://man7.org/linux/man-pages/man2/bpf.2.html">description of the system call bpf</a>. Here is the function prototype of the bpf system call.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-h" data-lang="h"><span class="line"><span class="cl"><span class="c1">// https://man7.org/linux/man-pages/man2/bpf.2.html
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bpf</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">union</span> <span class="n">bpf_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Looking at the prototype of bpf, it seems relatively simple. But bpf is actually a &ldquo;rich call&rdquo;, i.e. it can do more than one thing, and it can do many things around BPF by passing in different values through cmd. The main function is to load the bpf program (cmd=BPF_PROG_LOAD), followed by a series of operations around MAP, including creating MAP (cmd=BPF_MAP_CREATE), querying MAP elements (cmd=BPF_MAP_LOOKUP_ELEM), and updating MAP element values (cmd=BPF_MAP _UPDATE_ELEM), etc.</p>
<p>When cmd=BPF_MAP_CREATE, i.e. after bpf performs the operation of creating a MAP, the bpf call will return a file descriptor fd, <strong>through which the newly created MAP can be subsequently manipulated</strong> . The map is accessed via fd, which is <strong>very unix</strong>!</p>
<p>Of course such an underlying system call is not generally needed for BPF user state developers to touch, like libbpf wraps a series of map operations functions that do not expose map fd to the user, simplifying the usage and improving the experience.</p>
<p>Let&rsquo;s take a look at how to implement map-based data exchange between the BPF user state and the kernel state in C.</p>
<h3 id="3-example-of-using-map-based-on-libbpf-using-c">3. Example of using map based on libbpf using C</h3>
<p>This example is adapted from the <a href="https://github.com/bigwhite/experiments/tree/master/ebpf-examples/helloworld">helloworld example</a>. The original helloworld example outputs a kernel log (available in /sys/kernel/debug/tracing/trace_pipe) when the execve system call is called, and the user-state program does not exchange any data with the kernel-state program.</p>
<p>In this new example (execve_counter), we still track the system call to execve, except that we count the calls to execve and store the counts in the BPF MAP. And the user state part of the program reads the count in this MAP and outputs the count value at regular intervals.</p>
<p>Let&rsquo;s take a look at the source code of the kernel state part of BPF.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// https://github.com/bigwhite/experiments/tree/master/ebpf-examples/execve-counter/execve_counter.bpf.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;bpf/bpf_helpers.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">__u64</span> <span class="n">u64</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">char</span> <span class="n">stringkey</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">__uint</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">BPF_MAP_TYPE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">__uint</span><span class="p">(</span><span class="n">max_entries</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//__type(key, stringkey);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">stringkey</span><span class="o">*</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">u64</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">execve_counter</span> <span class="n">SEC</span><span class="p">(</span><span class="s">&#34;.maps&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">SEC</span><span class="p">(</span><span class="s">&#34;tracepoint/syscalls/sys_enter_execve&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">bpf_prog</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">stringkey</span> <span class="n">key</span> <span class="o">=</span> <span class="s">&#34;execve_counter&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">u64</span> <span class="o">*</span><span class="n">v</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span> <span class="o">=</span> <span class="n">bpf_map_lookup_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">execve_counter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">v</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">LICENSE</span><span class="p">[]</span> <span class="n">SEC</span><span class="p">(</span><span class="s">&#34;license&#34;</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;Dual BSD/GPL&#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Unlike the helloworld example, we have defined a map structure execve_counter in the new example, which is marked as a BPF MAP variable by the SEC macro.</p>
<p>This map structure has four fields as follows.</p>
<ul>
<li>type: the BPF MAP type used (see the previous bpf_map_type enumeration type), here we use BPF_MAP_TYPE_HASH, i.e. a hash hash table structure.</li>
<li>max_entries: the maximum number of key-value pairs within the map.</li>
<li>key: a pointer to the key memory space. Here we customize a type stringkey(char[64]) to indicate the type of each key element.</li>
<li>value: a pointer to the value memory space, here the value element is of type u64, a 64-bit integer.</li>
</ul>
<p>The implementation of the kernel state function bpf_prog is also relatively simple: look up the key &ldquo;execve_counter&rdquo; in the map above, and if you find it, add 1 to the value in the memory pointed to by the value pointer.</p>
<p>Let&rsquo;s take a look at the source code of the user state part of the execve_counter example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// https://github.com/bigwhite/experiments/tree/master/ebpf-examples/execve_counter/execve_counter.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">include</span> <span class="p">&lt;</span><span class="nx">stdio</span><span class="p">.</span><span class="nx">h</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">include</span> <span class="p">&lt;</span><span class="nx">unistd</span><span class="p">.</span><span class="nx">h</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">include</span> <span class="p">&lt;</span><span class="nx">sys</span><span class="o">/</span><span class="nx">resource</span><span class="p">.</span><span class="nx">h</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">include</span> <span class="p">&lt;</span><span class="nx">bpf</span><span class="o">/</span><span class="nx">libbpf</span><span class="p">.</span><span class="nx">h</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">include</span> <span class="p">&lt;</span><span class="nx">linux</span><span class="o">/</span><span class="nx">bpf</span><span class="p">.</span><span class="nx">h</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="err">#</span><span class="nx">include</span> <span class="s">&#34;execve_counter.skel.h&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">typedef</span> <span class="nx">__u64</span> <span class="nx">u64</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">typedef</span> <span class="nx">char</span> <span class="nx">stringkey</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">static</span> <span class="kt">int</span> <span class="nf">libbpf_print_fn</span><span class="p">(</span><span class="nx">enum</span> <span class="nx">libbpf_print_level</span> <span class="nx">level</span><span class="p">,</span> <span class="kd">const</span> <span class="nx">char</span> <span class="o">*</span><span class="nx">format</span><span class="p">,</span> <span class="nx">va_list</span> <span class="nx">args</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">vfprintf</span><span class="p">(</span><span class="nx">stderr</span><span class="p">,</span> <span class="nx">format</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="nx">argc</span><span class="p">,</span> <span class="nx">char</span> <span class="o">**</span><span class="nx">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">struct</span> <span class="nx">execve_counter_bpf</span> <span class="o">*</span><span class="nx">skel</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nx">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">libbpf_set_strict_mode</span><span class="p">(</span><span class="nx">LIBBPF_STRICT_ALL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Set up libbpf errors and debug info callback */</span>
</span></span><span class="line"><span class="cl">    <span class="nf">libbpf_set_print</span><span class="p">(</span><span class="nx">libbpf_print_fn</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Open BPF application */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">skel</span> <span class="p">=</span> <span class="nf">execve_counter_bpf__open</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(!</span><span class="nx">skel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="nx">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to open BPF skeleton\n&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Load &amp; verify BPF programs */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">err</span> <span class="p">=</span> <span class="nf">execve_counter_bpf__load</span><span class="p">(</span><span class="nx">skel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="nx">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to load and verify BPF skeleton\n&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* init the counter */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stringkey</span> <span class="nx">key</span> <span class="p">=</span> <span class="s">&#34;execve_counter&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">u64</span> <span class="nx">v</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">err</span> <span class="p">=</span> <span class="nf">bpf_map__update_elem</span><span class="p">(</span><span class="nx">skel</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">maps</span><span class="p">.</span><span class="nx">execve_counter</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">key</span><span class="p">,</span> <span class="nf">sizeof</span><span class="p">(</span><span class="nx">key</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">,</span> <span class="nf">sizeof</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">BPF_ANY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="nx">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to init the counter, %d\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* Attach tracepoint handler */</span>
</span></span><span class="line"><span class="cl">    <span class="nx">err</span> <span class="p">=</span> <span class="nf">execve_counter_bpf__attach</span><span class="p">(</span><span class="nx">skel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">fprintf</span><span class="p">(</span><span class="nx">stderr</span><span class="p">,</span> <span class="s">&#34;Failed to attach BPF skeleton\n&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// read counter value from map
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">err</span> <span class="p">=</span> <span class="nf">bpf_map__lookup_elem</span><span class="p">(</span><span class="nx">skel</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">maps</span><span class="p">.</span><span class="nx">execve_counter</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">key</span><span class="p">,</span> <span class="nf">sizeof</span><span class="p">(</span><span class="nx">key</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">,</span> <span class="nf">sizeof</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="nx">BPF_ANY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="nf">fprintf</span><span class="p">(</span><span class="nx">stderr</span><span class="p">,</span> <span class="s">&#34;Lookup key from map error: %d\n&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">               <span class="k">goto</span> <span class="nx">cleanup</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;execve_counter is %llu\n&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="nf">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">cleanup</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">execve_counter_bpf__destroy</span><span class="p">(</span><span class="nx">skel</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="nx">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The map is created in execve_counter_bpf__load, and as you will see by tracing the code (refer to the libbpf source code), the bpf system call is eventually called to create the map.</p>
<p>The difference with the helloworld example is that we initialize the key in the bpf map using the bpf_map__update_elem wrapped in libbpf before attaching the handler (initialized to 0, without this step, the first time the bpf program is executed, it will prompt that the key cannot be found).</p>
<p>Then after attaching the handler, we look up the value of key=&ldquo;execve_counter&rdquo; every 5s in a loop via bpf_map__lookup_elem and output it to the console.</p>
<p>Next we run make to compile the ebpf program, then execute it and observe the output.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">$sudo</span> ./execve_counter
</span></span><span class="line"><span class="cl">libbpf: loading object <span class="s1">&#39;execve_counter_bpf&#39;</span> from buffer
</span></span><span class="line"><span class="cl">libbpf: elf: section<span class="o">(</span>3<span class="o">)</span> tracepoint/syscalls/sys_enter_execve, size 192, link 0, flags 6, <span class="nv">type</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">libbpf: sec <span class="s1">&#39;tracepoint/syscalls/sys_enter_execve&#39;</span>: found program <span class="s1">&#39;bpf_prog&#39;</span> at insn offset <span class="m">0</span> <span class="o">(</span><span class="m">0</span> bytes<span class="o">)</span>, code size <span class="m">24</span> insns <span class="o">(</span><span class="m">192</span> bytes<span class="o">)</span>
</span></span><span class="line"><span class="cl">libbpf: elf: section<span class="o">(</span>4<span class="o">)</span> .reltracepoint/syscalls/sys_enter_execve, size 16, link 22, flags 0, <span class="nv">type</span><span class="o">=</span><span class="m">9</span>
</span></span><span class="line"><span class="cl">libbpf: elf: section<span class="o">(</span>5<span class="o">)</span> .rodata, size 64, link 0, flags 2, <span class="nv">type</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">libbpf: elf: section<span class="o">(</span>6<span class="o">)</span> .maps, size 32, link 0, flags 3, <span class="nv">type</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">libbpf: elf: section<span class="o">(</span>7<span class="o">)</span> license, size 13, link 0, flags 3, <span class="nv">type</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">libbpf: license of execve_counter_bpf is Dual BSD/GPL
</span></span><span class="line"><span class="cl">libbpf: elf: section<span class="o">(</span>13<span class="o">)</span> .BTF, size 898, link 0, flags 0, <span class="nv">type</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">libbpf: elf: section<span class="o">(</span>15<span class="o">)</span> .BTF.ext, size 176, link 0, flags 0, <span class="nv">type</span><span class="o">=</span><span class="m">1</span>
</span></span><span class="line"><span class="cl">libbpf: elf: section<span class="o">(</span>22<span class="o">)</span> .symtab, size 744, link 1, flags 0, <span class="nv">type</span><span class="o">=</span><span class="m">2</span>
</span></span><span class="line"><span class="cl">libbpf: looking <span class="k">for</span> externs among <span class="m">31</span> symbols...
</span></span><span class="line"><span class="cl">libbpf: collected <span class="m">0</span> externs total
</span></span><span class="line"><span class="cl">libbpf: map <span class="s1">&#39;execve_counter&#39;</span>: at sec_idx 6, offset 0.
</span></span><span class="line"><span class="cl">libbpf: map <span class="s1">&#39;execve_counter&#39;</span>: found <span class="nb">type</span> <span class="o">=</span> 1.
</span></span><span class="line"><span class="cl">libbpf: map <span class="s1">&#39;execve_counter&#39;</span>: found key <span class="o">[</span>9<span class="o">]</span>, <span class="nv">sz</span> <span class="o">=</span> 64.
</span></span><span class="line"><span class="cl">libbpf: map <span class="s1">&#39;execve_counter&#39;</span>: found value <span class="o">[</span>13<span class="o">]</span>, <span class="nv">sz</span> <span class="o">=</span> 8.
</span></span><span class="line"><span class="cl">libbpf: map <span class="s1">&#39;execve_counter&#39;</span>: found <span class="nv">max_entries</span> <span class="o">=</span> 128.
</span></span><span class="line"><span class="cl">libbpf: map <span class="s1">&#39;execve_c.rodata&#39;</span> <span class="o">(</span>global data<span class="o">)</span>: at sec_idx 5, offset 0, flags 480.
</span></span><span class="line"><span class="cl">libbpf: map <span class="m">1</span> is <span class="s2">&#34;execve_c.rodata&#34;</span>
</span></span><span class="line"><span class="cl">libbpf: sec <span class="s1">&#39;.reltracepoint/syscalls/sys_enter_execve&#39;</span>: collecting relocation <span class="k">for</span> section<span class="o">(</span>3<span class="o">)</span> <span class="s1">&#39;tracepoint/syscalls/sys_enter_execve&#39;</span>
</span></span><span class="line"><span class="cl">libbpf: sec <span class="s1">&#39;.reltracepoint/syscalls/sys_enter_execve&#39;</span>: relo <span class="c1">#0: insn #15 against &#39;execve_counter&#39;</span>
</span></span><span class="line"><span class="cl">libbpf: prog <span class="s1">&#39;bpf_prog&#39;</span>: found map <span class="m">0</span> <span class="o">(</span>execve_counter, sec 6, off 0<span class="o">)</span> <span class="k">for</span> insn <span class="c1">#15</span>
</span></span><span class="line"><span class="cl">libbpf: map <span class="s1">&#39;execve_counter&#39;</span>: created successfully, <span class="nv">fd</span><span class="o">=</span><span class="m">4</span>
</span></span><span class="line"><span class="cl">libbpf: map <span class="s1">&#39;execve_c.rodata&#39;</span>: created successfully, <span class="nv">fd</span><span class="o">=</span><span class="m">5</span>
</span></span><span class="line"><span class="cl">execve_counter is <span class="m">0</span>
</span></span><span class="line"><span class="cl">execve_counter is <span class="m">0</span>
</span></span><span class="line"><span class="cl">execve_counter is <span class="m">9</span>
</span></span><span class="line"><span class="cl">execve_counter is <span class="m">23</span>
</span></span><span class="line"><span class="cl">... ...
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Note: If you don&rsquo;t know how to compile the execve_counter example, please first move to &ldquo;<a href="/post/2022-07/c-ebpf/">Developing a Hello World-level eBPF program from scratch using C</a>&rdquo; to understand how it is built.</p>
</blockquote>
<p>The bpftool tool provides the feature to view the map, through which we can view the map created by the example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">$sudo</span> bpftool map
</span></span><span class="line"><span class="cl">114: <span class="nb">hash</span>  name execve_counter  flags 0x0
</span></span><span class="line"><span class="cl">    key 64B  value 8B  max_entries <span class="m">128</span>  memlock 20480B
</span></span><span class="line"><span class="cl">    btf_id <span class="m">120</span>
</span></span><span class="line"><span class="cl">116: array  name execve_c.rodata  flags 0x80
</span></span><span class="line"><span class="cl">    key 4B  value 64B  max_entries <span class="m">1</span>  memlock 4096B
</span></span><span class="line"><span class="cl">    frozen
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can also dump the entire map.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">$sudo</span> bpftool map dump id <span class="m">114</span>
</span></span><span class="line"><span class="cl"><span class="o">[{</span>
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;key&#34;</span>: <span class="s2">&#34;execve_counter&#34;</span>,
</span></span><span class="line"><span class="cl">        <span class="s2">&#34;value&#34;</span>: <span class="m">23</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>We see that there is only one key-value pair (key=&ldquo;execve_counter&rdquo;) in the entire map, and its value is the same as the output of the user-state part of the example program.</p>
<p>Well, with the C example as a base, let&rsquo;s see how to implement this example based on Go.</p>
<h3 id="4-example-of-using-go-to-implement-execve-counter-based-on-ciliumebpf">4. Example of using Go to implement execve-counter based on cilium/ebpf</h3>
<p>It is much easier to use Go to develop the user state part of a BPF program, and the packages provided by cilium/ebpf are very easy to use. If you don&rsquo;t know how to use Go to develop the user state part of ebpf programs, please go to the article <a href="/post/2022-07/go-ebpf/">&ldquo;Developing eBPF programs using Go language&rdquo;</a>  to learn more.</p>
<p>The essential raw material for the Go example is execve_counter.bpf.c. The only difference between this C source file and execve_counter.bpf.c in the execve_counter example above is that the include header file has been changed to common.h.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="line"><span class="cl">$diff execve_counter.bpf.c ../execve-counter/execve_counter.bpf.c
</span></span><span class="line"><span class="cl">1,2c1,2
</span></span><span class="line"><span class="cl">&lt;
</span></span><span class="line"><span class="cl">&lt; #include &#34;common.h&#34;
</span></span><span class="line"><span class="cl"><span class="gd">---
</span></span></span><span class="line"><span class="cl"><span class="gd"></span>&gt; #include &lt;linux/bpf.h&gt;
</span></span><span class="line"><span class="cl">&gt; #include &lt;bpf/bpf_helpers.h&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Based on the raw material execve_counter.bpf.c, the bpf2go tool generates the Go source code needed for the user state part, e.g. the bpf map instance contained in bpfObject.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// bpfMaps contains all maps after they have been loaded into the kernel.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// It can be passed to loadBpfObjects or ebpf.CollectionSpec.LoadAndAssign.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">bpfMaps</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ExecveCounter</span> <span class="o">*</span><span class="nx">ebpf</span><span class="p">.</span><span class="nx">Map</span> <span class="s">`ebpf:&#34;execve_counter&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Finally, we can use these generated Go functions related to bpf objects directly in the main function of the main package, here is the main.go part of the source code.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// https://github.com/bigwhite/experiments/tree/master/ebpf-examples/execve-counter-go/main.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// $BPF_CLANG, $BPF_CFLAGS and $BPF_HEADERS are set by the Makefile.
</span></span></span><span class="line"><span class="cl"><span class="c1">//go:generate bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS -target bpfel,bpfeb bpf execve_counter.bpf.c -- -I $BPF_HEADERS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">stopper</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Signal</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">signal</span><span class="p">.</span><span class="nf">Notify</span><span class="p">(</span><span class="nx">stopper</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Interrupt</span><span class="p">,</span> <span class="nx">syscall</span><span class="p">.</span><span class="nx">SIGTERM</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Allow the current process to lock memory for eBPF resources.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rlimit</span><span class="p">.</span><span class="nf">RemoveMemlock</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Load pre-compiled programs and maps into the kernel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">objs</span> <span class="o">:=</span> <span class="nx">bpfObjects</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">loadBpfObjects</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">objs</span><span class="p">,</span> <span class="kc">nil</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;loading objects: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">objs</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// init the map element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">key</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">    <span class="nb">copy</span><span class="p">(</span><span class="nx">key</span><span class="p">[:],</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;execve_counter&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">val</span> <span class="kt">int64</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">objs</span><span class="p">.</span><span class="nx">bpfMaps</span><span class="p">.</span><span class="nx">ExecveCounter</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;init map key error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// attach to xxx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">kp</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">link</span><span class="p">.</span><span class="nf">Tracepoint</span><span class="p">(</span><span class="s">&#34;syscalls&#34;</span><span class="p">,</span> <span class="s">&#34;sys_enter_execve&#34;</span><span class="p">,</span> <span class="nx">objs</span><span class="p">.</span><span class="nx">BpfProg</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;opening tracepoint: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">kp</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">ticker</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">ticker</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ticker</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">objs</span><span class="p">.</span><span class="nx">bpfMaps</span><span class="p">.</span><span class="nx">ExecveCounter</span><span class="p">.</span><span class="nf">Lookup</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">val</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">log</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;reading map error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;execve_counter: %d\n&#34;</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stopper</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Wait for a signal and close the perf reader,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// which will interrupt rd.Read() and make the program exit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Received signal, exiting program..&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the main function, we access the map instance directly through objs.bpfMaps.ExecveCounter, and can manipulate the map directly through its Put and Lookup methods. here it should be noted that the type of key must be consistent with the key type (char[64]) in execve_counter.bpf.c. The memory layout is the same, you cannot use string type directly, otherwise the following error will be reported in the execution.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">init map key error: can&#39;t marshal key: string doesn&#39;t marshal to 64 bytes
</span></span></code></pre></td></tr></table>
</div>
</div><p>Compiling and executing execve-counter-go is no different from helloworld-go.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">$make</span>
</span></span><span class="line"><span class="cl"><span class="nv">$go</span> run -exec sudo main.go bpf_bpfel.go
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">2022/07/17 16:59:52 execve_counter: <span class="m">0</span>
</span></span><span class="line"><span class="cl">2022/07/17 16:59:57 execve_counter: <span class="m">14</span>
</span></span><span class="line"><span class="cl">^C2022/07/17 16:59:59 Received signal, exiting program..
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="5-summary">5. Summary</h3>
<p>This article introduced the main method for exchanging data between the eBPF kernel-state part and the user-state part: the BPF MAP mechanism. MAP here is not a hash table in the narrow sense, but a container of abstract data structures, currently supporting more than two dozen data structures, so you can pick the appropriate structure according to your needs (you can consult the manual to understand the characteristics of various data structures).</p>
<p>MAP is also essentially created by the bpf system call. The bpf program only needs to declare the key, value, type and other composition information of MAP. The user state can operate the map through the fd returned by the bpf system call. libbpf and cilium/ebpf, etc. encapsulate the operation of the fd, which simplifies the use of the API.</p>
<p>The map update operation in the kernel is not atomic, so when there are multiple bpf programs accessing a map concurrently, the operation needs to be synchronized. bpf provides bpf_spin_lock to synchronize the map operation. We can add bpf_spin_lock to the value type to synchronize changes to the value, as in the following example (example from the book <code>Linux Observability with BPF</code>).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">struct</span> <span class="nx">concurrent_element</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">struct</span> <span class="nx">bpf_spin_lock</span> <span class="nx">semaphore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="nx">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">struct</span> <span class="nx">bpf_map_def</span> <span class="nf">SEC</span><span class="p">(</span><span class="s">&#34;maps&#34;</span><span class="p">)</span> <span class="nx">concurrent_map</span> <span class="p">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="kd">type</span> <span class="p">=</span> <span class="nx">BPF_MAP_TYPE_HASH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">key_size</span> <span class="p">=</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">value_size</span> <span class="p">=</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kd">struct</span> <span class="nx">concurrent_element</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="nx">max_entries</span> <span class="p">=</span> <span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bpf_program</span><span class="p">(</span><span class="kd">struct</span> <span class="nx">pt_regs</span> <span class="o">*</span><span class="nx">ctx</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">intkey</span><span class="p">=</span><span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kd">struct</span> <span class="nx">concurrent_element</span> <span class="nx">init_value</span> <span class="p">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">      <span class="kd">struct</span> <span class="nx">concurrent_element</span> <span class="o">*</span><span class="nx">read_value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">bpf_map_create_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">concurrent_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">init_value</span><span class="p">,</span> <span class="nx">BPF_NOEXIST</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">read_value</span> <span class="p">=</span> <span class="nf">bpf_map_lookup_elem</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">concurrent_map</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nf">bpf_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">read_value</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">semaphore</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="nx">read_value</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">count</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">bpf_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">read_value</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">semaphore</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The code involved in this article can be downloaded at <a href="https://github.com/bigwhite/experiments/tree/master/ebpf-examples">here</a>.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-07/go-plugin-faq/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">FAQ about Go plugin and solutions</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-07/gopsutil/">
            <span class="next-text nav-default">Get OS information using gopsutil</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
