<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Go 1.18 things - workspace, fuzzy tests, generics - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore three very important new features in Golang 1.18, workspace, fuzzy tests, and generics." /><meta name="keywords" content="golang 1.8, workspace, fuzzy tests, generics" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-07/go-1-8/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Go 1.18 things - workspace, fuzzy tests, generics" />
<meta property="og:description" content="Explore three very important new features in Golang 1.18, workspace, fuzzy tests, and generics." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-07/go-1-8/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-11T12:32:41+08:00" />
<meta property="article:modified_time" content="2022-07-11T12:32:41+08:00" />

<meta itemprop="name" content="Go 1.18 things - workspace, fuzzy tests, generics">
<meta itemprop="description" content="Explore three very important new features in Golang 1.18, workspace, fuzzy tests, and generics."><meta itemprop="datePublished" content="2022-07-11T12:32:41+08:00" />
<meta itemprop="dateModified" content="2022-07-11T12:32:41+08:00" />
<meta itemprop="wordCount" content="4871">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 1.18 things - workspace, fuzzy tests, generics"/>
<meta name="twitter:description" content="Explore three very important new features in Golang 1.18, workspace, fuzzy tests, and generics."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Go 1.18 things - workspace, fuzzy tests, generics</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-07-11 12:32:41 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4871 words </span>
          <span class="more-meta"> 10 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#go-workspace-mode">Go Workspace Mode</a>
          <ul>
            <li><a href="#realistic-situation">Realistic situation</a></li>
            <li><a href="#what-is-the-workspace-pattern">What is the Workspace Pattern</a></li>
            <li><a href="#recommended-usage">Recommended usage</a></li>
            <li><a href="#points-to-note-when-using">Points to note when using</a></li>
          </ul>
        </li>
        <li><a href="#go-fuzzing-test">Go Fuzzing Test</a>
          <ul>
            <li><a href="#why-golang-supports-fuzzing-tests">Why Golang supports fuzzing tests</a></li>
            <li><a href="#what-is-fuzzy-testing">What is fuzzy testing</a></li>
            <li><a href="#how-golangs-fuzzy-tests-are-used">How Golang&rsquo;s fuzzy tests are used</a></li>
            <li><a href="#notes-on-use">Notes on use</a></li>
          </ul>
        </li>
        <li><a href="#gos-generics">Go&rsquo;s Generics</a>
          <ul>
            <li><a href="#type-parameters">Type Parameters</a></li>
            <li><a href="#type-sets">Type Sets</a></li>
            <li><a href="#type-inference">Type Inference</a></li>
            <li><a href="#derived-algorithm-with-examples">derived algorithm with examples</a></li>
            <li><a href="#deduction-algorithm-with-examples">Deduction algorithm with examples</a></li>
            <li><a href="#simple-example">Simple example</a></li>
            <li><a href="#a-more-complex-example">A more complex example</a></li>
            <li><a href="#limitations-of-using-generics">Limitations of using generics</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>On March 15, 2022, Google released the much-anticipated Golang 1.18, which brings several major new features.</p>
<ol>
<li>a workspace to solve some of the problems associated with developing multiple repositories locally at the same time</li>
<li>a Fuzzing Test that automatically detects code branches, generates random input, and checks to see if the code panics</li>
<li>generic support that many developers have been waiting for.</li>
</ol>
<blockquote>
<p>This article will briefly describe these three features.</p>
</blockquote>
<h2 id="go-workspace-mode">Go Workspace Mode</h2>
<h3 id="realistic-situation">Realistic situation</h3>
<h4 id="multi-repository-development">Multi-repository development</h4>
<p>In practice, we often modify multiple modules that have dependencies at the same time, for example, if we implement a requirement on a service module, we also need to make changes to a common module of the project team, the whole workflow will look like this.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/11/1a18e57df6fa42eb9a65fd16c0ab24ec.png" alt="workflow"></p>
<p>As you can see, every time you modify the Common library, you need to push the code to the remote end, then modify the dependency of the local service repository, and then pull the Common code from the remote end via go mod tidy, which is a lot of trouble.</p>
<p>Some people may ask, In this case, can&rsquo;t we just add a replace clause to go.mod in the service repository?</p>
<p>However, if you use replace in go.mod, you need to pay extra mental cost in maintenance, and if the go.mod with replace is pushed to the remote code base, others will be confused.</p>
<h4 id="multiple-new-repositories-start-development">Multiple new repositories start development</h4>
<p>Suppose at this point I am developing two new modules, as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">code.byted.org/SomeNewProject/Common
</span></span><span class="line"><span class="cl">code.byted.org/SomeNewProject/MyService
</span></span></code></pre></td></tr></table>
</div>
</div><p>And MyService relies on Common.</p>
<p>During development, for various reasons, the code may not be pushed to the remote end immediately. So if I need to compile MyService locally, go build (or go mod tidy) will fail to automatically download the dependency because the Common library is not published to the codebase at all.</p>
<p>For the same reason as the &ldquo;multiple repository simultaneous development&rdquo; above, replace should not be added to MyService&rsquo;s go.mod file either.</p>
<h3 id="what-is-the-workspace-pattern">What is the Workspace Pattern</h3>
<p>The Go workspace pattern first emerged from a proposal by Go developer Michael Matloob in April 2021 called &ldquo;Multi-Module Workspaces in cmd/go&rdquo;.</p>
<p>In this proposal, a new go.work file is created, and a series of local paths are specified in this file. The go modules under these local paths together form a workspace, and go commands can manipulate the go modules under these paths, and these go modules will be used first when compiling.</p>
<p>A workspace can be initialized and an empty go.work file generated with the following command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go work init .
</span></span></code></pre></td></tr></table>
</div>
</div><p>The contents of the newly generated go.work file are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go 1.18
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">directory ./.
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the go.work file, the directory indicates the module directories in the workspace, and when compiling code, modules under the same workspace are used first.</p>
<p>In go.work, there is also support for using replace to specify the local code base, but in most cases it is better to add the path of the dependent local code base to the directory.</p>
<h3 id="recommended-usage">Recommended usage</h3>
<p>Because go.work describes a local workspace, it cannot be committed to a remote repository. Although you can add this file to .gitignore, the most recommended approach is to use go.work in the upper level of the local repository.</p>
<p>For example, in the &ldquo;multiple new repositories to start development&rdquo; example above, let&rsquo;s say that the local paths of my two repositories are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">/Users/bytedance/dev/my_new_project/common
</span></span><span class="line"><span class="cl">/Users/bytedance/dev/my_new_project/my_service
</span></span></code></pre></td></tr></table>
</div>
</div><p>Then I can generate a go.work in the &ldquo;/Users/bytedance/dev/my_new_project&rdquo; directory with the following content.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">/Users/bytedance/dev/my_new_project/go.work:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">go 1.18
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">directory <span class="o">(</span>
</span></span><span class="line"><span class="cl">    ./common
</span></span><span class="line"><span class="cl">    ./my_service
</span></span><span class="line"><span class="cl"><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>You can also organize multiple directories into a workspace by placing go.work in the top-level directory, and since the top-level directory itself is not managed by git, you don&rsquo;t have to worry about gitignore or anything like that, which is a relatively painless way to go.</p>
<h3 id="points-to-note-when-using">Points to note when using</h3>
<p>Currently (go 1.18) only go build makes judgments about go.work, and go mod tidy does not care about Go workspaces.</p>
<h2 id="go-fuzzing-test">Go Fuzzing Test</h2>
<h3 id="why-golang-supports-fuzzing-tests">Why Golang supports fuzzing tests</h3>
<p>Since 1.18, Fuzzing Test has been added to Golang&rsquo;s testing standard library as a part of language security, for the obvious reason that security is an essential and increasingly important consideration for programmers building software.</p>
<p>Golang has so far provided a number of features and tools for language security, such as enforcing explicit type conversions, disabling implicit type conversions, checking for out-of-bounds access to arrays and slices, hashing dependency packages with go.sum, and more.</p>
<p>As we enter the cloud-native era, Golang has become one of the head languages for cloud-native infrastructure and services. The security requirements of these systems are naturally self-evident. Especially for user input, it is one of the basic requirements for these systems not to be handled exceptionally, crash, or be manipulated by user input.</p>
<p>This requires our systems to be stable when handling any user input, but traditional quality assurance tools, such as Code Review, static analysis, manual testing, Unit Test, and so on. In the face of increasingly complex systems, it is naturally impossible to exhaust all possible combinations of inputs, especially some very obscure corner cases.</p>
<p>Fuzzy testing is one of the best practices in the industry to solve this problem, so it is not hard to understand why Golang chooses to support it.</p>
<h3 id="what-is-fuzzy-testing">What is fuzzy testing</h3>
<p>Fuzzy testing is a way to test a program by automatically constructing some random data as input to the program through a data construction engine, supplemented by some initial data that the developer can provide. Fuzzy testing can help developers find hard-to-find errors in stability, logic, and even security, especially as the system under test becomes more complex.</p>
<p>Instead of relying on a data set defined by the development tester, fuzzy testing is usually implemented as a set of random data constructed by the data construction engine itself. The fuzzy tests provide this data as input to the program under test and monitor it for panic, assertion failure, infinite loops, or any other exceptions. The data generated by the data construction engine is called <strong>corpus</strong>, and fuzzy tests are also a means of continuous testing, because if there is no limit on the number of executions or the maximum time of execution, it will keep on executing.</p>
<p>Golang&rsquo;s fuzzing tests are implemented in the compiler toolchain, so they use an entry generation technique called &ldquo;coverage guided fuzzing&rdquo;, which runs roughly as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/11/23d95ff94f134835bec387e16fbf357a.png" alt="Golang&amp;rsquo;s fuzzing tests"></p>
<h3 id="how-golangs-fuzzy-tests-are-used">How Golang&rsquo;s fuzzy tests are used</h3>
<p>Golang&rsquo;s fuzzy tests can simply be used directly when using them, or you can provide some initial corpus yourself.</p>
<h4 id="the-simplest-practical-example">The simplest practical example</h4>
<p>The fuzzy test functions are also placed in xxx_test.go. To write the simplest fuzzy test example (with the obvious divide-by-0 error).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;testing&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">FuzzDiv</span><span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">F</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">f</span><span class="p">.</span><span class="nf">Fuzz</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="o">/</span><span class="nx">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As you can see, similar to unit tests, the function names for fuzz tests are in FuzzXxx format and accept a <code>testing.F</code> pointer object.</p>
<p>The fuzz test is then performed on the specified function using <code>f.Fuzz</code> in the function. The first argument to the function being tested must be of type <code>*testing.T</code>, and can be followed by any number of arguments of the basic type.</p>
<p>After writing, use the following command to start the fuzz test.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go <span class="nb">test</span> -fuzz .
</span></span></code></pre></td></tr></table>
</div>
</div><p>The fuzz test will continue by default, as long as the function being tested is not panic or error free. The &ldquo;-fuzztime&rdquo; option can be used to limit the duration of the fuzz test.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">go <span class="nb">test</span> -fuzztime 10s -fuzz .
</span></span></code></pre></td></tr></table>
</div>
</div><p>When you test the above code with fuzzy test, you will encounter a panic situation, and the fuzzy test will output the following message.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">warning: starting with empty corpus
</span></span><span class="line"><span class="cl">fuzz: elapsed: 0s, execs: 0 (0/sec), new interesting: 0 (total: 0)
</span></span><span class="line"><span class="cl">fuzz: elapsed: 0s, execs: 1 (65/sec), new interesting: 0 (total: 0)
</span></span><span class="line"><span class="cl">--- FAIL: FuzzDiv (0.02s)
</span></span><span class="line"><span class="cl">    --- FAIL: FuzzDiv (0.00s)
</span></span><span class="line"><span class="cl">        testing.go:1349: panic: runtime error: integer divide by zero
</span></span><span class="line"><span class="cl">            goroutine 11 [running]:
</span></span><span class="line"><span class="cl">            runtime/debug.Stack()
</span></span><span class="line"><span class="cl">                    /Users/bytedance/.mytools/go/src/runtime/debug/stack.go:24 +0x90
</span></span><span class="line"><span class="cl">            testing.tRunner.func1()
</span></span><span class="line"><span class="cl">                    /Users/bytedance/.mytools/go/src/testing/testing.go:1349 +0x1f2
</span></span><span class="line"><span class="cl">            panic({0x1196b80, 0x12e3140})
</span></span><span class="line"><span class="cl">                    /Users/bytedance/.mytools/go/src/runtime/panic.go:838 +0x207
</span></span><span class="line"><span class="cl">            mydev/fuzz.FuzzDiv.func1(0x0?, 0x0?, 0x0?)
</span></span><span class="line"><span class="cl">                    /Users/bytedance/Documents/dev_test/fuzz/main_test.go:8 +0x8c
</span></span><span class="line"><span class="cl">            reflect.Value.call({0x11932a0?, 0x11cbf68?, 0x13?}, {0x11be123, 0x4}, {0xc000010420, 0x3, 0x4?})
</span></span><span class="line"><span class="cl">                    /Users/bytedance/.mytools/go/src/reflect/value.go:556 +0x845
</span></span><span class="line"><span class="cl">            reflect.Value.Call({0x11932a0?, 0x11cbf68?, 0x514?}, {0xc000010420, 0x3, 0x4})
</span></span><span class="line"><span class="cl">                    /Users/bytedance/.mytools/go/src/reflect/value.go:339 +0xbf
</span></span><span class="line"><span class="cl">            testing.(*F).Fuzz.func1.1(0x0?)
</span></span><span class="line"><span class="cl">                    /Users/bytedance/.mytools/go/src/testing/fuzz.go:337 +0x231
</span></span><span class="line"><span class="cl">            testing.tRunner(0xc000003a00, 0xc00007e3f0)
</span></span><span class="line"><span class="cl">                    /Users/bytedance/.mytools/go/src/testing/testing.go:1439 +0x102
</span></span><span class="line"><span class="cl">            created by testing.(*F).Fuzz.func1
</span></span><span class="line"><span class="cl">                    /Users/bytedance/.mytools/go/src/testing/fuzz.go:324 +0x5b8
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    Failing input written to testdata/fuzz/FuzzDiv/2058e4e611665fa289e5c0098bad841a6785bf79d30e47b96d8abcb0745a061c
</span></span><span class="line"><span class="cl">    To re-run:
</span></span><span class="line"><span class="cl">    go test -run=FuzzDiv/2058e4e611665fa289e5c0098bad841a6785bf79d30e47b96d8abcb0745a061c
</span></span><span class="line"><span class="cl">FAIL
</span></span><span class="line"><span class="cl">exit status 1
</span></span><span class="line"><span class="cl">FAIL        mydev/fuzz        0.059s
</span></span></code></pre></td></tr></table>
</div>
</div><p>Of which.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Failing input written to testdata/fuzz/FuzzDiv/2058e4e611665fa289e5c0098bad841a6785bf79d30e47b96d8abcb0745a061c
</span></span></code></pre></td></tr></table>
</div>
</div><p>This line indicates that the fuzzy test has saved the panic test input to this file, and tries to output the contents of this file at this time.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">go test fuzz v1
</span></span><span class="line"><span class="cl">int(-60)
</span></span><span class="line"><span class="cl">int(0)
</span></span></code></pre></td></tr></table>
</div>
</div><p>You can see the input that triggered the panic, and then we can check what is wrong with our code based on the input. Of course, this simple example is a deliberate write of a divide-by-0 error.</p>
<h4 id="provides-a-custom-corpus">provides a custom corpus</h4>
<p>Golang&rsquo;s fuzz testing also allows developers to provide their own initial corpus, either through the &ldquo;f.Add&rdquo; method or by writing the corpus in the same format as the &ldquo;Failing input&rdquo; above, to You can also write the corpus in the same format as &ldquo;Failing input&rdquo; above, in &ldquo;testdata/fuzz/FuzzXXX/custom corpus filename&rdquo;.</p>
<h3 id="notes-on-use">Notes on use</h3>
<p>Golang&rsquo;s fuzzy tests currently only support these types of arguments for the function being tested.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">byte</span><span class="p">,</span> <span class="kt">rune</span><span class="p">,</span> <span class="kt">float32</span><span class="p">,</span> <span class="kt">float64</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span><span class="p">,</span> <span class="kt">uint</span><span class="p">,</span> <span class="kt">uint8</span><span class="p">,</span> <span class="kt">uint16</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">,</span> <span class="kt">uint64</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>According to the documentation of the standard library, more type support will be added later.</p>
<h2 id="gos-generics">Go&rsquo;s Generics</h2>
<p>Golang finally added support for generics in 1.18. With generics, we can write some public library code like this.</p>
<p>Old code (reflection).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">IsContainCommon</span><span class="p">(</span><span class="nx">val</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">array</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">(</span><span class="nx">array</span><span class="p">).</span><span class="nf">Kind</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">reflect</span><span class="p">.</span><span class="nx">Slice</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lst</span> <span class="o">:=</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">ValueOf</span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">index</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="nx">lst</span><span class="p">.</span><span class="nf">Len</span><span class="p">();</span> <span class="nx">index</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">lst</span><span class="p">.</span><span class="nf">Index</span><span class="p">(</span><span class="nx">index</span><span class="p">).</span><span class="nf">Interface</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>New code (generic).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">IsContainCommon</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">val</span> <span class="nx">T</span><span class="p">,</span> <span class="nx">array</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">array</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">DeepEqual</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Generics add three important new features to Golang: 1.</p>
<ol>
<li>support for using Type parameters when defining functions and types</li>
<li>redefine interface as a &ldquo;collection of types&rdquo;.</li>
<li>generic type support type derivation</li>
</ol>
<p>The following is a brief explanation of each of these elements.</p>
<h3 id="type-parameters">Type Parameters</h3>
<p>The list of type parameters is very similar to the list of function parameters, except that it uses square brackets.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Min</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">](</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">y</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above code defines a parameter type T for the Min function, which is very similar to <code>template &lt; typename T &gt;</code> in C++, except that in Golang, you can specify the &ldquo;constraints&rdquo; that it needs to satisfy for this parameter type &ldquo;. In this example, the &ldquo;constraint&rdquo; used is <code>constraints.Ordered</code></p>
<p>The function can then be used as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">x</span> <span class="o">:=</span> <span class="nx">Min</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">y</span> <span class="o">:=</span> <span class="nx">Min</span><span class="p">[</span><span class="kt">float64</span><span class="p">](</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The process of specifying type parameters for a generic function is called &ldquo;instantiation&rdquo;, and the instantiated function can also be saved as a function object and used further.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">f</span> <span class="o">:=</span> <span class="nx">Min</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span> <span class="c1">// 这一步保存了一个实例化的函数对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">n</span> <span class="o">:=</span> <span class="nf">f</span><span class="p">(</span><span class="mi">123</span><span class="p">,</span> <span class="mi">456</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Similarly, custom types support generic types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TreeNode</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{}]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span> <span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Find</span><span class="p">(</span><span class="nx">x</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">myBinaryTree</span> <span class="nx">TreeNode</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As in the above code, the struct type supports its own member variables holding the same generic type as itself when using generics.</p>
<h3 id="type-sets">Type Sets</h3>
<p>Let&rsquo;s go a little deeper into the &ldquo;constraints&rdquo; mentioned in the above example. The &ldquo;int&rdquo;, &ldquo;float64&rdquo;, and &ldquo;int64&rdquo; in the above example are actually passed as &ldquo;parameters&rdquo; when instantiated. is passed to the &ldquo;type parameter list&rdquo;. That is, <code>[T constraints.Ordered]</code> in the example above.</p>
<p>Just like passing a normal parameter requires verifying the type of the parameter, passing a type parameter requires verifying the type of the parameter being passed, to check if the type being passed meets the requirements.</p>
<p>For example, in the example above, when instantiating the Min function with the types &ldquo;int&rdquo;, &ldquo;float64&rdquo;, and &ldquo;int64&rdquo;, the compiler will check whether these parameters satisfy the constraint &ldquo;constraints.Ordered&rdquo;. Ordered&rdquo; constraint, which describes the set of all types that can be compared using &ldquo;&lt;&rdquo;, and is itself an interface.</p>
<p>In Go&rsquo;s generics, a type constraint must be an interface, and the &ldquo;traditional&rdquo; Golang definition of an interface is &ldquo;an interface that defines a collection of methods&rdquo;, and any type that implements this collection of methods implements the interface. Any type that implements this set of methods implements this interface.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/11/3b2ea4ae48704be2ae9f91ae21b2f1af.png" alt="go Type Sets"></p>
<p>But here&rsquo;s where the problem arises: the &ldquo;&lt;&rdquo; comparison is clearly not a method (there are no C++ operator overloads in Go), and the constraints.Ordered describing the constraint is indeed an interface itself.</p>
<p>So starting with 1.18, Golang redefines an interface as &ldquo;a collection of types&rdquo;. As previously thought about interfaces, an interface can also be thought of as &ldquo;a collection of all types that implement the set of methods of the interface&rdquo;.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/11/175919e61c60444d9566a4992930ac97.png" alt="go interface"></p>
<p>The two views are actually similar, but the latter is obviously more flexible, specifying a set of concrete types as an interface directly, even if those types don&rsquo;t have any methods.</p>
<p>For example, in 1.18, an interface can be defined like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyInterface</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="p">|</span><span class="kt">bool</span><span class="p">|</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This definition means that int/bool/string can be used as MyInterface.</p>
<p>Ordered, which is actually defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Ordered</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Integer</span><span class="p">|</span><span class="nx">Float</span><span class="p">|</span><span class="err">~</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Float</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">float32</span><span class="p">|</span><span class="err">~</span><span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Integer</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Signed</span><span class="p">|</span><span class="nx">Unsigned</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Signed</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span><span class="p">|</span><span class="err">~</span><span class="kt">int8</span><span class="p">|</span><span class="err">~</span><span class="kt">int16</span><span class="p">|</span><span class="err">~</span><span class="kt">int32</span><span class="p">|</span><span class="err">~</span><span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Unsigned</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">uint</span><span class="p">|</span><span class="err">~</span><span class="kt">uint8</span><span class="p">|</span><span class="err">~</span><span class="kt">uint16</span><span class="p">|</span><span class="err">~</span><span class="kt">uint32</span><span class="p">|</span><span class="err">~</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>where the leading &ldquo;~&rdquo; symbol means &ldquo;any underlying type is the type of the type that follows&rdquo;, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyString</span> <span class="kt">string</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The MyString defined in this way satisfies the &ldquo;~string&rdquo; type constraint.</p>
<h3 id="type-inference">Type Inference</h3>
<p>Finally, type inference, which is common to all languages that support generics, is not absent. Type Inference allows users to call generic functions without specifying all type parameters. An example is the following function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 将F类型的slice变换为T类型的slice
</span></span></span><span class="line"><span class="cl"><span class="c1">// 关键字 any 等同于 interface{}
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nx">Map</span><span class="p">[</span><span class="nx">F</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">src</span> <span class="p">[]</span><span class="nx">F</span><span class="p">,</span> <span class="nx">f</span> <span class="kd">func</span><span class="p">(</span><span class="nx">F</span><span class="p">)</span> <span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ret</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">src</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">src</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nf">f</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ret</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>It can be used in the following way.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">myConv</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span><span class="kt">string</span> <span class="p">{</span><span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">i</span><span class="p">)}</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">src</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">dest</span> <span class="p">[]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="nx">dest</span> <span class="p">=</span> <span class="nx">Map</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">](</span><span class="nx">src</span><span class="p">,</span> <span class="nx">myConv</span><span class="p">)</span> <span class="c1">// 明确指定F和T的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">dest</span> <span class="p">=</span> <span class="nx">Map</span><span class="p">[</span><span class="kt">int</span><span class="p">](</span><span class="nx">src</span><span class="p">,</span> <span class="nx">myConv</span><span class="p">)</span> <span class="c1">// 仅指定F的类型，T的类型交由编译器推导
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">dest</span> <span class="p">=</span> <span class="nf">Map</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="nx">myConv</span><span class="p">)</span> <span class="c1">// 完全不指定类型，F和T都交由编译器推导
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Generic functions can be used without specifying specific type arguments, or by specifying only some of the types to the left of the type argument list. The compiler will report an error when automatic type derivation fails.</p>
<p>Type derivation in Golang generics is divided into two main parts.</p>
<ol>
<li>function argument type derivation: the specific types corresponding to the type arguments are derived from the function&rsquo;s input parameters.</li>
<li>Constraint type derivation: Inferring the specific type of an unknown type parameter from the type parameter of a known specific type.</li>
</ol>
<p>Both type derivations rely on a technique called &ldquo;Type Unification&rdquo;.</p>
<h4 id="type-unification">Type Unification</h4>
<p>Type unification is the comparison of two types, which may themselves be a type parameter or may contain a type parameter.</p>
<p>The process of comparison is a comparison of the &ldquo;structure&rdquo; of the two types and requires that the two types being compared satisfy the following conditions:</p>
<ol>
<li>the &ldquo;structure&rdquo; of the two types must match after eliminating the type parameter</li>
<li>the remaining specific types in the structure must be the same after the type parameters are removed</li>
<li>if neither type parameter is included, then both types must be identical, or the underlying data types must be identical</li>
</ol>
<p>By &ldquo;structure&rdquo;, we mean slice, map, function, etc. in the type definition, and any nesting between them.</p>
<p>When these conditions are met, the type uniformity comparison is successful and the compiler can further speculate on the type parameters, for example.</p>
<p>If we have two type parameters &ldquo;T1&rdquo; and &ldquo;T2&rdquo; at this time, then <code>[]map[int]bool</code> can match the following types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span> <span class="c1">// 它本身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">T1</span> <span class="c1">// T1被推断为 []map[int]bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[]</span><span class="nx">T1</span> <span class="c1">// T1被推断为 map[int]bool
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="nx">T2</span> <span class="c1">// T1被推断为 int, T2被推断为 bool
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/11/91025c72dac5441a8fb6cf9c5041fd8b.png" alt="go parameters"></p>
<p>As a counterexample, <code>[]map[int]bool</code> clearly does not match these types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">[]</span><span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="nx">T1</span><span class="p">]</span><span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="c1">// etc...
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="function-argument-type-inference">Function Argument Type Inference</h4>
<p>Function Argument Type Inference, as the name implies, is a generalized function that is called without all type arguments being fully specified, and then the compiler infers the specific types of the type arguments based on the types of the actual function inputs, such as the Min function at the beginning of this article.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Min</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">](</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">y</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">ans</span> <span class="o">:=</span> <span class="nf">Min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// 此时类型参数T被推导为int
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Like other languages that support generics, Golang&rsquo;s function argument type derivation only supports &ldquo;type arguments that can be derived from the input&rdquo;, and if the type argument is used to mark the return type, then the type argument must be explicitly specified when it is used.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">MyFunc</span><span class="p">[</span><span class="nx">T1</span><span class="p">,</span> <span class="nx">T2</span><span class="p">,</span> <span class="nx">T3</span> <span class="nx">any</span><span class="p">](</span><span class="nx">x</span> <span class="nx">T1</span><span class="p">)</span> <span class="nx">T2</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">x</span> <span class="nx">T3</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">ans</span> <span class="o">:=</span> <span class="nx">MyFunc</span><span class="p">[</span><span class="kt">int</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">string</span><span class="p">](</span><span class="mi">123</span><span class="p">)</span> <span class="c1">// 需要手动指定
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Functions like this, where part of the type parameter appears only in the return value (or only in the function body, not as an input or output parameter), cannot use function parameter type derivation, but must explicitly specify the type manually.</p>
<h3 id="derived-algorithm-with-examples">derived algorithm with examples</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/11/c1035c8c7ddb4826a2aa8cd386e959e5.png" alt="derived algorithm with examples"></p>
<p>Using the Min function as an example, we can explain the process of deriving function parameter types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">Min</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Ordered</span><span class="p">](</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="nx">y</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">x</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">y</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Let&rsquo;s look at the first scenario first.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">Min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>At this point, both input parameters are untyped literal constants, so the first round of type unification is skipped, and the specific type of the input parameters is not determined. At this point, the compiler tries to use the default type int for both parameters, and since the type of both input parameters at the function definition is &ldquo;T&rdquo;, and both use the default type int, T is successfully inferred to be int.</p>
<p>Then look at the second case.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">Min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>At this point, the second argument has an explicit type int64, so in the first round of type unification, T is inferred to be int64, and when trying to determine the type for the first argument &ldquo;1&rdquo; that was missed in the first round, T is successfully inferred to be int64 because &ldquo;1&rdquo; is a legal int64, T is successfully inferred as int64.</p>
<p>Let&rsquo;s look at the third case.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">Min</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>At this point, the second argument has a clear type int64, so in the first round of type unification, T is inferred to be int64, and when trying to determine the type for the first argument &ldquo;1.5&rdquo;, which was missed in the first round, the type inference fails because &ldquo;1.5&rdquo; is not is not a legal int64 type value, the type derivation fails and the compiler reports an error.</p>
<p>Finally, look at the fourth case.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">Min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Similar to the first case, the first round of type unification is skipped and the specific types of the two input parameters are not determined, so the compiler starts trying to use the default types. The default types of the two parameters are int and float64, and since the same type parameter T can only be determined as one type in type derivation, type derivation fails at this point as well.</p>
<h4 id="constraints-type-inference">Constraints Type Inference</h4>
<p>Constraint type inference is another powerful weapon of Golang generics, allowing the compiler to derive the specific type of a type parameter from another type parameter, and to preserve the caller&rsquo;s type information by using type parameters.</p>
<p>Constraint type derivation can allow constraints to be specified for a type parameter using other type parameters. Such constraints are called <strong>&ldquo;structured constraints&rdquo;</strong>.  Such constraints define the data structure that a type parameter must satisfy, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 将一个整数slice中的每个元素都x2后返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nx">DoubleSlice</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">E</span><span class="p">,</span> <span class="nx">E</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Integer</span><span class="p">](</span><span class="nx">slice</span> <span class="nx">S</span><span class="p">)</span> <span class="nx">S</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ret</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">S</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">item</span> <span class="o">+</span> <span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ret</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the definition of this function, &ldquo;~[]E&rdquo; is a shorthand for the structured constraint on S. It is written in its entirety as &ldquo;interface{~[]E}&rdquo;, i.e., an interface defined as a collection of types, and which contains only one definition of &ldquo;~[]E&rdquo;, meaning &ldquo;all types whose underlying data type is []E&rdquo;.</p>
<p>Note that the set of types corresponding to a legal structured constraint should satisfy any of the following conditions: 1.</p>
<ol>
<li>the set of types contains only one type</li>
<li>the underlying data types of all types in the type set are identical</li>
</ol>
<p>In this example, the structured constraint used by S is a legal structured constraint because the underlying data types of all types that satisfy the constraint are []E.</p>
<p>The compiler attempts constraint type derivation when there are type parameters that cannot be determined by <strong>function parameter type derivation</strong> for specific types and the list of type parameters <strong>contains structured constraints</strong>.</p>
<h3 id="deduction-algorithm-with-examples">Deduction algorithm with examples</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/11/6deb13d9a7564845a7fbe4391fc8965c.png" alt="Deduction algorithm with examples"></p>
<h3 id="simple-example">Simple example</h3>
<p>In conjunction with our example of the &ldquo;DoubleSlice&rdquo; function, let&rsquo;s talk about the specific process of constraint type derivation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MySlice</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">ans</span> <span class="o">:=</span> <span class="nf">DoubleSlice</span><span class="p">(</span><span class="nx">MySlice</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this call, the first thing performed is the normal function argument type derivation, and this step will result in a derivation like this</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">S</span> <span class="p">=&gt;</span> <span class="nx">MySlice</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>At this point the compiler finds that there is a type parameter E that has not been derived and that there is currently a type parameter S that uses structural constraints, so it starts constraining the type derivation.</p>
<p>The first thing to look for is a type parameter whose type derivation has been completed, in this case S, whose type has been derived as MySlice.</p>
<p>Then the actual type of S, &ldquo;MySlice&rdquo;, is unified with the structured constraint of S, &ldquo;~[]E&rdquo;, and since the underlying type of MySlice is []int, the structured match gives this match Result.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">E</span> <span class="p">=&gt;</span> <span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>At this point all type parameters have been inferred and conform to their respective constraints, and type derivation is over.</p>
<h3 id="a-more-complex-example">A more complex example</h3>
<p>Suppose there is a function such as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">SomeComplicatedMethod</span><span class="p">[</span><span class="nx">S</span> <span class="err">~</span><span class="p">[]</span><span class="nx">M</span><span class="p">,</span> <span class="nx">M</span> <span class="err">~</span><span class="kd">map</span><span class="p">[</span><span class="nx">K</span><span class="p">]</span><span class="nx">V</span><span class="p">,</span> <span class="nx">K</span> <span class="nx">comparable</span><span class="p">,</span> <span class="nx">V</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">S</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// comparable 是一个内置的约束，表示所有可以使用 == != 运算符的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Then we call it like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nf">SomeComplicatedMethod</span><span class="p">([]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">{})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The type derivation process generated at compile time is as follows, starting with the result of the function parameter type derivation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">S</span> <span class="p">=&gt;</span> <span class="p">[]</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Then using constrained type derivation for S, comparing <code>[]map[string]int</code> and <code>~[]M</code>, we get</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">M</span> <span class="p">=&gt;</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Continuing with the constrained type derivation for M, comparing <code>map[string]int</code> with <code>~map[K]V</code>, we get</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">K</span> <span class="p">=&gt;</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="nx">V</span> <span class="p">=&gt;</span> <span class="kt">int</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The type derivation is now successfully completed.</p>
<h4 id="preserving-type-information-with-constraint-type-inference">Preserving Type Information with Constraint Type Inference</h4>
<p>Another useful aspect of constraint type derivation is that it preserves the type information of the caller&rsquo;s original arguments.</p>
<p>Using the &ldquo;DoubleSlice&rdquo; function from this section as an example, suppose we now implement a more &ldquo;simple&rdquo; version of it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">DoubleSliceSimple</span><span class="p">[</span><span class="nx">E</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Integer</span><span class="p">](</span><span class="nx">slice</span> <span class="p">[]</span><span class="nx">E</span><span class="p">)</span> <span class="p">[]</span><span class="nx">E</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ret</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">E</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">item</span> <span class="o">+</span> <span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">ret</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This version has only one type parameter, E. At this point, we call it as we did before.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MySlice</span> <span class="p">[]</span><span class="kt">int</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">ans</span> <span class="o">:=</span> <span class="nf">DoubleSliceSimple</span><span class="p">(</span><span class="nx">MySlice</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">})</span> <span class="c1">// ans 的类型是 []int !!!
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The type derivation at this point is just the most basic type derivation of the function parameters, where the compiler does a direct structured comparison between MySlice and []E and concludes that the actual type of E is int.</p>
<p>The DoubleSliceSimple function returns []E, which is []int, not MySlice as passed in by the caller, whereas the previous DoubleSlice function, by defining a type parameter S with a structured constraint and using S to match the type of the input directly, and returning a value of type S, preserves The original argument type of the caller is preserved.</p>
<h3 id="limitations-of-using-generics">Limitations of using generics</h3>
<p>There are still a number of limitations to Golang generics, some of the major ones include.</p>
<ol>
<li>member functions cannot use generics</li>
<li>you cannot use a method that is not specified in the constraint definition, even if all the types in the type set implement the method</li>
<li>you cannot use a member variable even if all types in the type set have the member</li>
</ol>
<p>The following are examples of each.</p>
<h4 id="member-functions-cannot-use-generics">member functions cannot use generics</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyStruct</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">MyStruct</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nx">Method</span><span class="p">[</span><span class="nx">T2</span> <span class="nx">any</span><span class="p">](</span><span class="nx">param</span> <span class="nx">T2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 错误：成员函数无法使用泛型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this example, the member function Method of <code>MyStruct[T]</code> defines a function parameter T2 that belongs only to itself, however such an operation is currently not supported by the compiler (and most likely will not be supported in the future).</p>
<h4 id="cannot-use-methods-other-than-those-defined-by-constraints">cannot use methods other than those defined by constraints</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyType1</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">MyType1</span><span class="p">)</span> <span class="nf">Method</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyType2</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">MyType2</span><span class="p">)</span> <span class="nf">Method</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyConstraint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MyType1</span> <span class="p">|</span> <span class="nx">MyType2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">MyFunc</span><span class="p">[</span><span class="nx">T</span> <span class="nx">MyConstraint</span><span class="p">](</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span><span class="p">.</span><span class="nf">Method</span><span class="p">()</span> <span class="c1">// 错误：MyConstraint 不包含 .Method() 方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this example, the two members of the MyConstraint collection, MyType1 and MyType2, cannot be called directly from a generic function, even though they both implement the .Method() function.</p>
<p>If they need to be called, MyConstraint should be rewritten in the following form.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyConstraint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MyType1</span> <span class="p">|</span> <span class="nx">MyType2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Method</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="unable-to-use-member-variables">Unable to use member variables</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyType1</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyType2</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyConstraint</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">MyType1</span> <span class="p">|</span> <span class="nx">MyType2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">MyFunc</span><span class="p">[</span><span class="nx">T</span> <span class="nx">MyConstraint</span><span class="p">](</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">Name</span><span class="p">)</span> <span class="c1">// 错误：MyConstraint 不包含 .Name 成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this example, although MyType1 and MyType2 both contain a Name member and are both of type string, they cannot be used directly in a generic function in any way.</p>
<p>This is because the type constraint itself is an interface, and the definition of an interface can only contain a collection of types, and a list of member functions.</p>
<h2 id="summary">Summary</h2>
<p>Golang 1.18 brings the above three very important new features, among them.</p>
<ol>
<li>workspace mode allows for a smoother workflow for local development.</li>
<li>fuzzy tests can find some corner cases and improve the robustness of the code.</li>
<li>generalization can make the code of some public libraries more elegant, avoiding the old way of having to use reflection for &ldquo;generality&rdquo;, which is not only difficult to write and read, but also increases the runtime overhead, because reflection is dynamic information at runtime, while generalization is static information at compile time.</li>
</ol>
<p>This article also briefly covers these aspects and hopefully gives you a basic understanding of these new things in Golang.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-07/k8s-mutatingwebhook/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">K8s Mutating Webhook</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-07/postgresql-14-continuous-archiving/">
            <span class="next-text nav-default">PostgreSQL14&#39;s Continuous Archive Backup Feature</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
