<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>PostgreSQL14&#39;s Continuous Archive Backup Feature - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Learn how to use the continuous archive backup feature of PostgreSQL14." /><meta name="keywords" content="Postgresql 14, Continuous Archiving" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-07/postgresql-14-continuous-archiving/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="PostgreSQL14&#39;s Continuous Archive Backup Feature" />
<meta property="og:description" content="Learn how to use the continuous archive backup feature of PostgreSQL14." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-07/postgresql-14-continuous-archiving/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-11T09:26:44+08:00" />
<meta property="article:modified_time" content="2022-07-11T09:26:44+08:00" />

<meta itemprop="name" content="PostgreSQL14&#39;s Continuous Archive Backup Feature">
<meta itemprop="description" content="Learn how to use the continuous archive backup feature of PostgreSQL14."><meta itemprop="datePublished" content="2022-07-11T09:26:44+08:00" />
<meta itemprop="dateModified" content="2022-07-11T09:26:44+08:00" />
<meta itemprop="wordCount" content="3746">
<meta itemprop="keywords" content="Postgresql," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="PostgreSQL14&#39;s Continuous Archive Backup Feature"/>
<meta name="twitter:description" content="Learn how to use the continuous archive backup feature of PostgreSQL14."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">PostgreSQL14&#39;s Continuous Archive Backup Feature</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-07-11 09:26:44 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3746 words </span>
          <span class="more-meta"> 18 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#continuous-archival-backups">Continuous Archival Backups</a>
          <ul>
            <li><a href="#enabling-wal-archiving">Enabling WAL archiving</a></li>
            <li><a href="#basic-backup">Basic backup</a></li>
          </ul>
        </li>
        <li><a href="#recovering-from-an-archived-backup">Recovering from an archived backup</a>
          <ul>
            <li><a href="#restore-command">Restore command</a></li>
            <li><a href="#recovery-modes">Recovery modes</a></li>
            <li><a href="#recovery-target">Recovery Target</a></li>
            <li><a href="#recovery-termination">Recovery termination</a></li>
          </ul>
        </li>
        <li><a href="#timeline">Timeline</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="continuous-archival-backups">Continuous Archival Backups</h2>
<p>pg has three basic backup methods.</p>
<ul>
<li>sql dump using <code>pg_dump</code>, which is a logical backup that cannot be restored to a specified state.</li>
<li>File system based backup, requires file system to provide snapshot function to ensure consistency, otherwise <strong>must</strong> be shut down first and then backed up.</li>
<li>Continuous archiving, the preferred high-reliability backup technology.</li>
</ul>
<p>Continuous archiving of WAL logs is the key to implementing archived backups, combining a file system level backup with an archived WAL file, so that when recovery is required, the file system backup is restored first, and then the archived WAL file is replayed to restore the system to its current (or specified point in time) state.</p>
<p>Advantages of continuous archiving.</p>
<ul>
<li>Rather than requiring a fully consistent file system backup, a consistent state is reached by replaying the WAL from a redo point, so a simple tool can be used to make a base backup without stopping the machine.</li>
<li>Simple continuous archiving of WAL files enables continuous backups in situations where full backups are not possible frequently.</li>
<li>Use base backups and WAL archive reversion to specified points in time to restore the database to any point in time after the base backup.</li>
<li>Continuous transfer of WAL archive files to another machine to which the same base backup has been applied enables a master-backup replication system.</li>
</ul>
<p>Disadvantages.</p>
<ul>
<li>Only the entire database set cluster can be restored by backup, no finer granularity is supported.</li>
<li>Base backups and continuous archive files can take up a lot of space.</li>
</ul>
<h3 id="enabling-wal-archiving">Enabling WAL archiving</h3>
<p>pg continuously generates 16M WAL segment files in the <code>pg_wal</code> directory by default. pg will clean up and recycle WAL segment files when archiving mode is not enabled.</p>
<p>The archive process transfers the WAL segment files before the checkpoint from the <code>pg_wal</code> directory to a specified location (e.g., copied to a user-defined directory), and the original WAL segment files are purged or recycled after a successful transfer.</p>
<p>The pg archiving process is highly scalable, as the transfer process executes a shell command provided by the user, and the exact method and target location of the transfer is completely user-defined, with only the return code of the command determining whether the archiving was successful.</p>
<p>Example configuration to enable WAL archiving.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">wal_level</span> <span class="o">=</span> replica <span class="c1"># or higher level</span>
</span></span><span class="line"><span class="cl"><span class="nv">archive_mode</span> <span class="o">=</span> on
</span></span><span class="line"><span class="cl"><span class="nv">archive_command</span> <span class="o">=</span> <span class="s1">&#39;test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are the following notes about the archive command.</p>
<ul>
<li>The archive command should never directly overwrite an archive file with the same name, since different set clusters may produce WAL segment files with the same name, and the archive command should return with a non-zero status code when an archive file already exists at the archive location.</li>
<li>The archive command should preserve the original filename of the WAL segment file.</li>
<li>The archive command should be designed to resolve or handle potential exceptions that could cause the <code>pg_wal</code> directory to grow and cause pg to shut down due to lack of space.</li>
<li>It is necessary to enable the <code>logging_collector</code> parameter so that the standard error output of the archive command will be collected in the database logs for easy debugging and monitoring of the archiving process.</li>
<li>For databases with a small workload, a WAL segment file may not be switched for a long time. Setting a small <code>archive_timeout</code> can shorten the time interval between when a transaction is executed and when it is reliably archived; ` Manually switch the WAL segment file, which also triggers the archiving of the WAL segment file used before the switch, this command can only be executed on the master.</li>
<li>If the command is terminated by a signal other than SIGTERM or a shell error (e.g., command not found), archiving will be aborted and the server will shut down.</li>
</ul>
<h3 id="basic-backup">Basic backup</h3>
<p>A basic backup is a staged operation consisting of several sequential commands.</p>
<ul>
<li>
<p>Execute <code>pg_start_backup</code> to start the backup, the database performs a checkpoint, explicitly creates a re-point at the start moment of the backup, writes as many transactions as possible to disk before this point in time, and records the LSN location of this checkpoint. In order not to interfere with online operation, this command performs the checkpoint by default by spreading out the IO, so it may take a long time to return. <code>pg_start_backup</code> also forces full-page write mode to ensure that writes to the database are fully replayable during the base backup.</p>
</li>
<li>
<p>After <code>pg_start_backup</code> is successfully executed, the user needs to archive the data directory using the file system tool itself to obtain a file system backup, noting that different files may have been copied at different points in time and therefore the state of the database in the file system backup may not be consistent. pg expects this to happen and brings it to a consistent state by replaying the WAL segment files written throughout the base backup to bring them to a consistent state.</p>
</li>
<li>
<p>When <code>pg_stop_backup</code> is executed, the database forcibly switches the WAL segment files in use and records the last LSN before the switch, with the ending LSN being the consistent state actually backed up by this base backup. The WAL segment files written during the base backup are archived, and the end operation sends a <strong>backup history file</strong> with the names of these WAL segment files to the archive location, the file name of which records the first WAL segment file needed to restore using this base backup, and the contents of which record the start and end timestamps of this backup and the required starting and ending WAL segment files. Applying these archived WAL segment files on top of the file system backup will restore to the consistent state represented by the ending LSN.</p>
</li>
<li>
<p>After ending the backup you need to create <strong>manually</strong> a <code>backup_label</code> file in the root directory of the file system backup with the output returned by the <code>pg_stop_backup</code> operation and preferably save the WAL segment files recorded in the backup history file separately, the file system backup plus the WAL segment files written during the backup is a valid base The file system backup plus the WAL segment files written during the backup is a valid base backup that can successfully restore the database to the consistent state it was in when the backup ended.</p>
</li>
</ul>
<p>The details of the <code>pg_start_backup</code> and <code>pg_stop_backup</code> commands can be found below.</p>
<ul>
<li><a href="https://www.2ndquadrant.com/en/blog/what-does-pg_start_backup-do/">what-does-pg_start_backup-do/</a></li>
<li><a href="https://www.postgresql.org/docs/current/functions-admin.html#FUNCTIONS-ADMIN-BACKUP">FUNCTIONS-ADMIN-BACKUP</a></li>
</ul>
<p>After securely archiving file system backups and WAL segment files used during backups (specified in the backup history file), WAL segment files with a numeric sequence in the file name smaller than the backup history file name can be deleted.</p>
<p>Recovery requires a base backup plus ongoing WAL archives created after that base backup, and since replaying a large number of WAL archives is time-consuming, the recommended practice is to do a base backup periodically, while cleaning up older WAL archives before the base backup (after cleaning it is impossible to restore to that point in time).</p>
<h4 id="make-a-base-backup-using-the-underlying-api">Make a base backup using the underlying API</h4>
<ol>
<li>
<p>Make sure the archiving function is enabled and working properly.</p>
</li>
<li>
<p>Connect to the database using the superuser and execute the following command (this connection needs to be maintained during the backup).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">pg_start_backup</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">false</span><span class="p">,</span><span class="w"> </span><span class="k">false</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>The first parameter is a custom descriptive label.</li>
<li>The second parameter represents whether to turn on fast checkpointing, which when turned on will execute fast checkpointing immediately initiating a large number of IOs that may affect database performance during backups. Turning it off will disperse the IOs to reduce the impact on the database, but will take longer to execute.</li>
<li>The third parameter represents whether to enable exclusive backups, which is no longer recommended in newer versions.</li>
</ul>
</li>
<li>
<p>Use any file system backup tool to archive the data directory. This error can be ignored if the backup tool returns with a non-zero status code because the files were changed during the copy. Partial temporary subdirectories, files or files in subdirectories under the data directory (e.g. <code>pg_wal</code>) can be ignored during archiving.</p>
</li>
<li>
<p>Continue with the following command in the same connection.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">pg_stop_backup</span><span class="p">(</span><span class="k">false</span><span class="p">,</span><span class="w"> </span><span class="k">true</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This command will terminate the backup mode and automatically switch the WAL segment files so that the WAL segment files written during the backup can be archived, by default these WAL end files are archived successfully before the command returns, the second field output returned needs to be written to the <code>backup_label</code> file in the root directory of the file system backup, this file needs to be created manually in non-exclusive backup mode.</p>
</li>
<li>
<p>When the end command returns successfully, it means that the WAL segment files written during the backup have been archived and the backup is finished. You can save the file system backup together with these WAL segment files, which form a complete base backup.</p>
</li>
</ol>
<h4 id="making-basic-backups-with-pg_basebackup">Making basic backups with pg_basebackup</h4>
<p><code>pg_basebackup</code> encapsulates the underlying <code>pg_start_backup</code> and <code>pg_stop_backup</code> commands and provides some very convenient features.</p>
<ul>
<li>Supports archiving and compressing file system backups of data directories, automatically ignoring unwanted files, and automatically writing to <code>backup_label</code> files.</li>
<li>Automatically record checksums of backup files to prevent backups from being changed.</li>
<li>Support to automatically fetch all WAL segment archive files generated during backup and save them to <code>pg_wal</code> or other directories.</li>
</ul>
<p>Usage examples.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ pg_basebackup -D /backup/demo -Ft -z -Xs -c fast -P -v
</span></span><span class="line"><span class="cl">pg_basebackup: initiating base backup, waiting <span class="k">for</span> checkpoint to <span class="nb">complete</span>
</span></span><span class="line"><span class="cl">pg_basebackup: checkpoint completed
</span></span><span class="line"><span class="cl">pg_basebackup: write-ahead log start point: 0/75ED8820 on timeline <span class="m">1</span>
</span></span><span class="line"><span class="cl">pg_basebackup: starting background WAL receiver
</span></span><span class="line"><span class="cl">pg_basebackup: created temporary replication slot <span class="s2">&#34;pg_basebackup_15233&#34;</span>
</span></span><span class="line"><span class="cl">244438/244438 kB <span class="o">(</span>100%<span class="o">)</span>, 1/1 tablespace
</span></span><span class="line"><span class="cl">pg_basebackup: write-ahead log end point: 0/859200C8
</span></span><span class="line"><span class="cl">pg_basebackup: waiting <span class="k">for</span> background process to finish streaming ...
</span></span><span class="line"><span class="cl">pg_basebackup: syncing data to disk ...
</span></span><span class="line"><span class="cl">pg_basebackup: renaming backup_manifest.tmp to backup_manifest
</span></span><span class="line"><span class="cl">pg_basebackup: base backup completed
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ls /backup/demo
</span></span><span class="line"><span class="cl">backup_manifest  base.tar.gz  pg_wal.tar.gz
</span></span></code></pre></td></tr></table>
</div>
</div><p>Extract <code>base.tar.gz</code> and <code>pg_wal.tar.gz</code> respectively to get the file system backup and the WAL segment archives written during the backup.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ cat /backup/demo/backup_label
</span></span><span class="line"><span class="cl">START WAL LOCATION: 0/75ED8820 <span class="o">(</span>file 000000010000000000000075<span class="o">)</span>
</span></span><span class="line"><span class="cl">CHECKPOINT LOCATION: 0/763C57B0
</span></span><span class="line"><span class="cl">BACKUP METHOD: streamed
</span></span><span class="line"><span class="cl">BACKUP FROM: primary
</span></span><span class="line"><span class="cl">START TIME: 2022-07-09 15:13:35 UTC
</span></span><span class="line"><span class="cl">LABEL: pg_basebackup base backup
</span></span><span class="line"><span class="cl">START TIMELINE: <span class="m">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ ls -l /backup/demo/pg_wal
</span></span><span class="line"><span class="cl">total <span class="m">278532</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000075</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000076</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000077</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000078</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000079</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 00000001000000000000007A
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 00000001000000000000007B
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 00000001000000000000007C
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 00000001000000000000007D
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 00000001000000000000007E
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 00000001000000000000007F
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000080</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000081</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000082</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000083</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000084</span>
</span></span><span class="line"><span class="cl">-rw------- <span class="m">1</span> postgres postgres <span class="m">16777216</span> Jul  <span class="m">9</span> 15:13 <span class="m">000000010000000000000085</span>
</span></span><span class="line"><span class="cl">drwx------ <span class="m">2</span> postgres postgres     <span class="m">4096</span> Jul  <span class="m">9</span> 15:20 archive_status
</span></span></code></pre></td></tr></table>
</div>
</div><p>The backup_label file in the data directory does not record the LSN location of the end of the base backup, but it can be viewed in the corresponding backup history file in the WAL archive directory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ cat 000000010000000000000075.00ED8820.backup
</span></span><span class="line"><span class="cl">START WAL LOCATION: 0/75ED8820 <span class="o">(</span>file 000000010000000000000075<span class="o">)</span>
</span></span><span class="line"><span class="cl">STOP WAL LOCATION: 0/859200C8 <span class="o">(</span>file 000000010000000000000085<span class="o">)</span>
</span></span><span class="line"><span class="cl">CHECKPOINT LOCATION: 0/763C57B0
</span></span><span class="line"><span class="cl">BACKUP METHOD: streamed
</span></span><span class="line"><span class="cl">BACKUP FROM: primary
</span></span><span class="line"><span class="cl">START TIME: 2022-07-09 15:13:35 UTC
</span></span><span class="line"><span class="cl">LABEL: pg_basebackup base backup
</span></span><span class="line"><span class="cl">START TIMELINE: <span class="m">1</span>
</span></span><span class="line"><span class="cl">STOP TIME: 2022-07-09 15:13:42 UTC
</span></span><span class="line"><span class="cl">STOP TIMELINE: <span class="m">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When recovering with this base backup, the recovery process replayed the <code>0000000100000000000000000085</code> WAL segment file before the database entered a consistent state, after which the database was able to accept connections to perform query operations, as shown in the recovery log below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">2022-07-10 08:05:28.780 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;000000010000000000000084&#34;</span> from archive
</span></span><span class="line"><span class="cl">2022-07-10 08:05:29.024 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;000000010000000000000085&#34;</span> from archive
</span></span><span class="line"><span class="cl">2022-07-10 08:05:29.147 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  consistent recovery state reached at 0/859200C8
</span></span><span class="line"><span class="cl">2022-07-10 08:05:29.148 UTC <span class="o">[</span>21179<span class="o">]</span> LOG:  database system is ready to accept read-only connections
</span></span><span class="line"><span class="cl">2022-07-10 08:05:29.232 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;000000040000000000000086&#34;</span> from archive
</span></span><span class="line"><span class="cl">2022-07-10 08:05:29.480 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;000000040000000000000087&#34;</span> from archive
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="recovering-from-an-archived-backup">Recovering from an archived backup</h2>
<p>To restore, proceed as follows.</p>
<ul>
<li>Stop the pg server process.</li>
<li>Back up the current data directory, or at least the WAL segment files in the <code>pg_wal</code> directory that have not been archived, if there is not enough space.</li>
<li>Remove all files and subdirectories from the data directory.</li>
<li>Restore <strong>file system backup</strong> to the data directory, making sure that the restored files and directories have the correct permissions.</li>
<li>If the <code>pg_wal</code> directory was not ignored when doing the file system backup, you now need to empty the restored <code>pg_wal</code> directory and copy the unarchived WAL segment files to it.</li>
<li>Create a <code>recovery.signal</code> file in the data directory that instructs pg to enter recovery mode at boot and will be automatically deleted after a successful recovery.</li>
<li>Set recovery-related parameters, such as <code>restore_command</code>, in the configuration file <code>postgresql.conf</code>, which is described in detail below.</li>
<li>Start the pg server. The server will enter recovery mode and start fetching and processing the WAL segment files needed for recovery. If the recovery process is terminated due to an external error (e.g. host power failure), you can simply restart the server to let it continue the recovery. When recovery is complete, the server deletes the <code>recovery.signal</code> file to prevent re-entry into recovery mode, and then begins normal operation.</li>
</ul>
<p>The recovery process is not complicated, and the key points are set via the configuration file to.</p>
<ul>
<li>The way to get the archived WAL segment file when recovering.</li>
<li>The target state to be reached for recovery.</li>
</ul>
<h3 id="restore-command">Restore command</h3>
<p>The <code>restore_command</code> (henceforth called the restore command) must be set to tell pg how to get the archived WAL segment file. Similar to the archive command, this command defines how to transfer the specific WAL segment file (which also contains other types of files) that pg needs from the archive location to a temporary location in the data directory in a user-defined way, and then pg will then reads the temporary file and performs a redo. More complex behavior can be customized in this command by executing a script.</p>
<p>If the archived WAL segment files are stored in the <code>/backup/demo/pg_wal</code> directory, the sample recovery command is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">restore_command</span> <span class="o">=</span> <span class="s1">&#39;cp /backup/demo/pg_wal/%f %p&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The recovery command is designed with the following caveats.</p>
<ul>
<li>
<p>The recovery command must return with a non-zero status code if the transfer fails or the transferred file does not exist. pg will try to fetch some files that are not in the archive location with the recovery command, so the recovery will not be aborted directly because the recovery command failed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">2022-07-10 08:05:24.762 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;00000003.history&#34;</span> from archive
</span></span><span class="line"><span class="cl">2022-07-10 08:05:24.766 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;00000004.history&#34;</span> from archive
</span></span><span class="line"><span class="cl">cp: cannot stat <span class="s1">&#39;/var/lib/postgresql/archive/14/demo/00000005.history&#39;</span>: No such file or directory
</span></span><span class="line"><span class="cl">2022-07-10 08:05:24.771 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  starting point-in-time recovery to 2022-07-10 08:03:23.157122+00
</span></span><span class="line"><span class="cl">2022-07-10 08:05:24.776 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;00000004.history&#34;</span> from archive
</span></span><span class="line"><span class="cl">2022-07-10 08:05:24.862 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;000000010000000000000076&#34;</span> from archive
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>If pg cannot fetch a file with the recovery command, it will later try to find it from the <code>pg_wal</code> directory in the data directory.</p>
</li>
<li>
<p>If the command is terminated by a signal other than SIGTERM or a shell error (e.g., command not found), recovery will be aborted and the server will shut down.</p>
</li>
</ul>
<h3 id="recovery-modes">Recovery modes</h3>
<p>Recovery actually works in two modes.</p>
<ul>
<li>Create a file named <code>standby.signal</code> in the data directory, which will enter standby mode when the server starts. The server enters the recovery state and does not stop recovering when it reaches the end of the archived WAL, but continues to try to recover by connecting to the primary server specified by the <code>primary_conninfo</code> setting or by using the <code>restore_command</code> to get a new WAL segment.</li>
<li>Create a file called <code>recovery.signal</code> in the data directory that will enter the target recovery mode when the server starts. Target recovery mode ends when the archived WAL segment file is fully replayed or when <code>recovery_target</code> is reached.</li>
</ul>
<p>Typically, standby mode is used to provide high availability and extend read-only libraries, while target recovery is used to recover lost data or clone a new server. If both <code>standby.signal</code> and <code>recovery.signal</code> files are created, the standby mode takes precedence.</p>
<h3 id="recovery-target">Recovery Target</h3>
<p>By default, recovery mode processes all available WAL segment files, i.e., it increments the sequence number in the WAL segment naming to get the next WAL segment file until it fails, and finally restores the database to a &ldquo;relatively up-to-date&rdquo; state. So it is usually normal to see a &ldquo;file not found&rdquo; error during the recovery process, especially at the end of the recovery.</p>
<p>If you only need to restore to a point in time between the end of the base backup and the current moment, you need to specify the <strong>stopping point</strong>, the recovery target. The recovery target can be a timestamp, a named recovery point and a transaction ID, in practice point-in-time based recovery is used mostly.</p>
<p>We can specify a recovery target by choosing one of the following parameters and only one of the following.</p>
<ul>
<li><code>recovery_target</code>: the only available value is <code>immediate</code>, which stops recovery when it reaches a consistent state at the end of the base backup.</li>
<li><code>recovery_target_lsn</code>: Set the recovery target to the specified LSN.</li>
<li><code>recovery_target_name</code>: set the recovery target to the specified named recovery point (created by <code>pg_create_restore_point()</code>).</li>
<li><code>recovery_target_time</code>: set the recovery target to the specified timestamp.</li>
<li><code>recovery_target_xid</code>: sets the recovery target to the specified transaction ID.</li>
</ul>
<p>Further set whether to include the recovery target and the behavior upon arrival with the following options.</p>
<ul>
<li><code>recovery_target_inclusive</code>: Specifies whether the recovery target is included on recovery, i.e. whether to replay WAL log entries that contain a target timestamp, LSN, or transaction ID, otherwise it will stop before that recovery target. The default value is <code>true</code>.</li>
<li><code>recovery_target_timeline</code>: Specifies the timeline reached during recovery, usually using the default value <code>latest</code>, which is the last generated timeline in the archive log.</li>
<li><code>recovery_target_action</code>: specifies the action that the server will perform when the recovery target is reached, which only takes effect when the recovery target is set. The following three actions can be executed.
<ul>
<li><code>pause</code>: Suspends the recovery process. When paused, the user can perform the next action based on the current status queried from the database. You can choose to resume the paused recovery process, which will cause the recovery mode to end, or you can choose to restart the database server after changing the recovery target configuration and revert to another target. This option is equivalent to <code>shutdown</code> if the server is unable to accept queries due to the <code>hot_standby=off</code> configuration.</li>
<li><code>promot</code>: Ends the recovery process and creates a new timeline to start accepting database connections.</li>
<li><code>shutdown</code>: Shut down the server directly. This does not delete the <code>recovery.signal</code> file and will immediately shut down again if the server is restarted; if it is restarted after changing the recovery target configuration, it will enter recovery mode and continue redirecting to a new recovery target from the previous recovery target.</li>
</ul>
</li>
</ul>
<h3 id="recovery-termination">Recovery termination</h3>
<p>In any case, if the recovery process ends due to running out of available WAL segment files before reaching the configured recovery target, the recovery process will exit with a FATAL error causing the server to shut down.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">2022-07-10 08:05:50.673 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;0000000400000000000000D1&#34;</span> from archive
</span></span><span class="line"><span class="cl">2022-07-10 08:05:50.865 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  restored log file <span class="s2">&#34;0000000400000000000000D2&#34;</span> from archive
</span></span><span class="line"><span class="cl">cp: cannot stat <span class="s1">&#39;/var/lib/postgresql/archive/14/demo/0000000400000000000000D3&#39;</span>: No such file or directory
</span></span><span class="line"><span class="cl">2022-07-10 08:05:51.003 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  redo <span class="k">done</span> at 0/D2CA8530 system usage: CPU: user: 5.91 s, system: 9.59 s, elapsed: 25.94 s
</span></span><span class="line"><span class="cl">2022-07-10 08:05:51.003 UTC <span class="o">[</span>21181<span class="o">]</span> LOG:  last completed transaction was at log <span class="nb">time</span> 2022-07-10 08:02:30.614229+00
</span></span><span class="line"><span class="cl">2022-07-10 08:05:51.003 UTC <span class="o">[</span>21181<span class="o">]</span> FATAL:  recovery ended before configured recovery target was reached
</span></span><span class="line"><span class="cl">2022-07-10 08:05:51.015 UTC <span class="o">[</span>21179<span class="o">]</span> LOG:  startup process <span class="o">(</span>PID 21181<span class="o">)</span> exited with <span class="nb">exit</span> code <span class="m">1</span>
</span></span><span class="line"><span class="cl">2022-07-10 08:05:51.015 UTC <span class="o">[</span>21179<span class="o">]</span> LOG:  terminating any other active server processes
</span></span><span class="line"><span class="cl">2022-07-10 08:05:51.026 UTC <span class="o">[</span>21179<span class="o">]</span> LOG:  shutting down due to startup process failure
</span></span><span class="line"><span class="cl">2022-07-10 08:05:51.047 UTC <span class="o">[</span>21179<span class="o">]</span> LOG:  database system is shut down
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the recovery process finds corrupt WAL data, recovery will stop immediately and the server will not start normally. In this case a new recovery target can be specified before the point of corruption and then the recovery process can be rerun.</p>
<p>If the recovery fails for external reasons, such as a system crash or inaccessible WAL archives, the recovery can be continued by simply restarting the server and the recovery process will start over from where it failed. Recovery restarts work much like normal checkpoints: the server periodically flushes all its state to disk, then updates the <code>pg_control</code> file with the completed WAL data at the record, which no longer needs to be reprocessed at restart.</p>
<h2 id="timeline">Timeline</h2>
<p>The concept of timeline is introduced in pg. A new timeline is created after each successful recovery based on the recovered timeline, which is mainly reflected in the naming of WAL segment files.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># SELECT timeline_id FROM pg_control_checkpoint();</span>
</span></span><span class="line"><span class="cl"> timeline_id
</span></span><span class="line"><span class="cl">-------------
</span></span><span class="line"><span class="cl">           <span class="m">2</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span><span class="m">1</span> row<span class="o">)</span>
</span></span><span class="line"><span class="cl"><span class="nv">postgres</span><span class="o">=</span><span class="c1"># SELECT pg_walfile_name(pg_current_wal_lsn());</span>
</span></span><span class="line"><span class="cl">     pg_walfile_name
</span></span><span class="line"><span class="cl">--------------------------
</span></span><span class="line"><span class="cl"> <span class="m">000000020000000000000086</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span><span class="m">1</span> row<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Each time a new timeline is created pg also creates a timeline history file <code>&lt;timeline-ID&gt;.history</code>, which records the parent timeline of that timeline. When restoring from an archive containing multiple timelines, pg needs the timeline history file to keep going back and selecting the correct sequence of WAL segment files. Therefore the timeline history file is also archived to the WAL archive location.</p>
<p>The advantage of introducing a timeline is that users can restore based on the same backup and then back up again, simulating a tree backup history through the timeline, and then easily locate and switch between forks without worrying about confusion between them due to naming conflicts, etc. The timeline is very useful in some scenarios, and usually we use the most recent timeline in the WAL archive directly.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/postgresql/">Postgresql</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-07/go-1-8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go 1.18 things - workspace, fuzzy tests, generics</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-07/rust-async/">
            <span class="next-text nav-default">Hello Rust async/await</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
