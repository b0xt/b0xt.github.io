<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>How to optimize docker image size - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore how to optimize docker image size." /><meta name="keywords" content="docker image size, optimize" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-07/docker-image/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="How to optimize docker image size" />
<meta property="og:description" content="Explore how to optimize docker image size." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-07/docker-image/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-07-17T12:06:47+08:00" />
<meta property="article:modified_time" content="2022-07-17T12:06:47+08:00" />

<meta itemprop="name" content="How to optimize docker image size">
<meta itemprop="description" content="Explore how to optimize docker image size."><meta itemprop="datePublished" content="2022-07-17T12:06:47+08:00" />
<meta itemprop="dateModified" content="2022-07-17T12:06:47+08:00" />
<meta itemprop="wordCount" content="1757">
<meta itemprop="keywords" content="docker," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="How to optimize docker image size"/>
<meta name="twitter:description" content="Explore how to optimize docker image size."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">How to optimize docker image size</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-07-17 12:06:47 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1757 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#theory-and-rationale">Theory and Rationale</a></li>
        <li><a href="#profiling-tools">Profiling Tools</a>
          <ul>
            <li><a href="#docker-history">docker history</a></li>
            <li><a href="#dive">dive</a></li>
          </ul>
        </li>
        <li><a href="#optimization-tips">Optimization Tips</a>
          <ul>
            <li><a href="#multi-stage-builds-and-build-from-scratch">Multi-stage builds and build from scratch</a></li>
            <li><a href="#avoid-creating-useless-documents-or-caches">Avoid creating useless documents or caches</a></li>
            <li><a href="#clean-up-unneeded-files-in-a-timely-manner">Clean up unneeded files in a timely manner</a></li>
            <li><a href="#merging-multiple-image-layers">Merging multiple image layers</a></li>
            <li><a href="#modifying-meta-information-while-copying-files">Modifying meta information while copying files</a></li>
          </ul>
        </li>
        <li><a href="#reference-links">Reference Links</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Recently, after taking over a new project, I streamlined the original 1.6GB image to over 600MB.</p>
<p>This article documents some of the lessons learned during the optimization process.</p>
<h2 id="theory-and-rationale">Theory and Rationale</h2>
<p>Image is essentially a compressed package consisting of a image layer and a runtime configuration file. Building a image is the process of generating a image layer and a configuration file by running the <code>RUN</code>, <code>COPY</code> and <code>ADD</code> commands in Dockerfile.</p>
<p>Key points related to image size.</p>
<ul>
<li>The <code>RUN</code>, <code>COPY</code>, and <code>ADD</code> commands create a new image layer on top of the existing image layer, and all file system changes resulting from executing the commands are committed as a image layer as a whole at the end of the command.</li>
<li>The image layer has the <code>copy-on-write</code> feature, so if you go to update an existing file in another image layer, it will be copied to the new image layer first and then modified, resulting in double the file space occupied.</li>
<li>If you delete a file in another image layer, it will only generate a delete mark for that file in the current image layer, and will not reduce the actual size of the whole image.</li>
</ul>
<p>The above theory can be verified by the following Dockerfile.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> alpine:latest</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> resource.tar /<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> touch /resource.tar<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> rm -f /resource.tar<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&#34;/bin/ash&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>We simply add, modify and delete a resource file in Dockerfile and then build the image to see its image layer information.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker build -t test-image -f Dockerfile .
</span></span><span class="line"><span class="cl">$ docker <span class="nb">history</span> test-image:latest
</span></span><span class="line"><span class="cl">IMAGE          CREATED              CREATED BY                                      SIZE      COMMENT
</span></span><span class="line"><span class="cl">95f1695b2904   About a minute ago   /bin/sh -c <span class="c1">#(nop)  ENTRYPOINT [&#34;/bin/ash&#34;]      0B</span>
</span></span><span class="line"><span class="cl">1780448c656f   About a minute ago   /bin/sh -c rm -f /resource.tar                  0B
</span></span><span class="line"><span class="cl">a85d29bf7738   About a minute ago   /bin/sh -c touch /resource.tar                  135MB
</span></span><span class="line"><span class="cl">6dac335fa653   <span class="m">4</span> minutes ago        /bin/sh -c <span class="c1">#(nop) COPY file:66065d6e23e0bc52…   135MB</span>
</span></span><span class="line"><span class="cl">e66264b98777   <span class="m">7</span> weeks ago          /bin/sh -c <span class="c1">#(nop)  CMD [&#34;/bin/sh&#34;]              0B</span>
</span></span><span class="line"><span class="cl">&lt;missing&gt;      <span class="m">7</span> weeks ago          /bin/sh -c <span class="c1">#(nop) ADD file:8e81116368669ed3d…   5.53MB</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the output of <code>docker history</code> you can see that.</p>
<ul>
<li>The <code>RUN touch /resource.tar</code> command only modifies the file&rsquo;s meta information, but still copies the entire file to the new image layer.</li>
<li>The <code>RUN rm -f /resource.tar</code> command removes the file and makes it invisible when running the container, but it is still present in the first two image layers and in the final image.</li>
</ul>
<h2 id="profiling-tools">Profiling Tools</h2>
<p>When tuning code for performance, the first step is to find the performance bottleneck of the code with the help of Profiling tools, and the same is true for optimizing the image volume. Here are two tools that can analyze the image size.</p>
<h3 id="docker-history">docker history</h3>
<p>docker comes with the <code>docker history</code> command, which shows more basic information such as creation time, instructions, and volume for all image layers, but is somewhat lackluster for complex images. See the example above for how to use it.</p>
<h3 id="dive">dive</h3>
<p>The third-party <code>dive</code> tool, which analyzes the image layer composition and lists the files contained in each image layer, makes it easy to locate the build instructions and specific files that affect the image volume.</p>
<p>Take the <code>golang:1.16</code> image as an example, first <a href="https://github.com/wagoodman/dive#installation">install dive</a>, then execute <code>dive golang:1.16</code>, the output is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/07/17/c3e550d77b3846d49e3aa1cc2932273f.png" alt="dive"></p>
<p>As shown above, after selecting the image layer on the left, you can clearly see the specific files in that layer in the file tree view on the right and can filter the files that have been added, updated or deleted compared to the previous layer. In the selected image layer, 150MB of dependency files have been added to the <code>/usr/lib</code> directory as a result of the <code>apt-get</code> installation of compiled dependencies.</p>
<h2 id="optimization-tips">Optimization Tips</h2>
<p>Here are some optimization tips that are more effective.</p>
<h3 id="multi-stage-builds-and-build-from-scratch">Multi-stage builds and build from scratch</h3>
<p>The <strong>multi-stage builds</strong> and <strong>build from scratch</strong> are basic tools and essential techniques for optimizing image size.</p>
<p>This approach separates the image building process into a build and a runtime environment, where the build environment installs dependencies such as compilers and compiles the required binary packages, and then copies them to a runtime environment that contains only the necessary runtime dependencies. This technique is particularly effective for languages like golang, which can compile static binaries, and we can run the compiled binaries in a <code>scratch</code> image (<code>scratch</code> is a special empty image).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> golang</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> hell0.go .<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span>
</span></span><span class="line"><span class="cl"><span class="k">RUN</span> go build hello.go<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> scratch</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span><span class="m">0</span> /go/hello .<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;./hello&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If you use a golang image directly as a runtime environment, the image size is usually close to 1 G, and most of the files are not necessary to run the container. After copying the compilation results to the runtime environment, the size varies from a few tens of kb to mb. If you need to keep the basic system tools in the runtime container, consider using the alpine image as the runtime environment.</p>
<h3 id="avoid-creating-useless-documents-or-caches">Avoid creating useless documents or caches</h3>
<p>A docker image should not contain documentation, caches, etc. that are not useful for running containers.</p>
<ol>
<li>
<p>Avoid keeping the installation cache locally</p>
<p>Most package managers cache downloaded resources at install time for later use. pip, for example, stores downloaded responses and build intermediate files in the <code>~/.cache/pip</code> directory, and should disable the default caching behavior with the <code>-no-cache-dir</code> option.</p>
</li>
<li>
<p>Avoid installing documentation</p>
<p>Some package managers offer the option to not install the included documentation, such as dnf with the <code>-nodocs</code> option.</p>
</li>
<li>
<p>Avoid caching package indexes.</p>
<p>Some package managers try to query all enabled repositories for package lists, versions, and other meta-information to cache locally as an index before performing an install. The index cache of individual repositories can reach 150 M or more. We should only query the index when installing a package and clear it after the installation is complete. You should not run commands like <code>yum makecache</code> in a separate command that caches the index.</p>
</li>
</ol>
<h3 id="clean-up-unneeded-files-in-a-timely-manner">Clean up unneeded files in a timely manner</h3>
<p>Files that are not needed when running a container must be cleaned up at the same level they are created, otherwise they will remain in the final image.</p>
<p>Installing packages via package management usually creates a large number of cache files, be sure to clean them up immediately at the end of the same <code>RUN</code> command. This can save a lot of cache space when installing a large number of dependencies.</p>
<p>Take <code>dnf</code> as an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">RUN</span> dnf install -y --nodocs &lt;PACKAGES&gt; <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> dnf clean all <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> rm -rf /var/cache/dnf<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Take <code>apt</code> as an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">RUN apt-get update <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> apt-get install -y &lt;PACKAGES&gt; <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/*
</span></span><span class="line"><span class="cl"><span class="c1"># The official ubuntu/debian image apt-get will automatically execute the clean command after installation</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="merging-multiple-image-layers">Merging multiple image layers</h3>
<p>As explained above, you should avoid updating files in different image layers and creating additional volume footprint. When building with many layers and complex execution instructions, it is difficult to avoid updating files in different image layers, and this extra volume can be streamlined by the following means.</p>
<ol>
<li>
<p>Merging all image layers into one layer when the image is finally generated is done with <code>-squash</code> in the <code>docker build</code> command (requires <a href="https://docs.docker.com/engine/reference/commandline/dockerd/#description">enabling experimental features of the docker daemon</a>).</p>
<p>As an example, take the Dockerfile at the beginning of this article.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker build -t squash-image --squash -f Dockerfile . 
</span></span><span class="line"><span class="cl">$ docker <span class="nb">history</span> squash-image
</span></span><span class="line"><span class="cl">IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT
</span></span><span class="line"><span class="cl">55ded8881d63   <span class="m">9</span> hours ago                                                    0B        merge sha256:95f1695b29044522250de1b0c1904aaf8670b991ec1064d086c0c15865051d5d to sha256:e66264b98777e12192600bf9b4d663655c98a090072e1bab49e233d7531d1294
</span></span><span class="line"><span class="cl">&lt;missing&gt;      <span class="m">11</span> hours ago   /bin/sh -c <span class="c1">#(nop)  ENTRYPOINT [&#34;/bin/ash&#34;]      0B</span>
</span></span><span class="line"><span class="cl">&lt;missing&gt;      <span class="m">11</span> hours ago   /bin/sh -c rm -f /resource.tar                  0B
</span></span><span class="line"><span class="cl">&lt;missing&gt;      <span class="m">11</span> hours ago   /bin/sh -c touch /resource.tar                  0B
</span></span><span class="line"><span class="cl">&lt;missing&gt;      <span class="m">11</span> hours ago   /bin/sh -c <span class="c1">#(nop) COPY file:66065d6e23e0bc52…   0B</span>
</span></span><span class="line"><span class="cl">&lt;missing&gt;      <span class="m">7</span> weeks ago    /bin/sh -c <span class="c1">#(nop)  CMD [&#34;/bin/sh&#34;]              0B</span>
</span></span><span class="line"><span class="cl">&lt;missing&gt;      <span class="m">7</span> weeks ago    /bin/sh -c <span class="c1">#(nop) ADD file:8e81116368669ed3d…   5.53MB</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The final generated image has only one image layer, including the last actual file system, which is equivalent to disabling the <code>copy-on-write</code> feature in the process of merging all image layers.</p>
<p>The disadvantage of this approach is that images can reuse image layers when saving and distributing, pushing images over existing image layers in image repositories and pulling images over locally pulled image layers, but this advantage is lost when merging into one layer.</p>
<p>For scenarios where the image layer may be shared with others, the following approach can be taken.</p>
</li>
<li>
<p>Phased build, part of the intermediate image layer compressed into a layer as the base image. Within a development team, we often add or update some of the dependencies on top of the official image, and then use it as the base image for the team&rsquo;s internal use, which can greatly reduce the actual size of the occupied image. Further, we can compress such base images into one layer. The following is an example of the official golang image.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> golang:1.16 as base</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> scratch</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>base / /<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&#34;/bin/bash&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>After compressing into one layer, the image size of <code>golang:1.16</code> has been changed from 919MB to 913MB. The official image has been optimized a lot so the space saving is very limited, but for the base image made by the development team internally, this optimization often brings unexpected surprises.</p>
</li>
</ol>
<h3 id="modifying-meta-information-while-copying-files">Modifying meta information while copying files</h3>
<p>It is common in Dockerfile to first add an executable to the image and then modify the execute permissions and user of the file.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile"><span class="line"><span class="cl"><span class="k">COPY</span> output/hello /usr/bin/hello<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> chmod +x /usr/bin/hello <span class="o">&amp;&amp;</span> chown normal:normal /usr/bin/hello<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>However, since modifying the file meta information also copies the file to a new image layer, the above command produces two copies of the same file. This can significantly increase the size of the entire image when the file size is large. In fact, it is possible to modify the meta information of a file while copying it. Both the <code>COPY</code> and <code>ADD</code> commands provide the <code>-chmod</code> and <code>-chown</code> options for modifying the meta information.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">COPY --chmod<span class="o">=</span><span class="m">755</span> --chown<span class="o">=</span>normal:normal output/hello /usr/bin/hello
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>-chmod</code> feature has not been added to the official documentation yet, you need to <a href="https://docs.docker.com/develop/develop-images/build_enhancements/">enable docker&rsquo;s buildkit feature</a> before using it (add <code>DOCKER_BUILDKIT=1</code> before the <code>docker build</code> command with <code>DOCKER_BUILDKIT=1</code>), currently only <code>--chmod=755</code> and <code>--chmod=0755</code> are supported, not <code>--chmod=+x</code>.</p>
<h2 id="reference-links">Reference Links</h2>
<ul>
<li><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices for writing Dockerfiles | Docker Documentation</a></li>
<li><a href="https://www.redhat.com/sysadmin/tiny-containers">How to build tiny container images | Enable Sysadmin</a></li>
<li><a href="https://blog.vamc19.dev/posts/dockerfile-copy-chmod/">COPY &ndash;chmod reduced the size of my container image by 35%</a></li>
<li><a href="https://www.ardanlabs.com/blog/2020/02/docker-images-part1-reducing-image-size.html">Docker Images : Part I - Reducing Image Size</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/docker/">docker</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-07/atuh-abac-rbac/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Permission model (RBAC/ABAC)</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-07/go-setup-and-teardown/">
            <span class="next-text nav-default">Using Setup and Teardown in Golang&#39;s Tests</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
