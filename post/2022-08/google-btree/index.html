<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Google B-Tree  - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="google/btree is a pure in-memory B-Tree implementation written in Go, and its source code is analyzed in this paper." /><meta name="keywords" content="Google btree" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/google-btree/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Google B-Tree " />
<meta property="og:description" content="google/btree is a pure in-memory B-Tree implementation written in Go, and its source code is analyzed in this paper." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/google-btree/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-14T11:24:05+08:00" />
<meta property="article:modified_time" content="2022-08-14T11:24:05+08:00" />

<meta itemprop="name" content="Google B-Tree ">
<meta itemprop="description" content="google/btree is a pure in-memory B-Tree implementation written in Go, and its source code is analyzed in this paper."><meta itemprop="datePublished" content="2022-08-14T11:24:05+08:00" />
<meta itemprop="dateModified" content="2022-08-14T11:24:05+08:00" />
<meta itemprop="wordCount" content="2738">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Google B-Tree "/>
<meta name="twitter:description" content="google/btree is a pure in-memory B-Tree implementation written in Go, and its source code is analyzed in this paper."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Google B-Tree </h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-14 11:24:05 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2738 words </span>
          <span class="more-meta"> 13 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#overview">Overview</a>
          <ul>
            <li><a href="#b-tree-structure">B-Tree structure</a></li>
            <li><a href="#api">API</a></li>
            <li><a href="#strict-weak-ordering">Strict Weak Ordering</a></li>
          </ul>
        </li>
        <li><a href="#data-structure">Data structure</a>
          <ul>
            <li><a href="#copyonwritecontext">copyOnWriteContext</a></li>
          </ul>
        </li>
        <li><a href="#external-interfaces-and-applications">External Interfaces and Applications</a>
          <ul>
            <li><a href="#replaceorinsert">ReplaceOrInsert</a></li>
            <li><a href="#delete">Delete</a></li>
            <li><a href="#iterate">Iterate</a></li>
            <li><a href="#application">Application</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>B-Tree and its variants data structures are widely used in storage systems, database systems, mainly as indexes for dynamic random access data scenarios. <em><a href="https://github.com/google/btree">google/btree (github.com)</a></em> is a pure in-memory B-Tree implementation written in Go, and its source code is analyzed in this paper.</p>
<h2 id="overview">Overview</h2>
<h3 id="b-tree-structure">B-Tree structure</h3>
<p><em><a href="https://dl.acm.org/doi/10.1145/1734663.1734671">Organization and maintenance of large ordered indices</a></em> This paper presents the B-Tree data structure. The query of B-Tree starts from the root node and performs a dichotomous lookup of the ordered data within the node and ends the query if it hits, otherwise it goes to the child node query up to the leaf node.</p>
<p>The characteristic of B-Tree query is that the search may end at a non-leaf node. As a typical tree structure, it contains the following node types.</p>
<ul>
<li>Root Node: A B-Tree has only one root node, which is located at the top of the tree.</li>
<li>Branch Node: contains data items and pointers to child nodes.</li>
<li>Leaf Node: stores only data items.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/14/35e9eced0f8c46a0aeaca35bca46511d.png" alt="B-Tree"></p>
<p>The structure of a B-Tree is shown in the figure above. A non-empty B-Tree with height h and minimum degree k has the following properties.</p>
<ol>
<li>the length from the root to the leaf nodes is h.</li>
<li>root and leaf nodes can contain [1, 2k] data, and the number of children of root and branch nodes is the number of data in that node + 1.</li>
<li>all nodes except root and leaf nodes have at least k data and at most 2k data.</li>
<li>all nodes except root and leaf nodes have at least k+1 child nodes and at most 2k+1 child nodes.</li>
</ol>
<h3 id="api">API</h3>
<p>btree provides the basic CRUD APIs. The comments describe the functionality of these interfaces in detail, and you can Google many articles about the use of btree. Therefore, only a few key APIs are listed to facilitate understanding of the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">BTree</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="nx">Item</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">BTree</span><span class="p">)</span> <span class="nf">ReplaceOrInsert</span><span class="p">(</span><span class="nx">item</span> <span class="nx">Item</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">BTree</span><span class="p">)</span> <span class="nf">Delete</span><span class="p">(</span><span class="nx">item</span> <span class="nx">Item</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">BTree</span><span class="p">)</span> <span class="nf">Has</span><span class="p">(</span><span class="nx">key</span> <span class="nx">Item</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">BTree</span><span class="p">)</span> <span class="nf">Clear</span><span class="p">(</span><span class="nx">addNodesToFreelist</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">BTree</span><span class="p">)</span> <span class="nf">Clone</span><span class="p">()</span> <span class="p">(</span><span class="nx">t2</span> <span class="o">*</span><span class="nx">BTree</span><span class="p">)</span> <span class="p">{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>Item</code> interface needs to be implemented before data can be inserted into the btree, and this interface contains only one Less method, which is used to sort all the data in the btree in increasing order.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Item</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">Less</span><span class="p">(</span><span class="nx">than</span> <span class="nx">Item</span><span class="p">)</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Passing values through the interface is a layer of abstraction for data compatibility across data types, rather than serializing data into byte slice for storage. The disadvantage is that type assertions and conversions are required each time the value is read, but usually the API is wrapped in a layer so that the caller does not have to pay attention to this content.</p>
<h3 id="strict-weak-ordering">Strict Weak Ordering</h3>
<p>An important concept in btree is Strict Weak Ordering: i.e. if <code>! (a&lt;b) &amp;&amp; ! (b&lt;a)</code>, then a and b are considered to be equal. Here, <strong>equivalence does not mean that a and b are the same object entity or that their values are identical, but rather that a and b are equal if they satisfy the expression <code>! (a&lt;b) &amp;&amp; ! (b&lt;a)</code> can be considered as <code>a == b</code></strong>.</p>
<p>For example, in the following code example, the <code>foo</code> structure has three internal fields and implements the Less method, which can be considered a less-than <code>&lt;</code> operator. a and b are both its two entity objects, and the structure does not manually implement the <code>==</code> operator. Although they have different variable values and memory addresses, they satisfy the condition <code>! (a&lt;b) &amp;&amp; ! (b&lt;a)</code>, then a and b can be considered equal.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">foo</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">key</span>   <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">  <span class="nx">value</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">  <span class="nx">name</span>  <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span><span class="nx">foo</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">foo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">i</span><span class="p">.</span><span class="nx">key</span> <span class="p">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">a</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">foo</span><span class="p">{</span><span class="nx">key</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="mi">456</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="s">&#34;test1&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">b</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">foo</span><span class="p">{</span><span class="nx">key</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="mi">789</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="s">&#34;test2&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">b</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nb">println</span><span class="p">(</span><span class="s">&#34;a == b&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Specifically in the query method implementation of the btree, a dichotomous lookup is used to find <strong>the first</strong> value that satisfies the <code>(item &lt; s[i])</code> condition. This means that <code>(item &lt; s[i-1])</code> is not valid (the value is false), and then <code>(s[i-1] &lt; item)</code> is judged again, and if it is not valid either, then item is considered equal to s[i-1].</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// &#39;found&#39; is true if the item already exists in the list at the given index.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="nx">items</span><span class="p">)</span> <span class="nf">find</span><span class="p">(</span><span class="nx">item</span> <span class="nx">Item</span><span class="p">)</span> <span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">i</span> <span class="o">:=</span> <span class="nx">sort</span><span class="p">.</span><span class="nf">Search</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">  <span class="p">})</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">Less</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">i</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="data-structure">Data structure</h2>
<p>The data structure of btree is relatively clear, containing the minimum degree <code>degree</code> of the B-Tree, the number of data entries stored <code>length</code>, and the root node <code>root</code>. Each node contains its own child nodes and data entries.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Write operations are not safe for concurrent mutation by multiple goroutines, but Read operations are.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">BTree</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">degree</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">  <span class="nx">length</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">  <span class="nx">root</span>   <span class="o">*</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl">  <span class="nx">cow</span>    <span class="o">*</span><span class="nx">copyOnWriteContext</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">items</span>    <span class="nx">items</span>
</span></span><span class="line"><span class="cl">  <span class="nx">children</span> <span class="nx">children</span>
</span></span><span class="line"><span class="cl">  <span class="nx">cow</span>      <span class="o">*</span><span class="nx">copyOnWriteContext</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">children</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>btree does not distinguish between different types of nodes, they are uniformly represented as node to reuse the code for node operations. If the node is a leaf node, then its <code>children</code> field is empty.</p>
<h3 id="copyonwritecontext">copyOnWriteContext</h3>
<p>copyOnWriteContext is a structure held by every node in the btree, and as you can see from the name, it is a copy-on-write related content. Since btree is a pure memory implementation, when we copy the original btree using the <code>Clone()</code> method provided internally, the new tree and the old tree will share the same memory space using the copy-on-write technique, thus saving memory overhead and the time needed to copy the data. Only when a node is to be written to is a new node actually created.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/14/d5075b0546374dcd8d29a0dbbb642b52.png" alt="copyOnWriteContext"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">copyOnWriteContext</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">freelist</span> <span class="o">*</span><span class="nx">FreeList</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">FreeList</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">mu</span>       <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">   <span class="nx">freelist</span> <span class="p">[]</span><span class="o">*</span><span class="nx">node</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>The Redis RDB persistence also uses COW technology, where the Redis master process forks out the child processes for data backup, and the parent process continues to provide services to the outside world. The child and parent processes only have different virtual spaces, but the corresponding physical spaces are the same, which is similar to the <code>Clone()</code> method. The difference is that btree&rsquo;s copy-on-write directly shares the virtual memory address.</p>
</blockquote>
<p>Taken as a whole, copyOnWriteContext has two roles.</p>
<ul>
<li>
<p>Mark whether btree has write access to the current node, if not, a new node needs to be created and replace the current node before a write operation can be performed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">mutableFor</span><span class="p">(</span><span class="nx">cow</span> <span class="o">*</span><span class="nx">copyOnWriteContext</span><span class="p">)</span> <span class="o">*</span><span class="nx">node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">cow</span> <span class="o">==</span> <span class="nx">cow</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">out</span> <span class="o">:=</span> <span class="nx">cow</span><span class="p">.</span><span class="nf">newNode</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// copy node to out code is omitted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">return</span> <span class="nx">out</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">copyOnWriteContext</span><span class="p">)</span> <span class="nf">newNode</span><span class="p">()</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">n</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">newNode</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">n</span><span class="p">.</span><span class="nx">cow</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>mutableFor</code> method of the node demonstrates this process. If the cow of the current node is the same as the cow of the btree, then the current node is returned directly, otherwise a new node is created and the value of the current node is copied to the new node.</p>
</li>
<li>
<p>Encapsulates the reusable node node list <code>freelist</code>, which is put into the recycle list when a node is destroyed, and can be directly retrieved for reuse when a new node is created, reducing the frequency of node memory requests.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">FreeList</span><span class="p">)</span> <span class="nf">newNode</span><span class="p">()</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">index</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">freelist</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">index</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">n</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">freelist</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">.</span><span class="nx">freelist</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">.</span><span class="nx">freelist</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nx">freelist</span><span class="p">[:</span><span class="nx">index</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">f</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>copyOnWriteContext is an important means for btree to optimize memory overhead, reducing the frequency of memory requests and destruction from both reuse/shared memory perspectives, and using copy-on-write to share the same data in high-volume data replication scenarios.</p>
<h2 id="external-interfaces-and-applications">External Interfaces and Applications</h2>
<h3 id="replaceorinsert">ReplaceOrInsert</h3>
<p>ReplaceOrInsert inserts a new piece of data into the btree, replacing the old value with the new one if it already exists. The implementation of this interface removes the boundary condition handling and essentially calls the internal <code>insert</code> method to insert the data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">BTree</span><span class="p">)</span> <span class="nf">ReplaceOrInsert</span><span class="p">(</span><span class="nx">item</span> <span class="nx">Item</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">out</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nf">maxItems</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">out</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span><span class="p">.</span><span class="nx">length</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">out</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">item</span> <span class="nx">Item</span><span class="p">,</span> <span class="nx">maxItems</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">i</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>  <span class="c1">// The data exists in the current node, update the data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">out</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">item</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">out</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>  <span class="c1">// The current node has no children, insert new data in the current node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">insertAt</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nf">maybeSplitChild</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">maxItems</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">inTree</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">item</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">inTree</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// no change, we want first split node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">case</span> <span class="nx">inTree</span><span class="p">.</span><span class="nf">Less</span><span class="p">(</span><span class="nx">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">      <span class="nx">i</span><span class="o">++</span> <span class="c1">// we want second split node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">      <span class="nx">out</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">item</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">out</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nf">mutableChild</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nf">insert</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">maxItems</span><span class="p">)</span> <span class="c1">// Recursive calls
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The execution path of the <code>insert</code> method is as follows.</p>
<ol>
<li>first determine whether the data exists in the current node, and if so, update the data.</li>
<li>if the data does not exist in the current node and the current node has no children, then insert the new data directly in the current node.</li>
<li>if the data does not exist in the current node, and the current node contains children, then recursively call the <code>insert</code> method of the children. As mentioned in the Strict Weak Ordering subsection, the <code>find</code> method returns i as the <strong>first</strong> value that satisfies the <code>(item &lt; s[i])</code> condition. Since it has been determined that the data does not exist in the current node, it should be stored in the i-th child node.</li>
</ol>
<h3 id="delete">Delete</h3>
<p>The following judgments are required when deleting data from a B-Tree node.</p>
<ul>
<li>If the number of items in the node is greater than minItems, the specified item is deleted directly from the node.</li>
<li>If the number of items in the node is less than or equal to minItems, then you need to fill the node with items:
<ol>
<li>the left node contains enough items, steal an item from the left node.</li>
<li>the right node contains enough items, steal an item from the right node.</li>
<li>merge with the right node.</li>
</ol>
</li>
</ul>
<p>The btree simplifies the delete operation somewhat by ensuring that the child node has enough items to remove the node before recursively calling the <code>remove</code> method on the child node, and then calling the <code>remove</code> method again to actually remove the data.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// The following code has been simplified
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">remove</span><span class="p">(</span><span class="nx">item</span> <span class="nx">Item</span><span class="p">,</span> <span class="nx">minItems</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">typ</span> <span class="nx">toRemove</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">i</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">removeAt</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// If we get to here, we have children.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">items</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">minItems</span> <span class="p">{</span> <span class="c1">// Child nodes need to be populated with item
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nf">growChildAndRemove</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">item</span><span class="p">,</span> <span class="nx">minItems</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nx">child</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">mutableChild</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">out</span> <span class="o">:=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">child</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">minItems</span><span class="p">,</span> <span class="nx">removeMax</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">out</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">minItems</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// growChildAndRemove Make sure the child node contains enough items
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">growChildAndRemove</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">item</span> <span class="nx">Item</span><span class="p">,</span> <span class="nx">minItems</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">typ</span> <span class="nx">toRemove</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">items</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">minItems</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Steal from left child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">items</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">minItems</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// steal from right child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// merge with right child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">minItems</span><span class="p">,</span> <span class="nx">typ</span><span class="p">)</span> <span class="c1">// The second call to the remove method actually removes the item
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="iterate">Iterate</h3>
<p>The btree supports incremental/descending range queries, in the case of incremental queries, this is a standard iterative BFS implementation and iterates over the values with the <code>ItemIterator</code> function passed in by the caller.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">iterate</span><span class="p">(</span><span class="nx">dir</span> <span class="nx">direction</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span> <span class="nx">Item</span><span class="p">,</span> <span class="nx">includeStart</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">hit</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">iter</span> <span class="nx">ItemIterator</span><span class="p">)</span> <span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">ok</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">  <span class="kd">var</span> <span class="nx">index</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="nx">dir</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nx">ascend</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">start</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">index</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="nx">start</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">hit</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">iterate</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">,</span> <span class="nx">includeStart</span><span class="p">,</span> <span class="nx">hit</span><span class="p">,</span> <span class="nx">iter</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nx">hit</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Removed boundary condition handling code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">!</span><span class="nf">iter</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">hit</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="nx">hit</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">iterate</span><span class="p">(</span><span class="nx">dir</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">stop</span><span class="p">,</span> <span class="nx">includeStart</span><span class="p">,</span> <span class="nx">hit</span><span class="p">,</span> <span class="nx">iter</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">hit</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">hit</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="application">Application</h3>
<p>etcd saves each version of the key-value pair <code>reversion</code> to BoltDB in order to achieve multi-version concurrency control. In order to associate the original key-value pair information provided by the client with the reversion, etcd uses btree to maintain the mapping between Key and reversion, and then uses the obtained reversion to find the value in BoltDB.</p>
<p>The following is etcd&rsquo;s wrapped btree code. Since btree supports concurrent reads, but only serial writes, a read/write lock is added to <code>treeIndex</code>, which is not described in detail in this article.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">treeIndex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
</span></span><span class="line"><span class="cl">  <span class="nx">tree</span> <span class="o">*</span><span class="nx">btree</span><span class="p">.</span><span class="nx">BTree</span>
</span></span><span class="line"><span class="cl">  <span class="nx">lg</span>   <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="summary">Summary</h2>
<p>The Google implementation of btree has many points to consider, using write-time copy and recycle lists to reduce memory overhead and reuse the underlying code as much as possible, and the overall design is very clean.</p>
<p>From the above, we know that the performance of B-Tree lookup is unstable, with the best case being only the root node and the worst case being the leaf node. And as an ordered combination of data, its range query performance is not good either. Therefore, an improved data structure B+Tree is proposed based on the B-Tree.</p>
<ul>
<li>All nodes of B-Tree store data, while only leaf nodes of B+Tree store data with stable query complexity of log(n),.</li>
<li>The leaf nodes of B+Tree add pointers to the left and right nodes, i.e., it becomes a chain table structure, and degenerates from BFS to chain table traversal when performing range queries.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/14/ff51da3b596343f6b1d955d177dd6f68.png" alt="B+Tree"></p>
<p>Another advantage of the B+Tree is that a non-leaf node of the same size can be indexed to more child nodes because the non-leaf nodes do not store data, only the key and a pointer to the child nodes. For example, if we implement a disk-based indexing system with a fixed size of 16KB per node and 1KB per piece of data, with a unit64 integer as the primary key and a unit64 pointer to a child node, that is, a node can store 16 pieces of data. Then the B+Tree with height 3 has 1 root node in the first layer, 1,000 nodes in the second layer (16 Bytes for a primary key and a pointer), and 1,000,000 nodes in the third layer, which can store about 16 million pieces of data. The B-Tree has only 16 nodes in the second layer and 256 nodes in the third layer, which can only store 4096 data, so it takes 6 layers to store 16 million data.</p>
<p>From the above example, we can see that in the case of tens of millions of data, without considering caching nodes in memory, B-Tree requires at worst 6 I/Os to query the data, while B+Tree is stable at 3 I/Os.</p>
<p>Therefore, in my opinion, B-Tree has no advantage in disk-based storage systems for either single-value queries or range queries, and in pure in-memory storage, B-Tree is only suitable for infrequent range queries.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.geeksforgeeks.org/difference-between-b-tree-and-b-tree/">Difference between B tree and B+ tree - GeeksforGeeks</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/1734663.1734671">Organization and maintenance of large ordered indices</a></li>
<li><a href="https://medium.com/@shiansu/strict-weak-ordering-and-the-c-stl-f7dcfa4d4e07">Strict Weak Ordering and the C++ STL</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/ebpf/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">eBPF, a Linux kernel monitoring technology </span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/radix-tree-gin/">
            <span class="next-text nav-default">Radix Tree and Gin Implementation</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
