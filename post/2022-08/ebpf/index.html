<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>eBPF, a Linux kernel monitoring technology  - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article briefly organizes the technical principles and application scenarios of eBPF." /><meta name="keywords" content="Ebpf" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/ebpf/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="eBPF, a Linux kernel monitoring technology " />
<meta property="og:description" content="This article briefly organizes the technical principles and application scenarios of eBPF." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/ebpf/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-14T11:42:08+08:00" />
<meta property="article:modified_time" content="2022-08-14T11:42:08+08:00" />

<meta itemprop="name" content="eBPF, a Linux kernel monitoring technology ">
<meta itemprop="description" content="This article briefly organizes the technical principles and application scenarios of eBPF."><meta itemprop="datePublished" content="2022-08-14T11:42:08+08:00" />
<meta itemprop="dateModified" content="2022-08-14T11:42:08+08:00" />
<meta itemprop="wordCount" content="3499">
<meta itemprop="keywords" content="ebpf," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="eBPF, a Linux kernel monitoring technology "/>
<meta name="twitter:description" content="This article briefly organizes the technical principles and application scenarios of eBPF."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">eBPF, a Linux kernel monitoring technology </h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-14 11:42:08 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3499 words </span>
          <span class="more-meta"> 17 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#ebpf-origins">eBPF Origins</a>
          <ul>
            <li><a href="#why-use">Why use?</a></li>
          </ul>
        </li>
        <li><a href="#ebpf-programming">eBPF Programming</a>
          <ul>
            <li><a href="#registers-and-calling-conventions">Registers and calling conventions</a></li>
            <li><a href="#program-types-and-helper-functions">Program Types and Helper Functions</a></li>
            <li><a href="#ebpf-maps">eBPF Maps</a></li>
          </ul>
        </li>
        <li><a href="#ebpf-application-scenarios">eBPF Application Scenarios</a>
          <ul>
            <li><a href="#tracing">Tracing</a></li>
            <li><a href="#networking">Networking</a></li>
            <li><a href="#security">Security</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>BPF is a very flexible and efficient virtual machine-like component in the Linux kernel, capable of safely executing bytecode at many kernel hook points. This article briefly organizes the technical principles and application scenarios of eBPF.</p>
<h2 id="ebpf-origins">eBPF Origins</h2>
<p>BPF is called <strong>B</strong>erkeley <strong>P</strong>acket <strong>F</strong>ilter, as the name suggests, BPF was originally used for packet filtering and was used in the <code>tcpdump</code> command, for example running a filter rule like <code>tcpdump tcp and dst port 443</code> would copy packets with protocol tcp and destination port 443 to the user state.</p>
<p>The BPF program runs in the kernel to facilitate filtering out unnecessary traffic and retrieving only those packets that we need to monitor, thus reducing the overhead of copying unnecessary packets into user space and subsequently filtering them.</p>
<p>BPF is implemented based on a virtual machine in the kernel, by translating BPF rules into bytecode to run in the kernel.</p>
<p>The eBPF (extended BPF) evolved from the BPF and has a richer set of instructions than the previous BPF, which expanded from 2 32-bit registers to 11 64-bit registers and was known as the cBPF (classic BPF). After v3.15 of the linux kernel, the kernel started to support eBPF, so a special program is responsible for translating cBPF instructions into eBPF instructions for execution.</p>
<p>eBPF greatly extends its functionality beyond packet filtering, allowing us to run arbitrary eBPF code in the kernel, for example, by attaching programs to <code>kprobe</code> events that trigger the eBPF program to run when the corresponding kernel function is started. To borrow from <a href="http://www.brendangregg.com/blog/index.html">Brendan Gregg</a>&rsquo;s description of eBPF technology.</p>
<blockquote>
<p>eBPF does to Linux what JavaScript does to HTML.</p>
</blockquote>
<p>Just as we can use JavaScript to develop event-triggered programs on web pages that run corresponding functions when events such as mouse clicks on buttons occur, these mini-programs run in a secure virtual machine in the browser. With eBPF, we can write mini-programs that run when events such as disk I/O, system calls, etc. occur, and these run in a secure virtual machine on the kernel. More precisely, eBPF is more like a v8 virtual machine running JavaScript, where we can compile high-level programming languages into bytecode and run them in the sandboxed environment of eBPF.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/14/dae30f72ad57469380fa887800ed8a56.png" alt="ebpf Event Trigger"></p>
<p>An event-triggered task is a task in a real-time operating system that starts running only under the condition that a specific event associated with it occurs.</p>
<p>Today eBPF is not only specific to networking, but can also be used in scenarios such as kernel tracking, security, etc. The versatility of eBPF has attracted a larger community to innovate and develop related eco-software.</p>
<h3 id="why-use">Why use?</h3>
<p>Since eBPF programs can be triggered by a series of events, eBPF-based applications can help us discover what is happening in the system. eBPF has an application scenario of program monitoring - identifying abnormal behavior of an application, for example when writing files to important system directories. eBPF code can run in response to a file event to check if the program&rsquo;s behavior is legitimate.</p>
<p>Although there are some off-the-shelf tools that can perform similar tasks, such as the <code>ps</code> command that reports the current system process status. However, the monitoring accuracy of such monitoring programs lies in the program sampling frequency; programs that execute at shorter sampling intervals than the monitoring program will not be detected, and increasing the sampling frequency will again affect the system performance. <strong>And the eBPF program is event-triggered, not sampling-based, and it runs in the kernel at a very high speed</strong>, so eBPF-based detection tools are more accurate than traditional sampling-based methods.</p>
<p>In addition, there is no need to recompile the kernel to use eBPF programs. We can write programs in a subset of C, compile them into eBPF bytecode using a compiler backend, and then the kernel maps the eBPF instructions to the processor&rsquo;s native instructions (opcode) using a JIT on-the-fly compiler located in the kernel for optimal execution performance in the kernel.</p>
<p>The drawback of eBPF-based security tools is that we can only detect new processes or file access events when they start, but we cannot prevent them from starting. These monitoring results can tell us when processes are running in an abnormal manner and can be used to trigger protective actions, such as shutting down processes or closing containers, via eBPF. However, if this unexpected behavior is malicious, damage may have been done.</p>
<p>The cilium document <em><a href="https://docs.cilium.io/en/v1.9/bpf/">BPF and XDP Reference Guide</a></em> summarizes some of the advantages of eBPF.</p>
<ul>
<li>Kernel programmability without kernel/user space switching. eBPF Map can be used when state needs to be shared between eBPF programs or between kernel/user space.</li>
<li>The ability for eBPF programs to disable unneeded features at compile time, e.g., if the container does not require IPv4, then eBPF programs can be written to handle only the IPv6 case.</li>
<li>eBPF provides a stable ABI to the user space and does not rely on any third-party kernel modules: eBPF is a core component of the Linux kernel, and Linux is already widely deployed, so it is guaranteed that existing eBPF programs will continue to run on new kernel versions. This guarantee is at the same level as the system calls and the eBPF programs are portable across platforms.</li>
<li>in network scenarios, eBPF programs can be updated atomically without restarting the kernel, system services, or containers and without causing network outages, in addition to the fact that updating an eBPF Map does not result in a loss of program state</li>
<li>BPF programs work with the kernel, reusing existing kernel infrastructure (e.g., drivers, netdevices, tunnels, protocol stacks, and sockets) and tools (e.g., iproute2), as well as the security guarantees provided by the kernel. <strong>Unlike the Linux Module, eBPF programs are verified by an in-kernel verifier to ensure that they do not cause the kernel to crash, that the program will always terminate, etc.</strong> Unlike the Linux Module, eBPF programs are verified by an in-kernel verifier. For example, XDP programs reuse existing kernel drivers and can directly manipulate data frames stored in the DMA buffers without exposing these data frames or even the entire driver to user space as in some models (e.g. DPDK). Moreover, XDP programs reuse the kernel stack instead of bypassing it. eBPF programs can be thought of as generic `glue code&rsquo; between kernel facilities, taking advantage of cleverly designed programs in the middle layer to solve specific problems.</li>
</ul>
<h2 id="ebpf-programming">eBPF Programming</h2>
<p>The eBPF is designed as a general purpose RISC instruction set that maps directly to <code>x86_64</code>, <code>arm64</code>, so all eBPF registers can be mapped to CPU hardware registers one by one, and the generic operations are 64-bit so that arithmetic operations can be performed on pointers.</p>
<p>Although the instruction set contains forward and backward jumps, the eBPF checker in the kernel forbids loops in the program to ensure that the program will eventually stop. Since eBPF programs run in the kernel, the checker&rsquo;s job is to ensure that these programs are safe to run and do not affect the stability of the system. This means that loops are possible from an instruction set point of view, but the checker imposes restrictions on them.</p>
<p>Some concepts and conventions in eBPF programming are described below.</p>
<h3 id="registers-and-calling-conventions">Registers and calling conventions</h3>
<p>The BPF consists of the following three parts.</p>
<ol>
<li>11 64-bit registers that contain 32-bit subregisters.</li>
<li>a Program Counter (PC);</li>
<li>a 512-byte size eBPF stack space.</li>
</ol>
<p>The registers are named from <code>r0</code> to <code>r10</code>, and the eBPF calling convention is as follows.</p>
<ul>
<li><code>r0</code> holds the return value of the called helper function, and is also used to hold the exit value of the eBPF program.</li>
<li><code>r1</code> - <code>r5</code> holds the parameters passed when the eBPF calls the kernel helper function.</li>
<li><code>r6</code> - <code>r9</code> are stored by the called party and can be read by the caller after the function returns.</li>
<li><code>r10</code> is the only read-only register that holds the address of the stack frame pointer of the eBPF stack space.</li>
<li>The stack space is used to temporarily hold the values of <code>r1</code> - <code>r5</code>. Due to the limited number of registers, if the values in these registers are to be reused between multiple auxiliary function calls, then the eBPF program needs to be responsible for temporarily dumping these values onto the eBPF stack or saving them to the registers held by the callee.</li>
</ul>
<blockquote>
<p>Note: The default mode of operation is 64-bit. 32-bit subregisters can only be accessed through a special ALU (Arithmetic Logic Unit), and writes to 32-bit subregisters are padded with zeros to 64 bits.</p>
</blockquote>
<p>When a BPF program starts execution, the <code>r1</code> register holds the program&rsquo;s context, i.e. the program&rsquo;s input parameters. eBPF can only work in a single context, which is defined by the program type, e.g. a network program can take the kernel representation of a network packet, <code>skb</code>, as an input parameter.</p>
<p><strong>Before kernel version 5.2 eBPF programs were strictly limited to a maximum of 4096 instructions</strong>, which meant that every program was designed to end quickly, but as eBPF programs became more complex, this was relaxed to 1 million instructions starting with version 5.2. In addition, there is the concept of tail calls in eBPF, which allows one eBPF program to call another eBPF program. Tail calls are also limited, currently up to 32 levels of calls. This feature is now commonly used to decouple the program logic into several different phases.</p>
<h3 id="program-types-and-helper-functions">Program Types and Helper Functions</h3>
<p>Each eBPF program belongs to a specific Program Types, which can be found in the <em><a href="https://github.com/torvalds/linux/blob/v5.9/include/uapi/linux/bpf.h#L168">linux/bpf.h#L168 at v5.9</a></em> file to see what program types are supported in the current version, and more are being added all the time. They can be broadly classified into several categories such as network, trace, security, etc. The input parameters of eBPF programs also vary according to the program type.</p>
<p>Helper Functions are used to help handle the interaction between user space and kernel space, such as getting PIDs, GIDs, time, and manipulating kernel objects from the kernel. The helper functions supported by different kernel versions are also different. We can view the helper functions supported by the current version from <em><a href="https://github.com/torvalds/linux/blob/v5.9/include/uapi/linux/bpf.h#L3399">linux/bpf.h#L3399 at v5.9</a></em>.</p>
<p>For example, eBPF programs of type <code>BPF_PROG_TYPE_SOCKET_FILTER</code> can only use the following helper functions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">BPF_FUNC_skb_load_bytes</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_FUNC_skb_load_bytes_relative</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_FUNC_get_socket_cookie</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_FUNC_get_socket_uid</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_FUNC_perf_event_output</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">Base</span> <span class="n">functions</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Due to space limitations, only a few simple examples are given in this article. For a detailed classification of auxiliary functions and relationships, please refer to the BCC documentation <em><a href="https://github.com/iovisor/bcc/blob/master/docs/kernel-versions.md">bcc/docs/kernel-versions</a></em> .</p>
<h3 id="ebpf-maps">eBPF Maps</h3>
<p>eBPF Maps are efficient key-value repositories that reside in kernel space**. data in a Map can be accessed by any eBPF program, and state information can be placed in a Map if you want to save state between multiple eBPF program calls. maps can also be accessed from user space via file descriptors and can be shared between any eBPF program and user space Map can also be accessed from user space via file descriptors and can be shared between any eBPF program and user space applications. Thus, the Map can be used for data interaction between eBPF programs and eBPF programs, and between eBPF programs and user-state programs.</p>
<p>The eBPF programs sharing a Map do not need to be the same program type, e.g. a monitoring program can share a Map with a network program. Currently a single eBPF program can directly access up to 64 different Maps.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/14/a4f317a3949f43409a7a63bbdd8a74ba.png" alt="eBPF map"></p>
<h4 id="mapping-types">Mapping Types</h4>
<p>Map provides a layer of base data structure mapping for upper-level programs. There are more than two dozen data types, all implemented by the core kernel, so we cannot add or modify data structures.</p>
<p>There are two types of Map: generic Map and non-generic Map. The following are some of the generic Map types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_HASH</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_ARRAY</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_LRU_HASH</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_PERCPU_HASH</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_PERCPU_ARRAY</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_LRU_PERCPU_HASH</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The Generic Map provides mappings for data structures such as hash tables, arrays, LRU, etc., in addition to the corresponding single CPU mapping types: we can assign CPUs to the type maps, and each CPU will see its own independent version of the map, which is more conducive to high-performance lookup and metrics aggregation.</p>
<p>eBPF programs can read and write Map through helper functions, and user-state programs can read and write Map through the <code>bpf()</code> system call, and all functions and commands that operate on the generic Map are listed below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Map-related helper functions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_FUNC_map_lookup_elem</span><span class="p">()</span>		<span class="c1">// Find an element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_FUNC_map_update_elem</span><span class="p">()</span>		<span class="c1">// Update or create elements
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_FUNC_map_delete_elem</span><span class="p">()</span>		<span class="c1">// Delete element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_FUNC_map_peek_elem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_FUNC_map_pop_elem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_FUNC_map_push_elem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="c1">// bpf() system call actionable API
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_MAP_LOOKUP_ELEM</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_UPDATE_ELEM</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_DELETE_ELEM</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_GET_NEXT_KEY</span><span class="p">,</span>			<span class="c1">// For iterative queries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_MAP_LOOKUP_AND_DELETE_ELEM</span><span class="p">,</span>	<span class="c1">// Find and delete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_MAP_LOOKUP_BATCH</span><span class="p">,</span>			<span class="c1">// Batch processing of corresponding operations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_MAP_LOOKUP_AND_DELETE_BATCH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_UPDATE_BATCH</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_DELETE_BATCH</span><span class="p">,</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Data manipulation is not complicated, and its role can be seen from the function name. The user state <code>bpf()</code> system call then encapsulates some advanced operations to facilitate bulk data processing.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// Non-generic MAP
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BPF_MAP_TYPE_PROG_ARRAY</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_ARRAY_OF_MAPS</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_HASH_OF_MAPS</span>
</span></span><span class="line"><span class="cl"><span class="n">BPF_MAP_TYPE_CGROUP_ARRAY</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above lists several non-generic Maps that are only used in specific scenarios, for example <code>BPF_MAP_TYPE_PROG_ARRAY</code> is used to hold references to other eBPF programs and can be used with tail calls to jump between programs, <code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code> and <code>BPF_MAP_TYPE_ HASH_OF_MAPS</code> are used to hold pointers to other Maps so that the entire Map can be replaced atomically at runtime, and <code>BPF_MAP_TYPE_CGROUP_ARRAY</code> is used to hold references to cgroups.</p>
<h4 id="ebpf-virtual-file-system">eBPF Virtual File System</h4>
<p>The basic feature of an eBPF mapping is the file descriptor <code>fd</code>, which means that the data saved when the file descriptor is closed is also lost. In order to keep this data even after the program that created it terminates, the eBPF virtual file system was introduced starting with Linux kernel version 4.4 and by default mounts the data in the <code>/sys/fs/bpf/</code> directory, identifying these persistent objects by their path.</p>
<p>We can only manipulate these objects with the system call <code>bpf()</code>, the <code>BPF_OBJ_PIN</code> command is used to save Map objects to the file system, and <code>BPF_OBJ_GET</code> is used to get objects that are already fixed to the file system.</p>
<h4 id="concurrent-access">Concurrent Access</h4>
<p>Since eBPF mapping can occur with many programs accessing the same Map concurrently, this can create contention conditions. To prevent data contention, eBPF introduces the concept of <strong>spin locks</strong> to lock the accessed map elements.</p>
<blockquote>
<p>The spinlock feature was introduced in Linux 5.1 and is only available for arrays, hashes, and cgroup mappings.</p>
</blockquote>
<p>In the eBPF program, we can use the two helper functions <code>BPF_FUNC_spin_lock()</code> and <code>BPF_FUNC_spin_unlock()</code> to lock and unlock the data so that other programs can access the element safely after releasing the lock. In user space, we can use the <code>BPF_F_LOCK</code> flag when updating or reading elements to avoid data races.</p>
<h2 id="ebpf-application-scenarios">eBPF Application Scenarios</h2>
<p>After understanding the basic concepts of eBPF programming, let&rsquo;s take a look at a few application scenarios for eBPF.</p>
<h3 id="tracing">Tracing</h3>
<p>The purpose of tracing is to provide runtime useful information for future problem analysis. The main advantage of using eBPF for tracing is that you can access almost any information about the Linux kernel and application, and eBPF imposes minimal overhead on system performance and latency, and does not require business process modifications to collect data. eBPF provides both probe and trace point tracing methods</p>
<h4 id="probes">Probes</h4>
<p>The probes provided by eBPF are of two types.</p>
<ul>
<li><strong>Kernel probes</strong>: provide dynamic access to internal components in the kernel.</li>
<li><strong>User space probes</strong>: provide dynamic access to programs running in user space.</li>
</ul>
<p>There are two types of kernel probes: kprobes allow inserting eBPF programs before any kernel instructions are executed, and kretprobes insert eBPF programs when kernel instructions have return values. User space probes allow dynamic flags to be set in programs running in user space; they are equivalent to kernel probes and are divided into uprobes and ureprobes.</p>
<p>In the following BCC example code, we have written a kprobes probe program that demonstrates the functionality of eBPF by tracing the <code>execve()</code> system call. Monitoring the <code>execve()</code> system call is useful for detecting unexpected executables.</p>
<p>The <code>do_sys_execve()</code> function in the code is used to get the name of the command the kernel is running and print it to the console; we then bind the <code>do_sys_execve()</code> function to the <code>execve()</code> system call using the bpf.attach_kprobe() method provided by BCC. Running this program will show you that whenever the kernel executes the <code>execve()</code> system call, the corresponding command name will be printed on the console.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">bcc</span> <span class="kn">import</span> <span class="n">BPF</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bpf_source</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">#include &lt;uapi/linux/ptrace.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">int do_sys_execve(struct pt_regs *ctx) {
</span></span></span><span class="line"><span class="cl"><span class="s2">  char comm[16];
</span></span></span><span class="line"><span class="cl"><span class="s2">  bpf_get_current_comm(&amp;comm, sizeof(comm));
</span></span></span><span class="line"><span class="cl"><span class="s2">  bpf_trace_printk(&#34;executing program: </span><span class="si">%s</span><span class="se">\\</span><span class="s2">n&#34;, comm);
</span></span></span><span class="line"><span class="cl"><span class="s2">  return 0;
</span></span></span><span class="line"><span class="cl"><span class="s2">}
</span></span></span><span class="line"><span class="cl"><span class="s2">&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bpf</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">bpf_source</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">execve_function</span> <span class="o">=</span> <span class="n">bpf</span><span class="o">.</span><span class="n">get_syscall_fnname</span><span class="p">(</span><span class="s2">&#34;execve&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bpf</span><span class="o">.</span><span class="n">attach_kprobe</span><span class="p">(</span><span class="n">event</span><span class="o">=</span><span class="n">execve_function</span><span class="p">,</span> <span class="n">fn_name</span><span class="o">=</span><span class="s2">&#34;do_sys_execve&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bpf</span><span class="o">.</span><span class="n">trace_print</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note that kernel probes do not have a stable application binary interface (ABI), so the same program code may not work in different kernel versions.</p>
<h4 id="tracepoints">Tracepoints</h4>
<p>Tracepoints are static markers for kernel code, developed and written by the kernel staff, and are guaranteed to exist on newer versions for traces from older versions.</p>
<p>Each tracepoint on Linux corresponds to a <code>/sys/kernel/debug/tracing/events</code> entry. For example, to see the network-related tracepoints.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp"># sudo ls -la /sys/kernel/debug/tracing/events/net
</span></span></span><span class="line"><span class="cl"><span class="cp"># Some tracking points have been deleted due to space limitations
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">total</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span>  <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">0</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">21</span><span class="o">:</span><span class="mo">00</span> <span class="n">net_dev_queue</span>
</span></span><span class="line"><span class="cl"><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span>  <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">0</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">21</span><span class="o">:</span><span class="mo">00</span> <span class="n">net_dev_start_xmi</span>
</span></span><span class="line"><span class="cl"><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span>  <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">0</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">21</span><span class="o">:</span><span class="mo">00</span> <span class="n">netif_receive_skb</span>
</span></span><span class="line"><span class="cl"><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span>  <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">0</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">21</span><span class="o">:</span><span class="mo">00</span> <span class="n">netif_receive_skb_entry</span>
</span></span><span class="line"><span class="cl"><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span>  <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">0</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">21</span><span class="o">:</span><span class="mo">00</span> <span class="n">netif_receive_skb_exit</span>
</span></span><span class="line"><span class="cl"><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span>  <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">0</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">21</span><span class="o">:</span><span class="mo">00</span> <span class="n">netif_rx</span>
</span></span><span class="line"><span class="cl"><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span>  <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">0</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">21</span><span class="o">:</span><span class="mo">00</span> <span class="n">netif_rx_entry</span>
</span></span><span class="line"><span class="cl"><span class="n">drwxr</span><span class="o">-</span><span class="n">xr</span><span class="o">-</span><span class="n">x</span>  <span class="mi">2</span> <span class="n">root</span> <span class="n">root</span> <span class="mi">0</span> <span class="n">Nov</span> <span class="mi">20</span> <span class="mi">21</span><span class="o">:</span><span class="mo">00</span> <span class="n">netif_rx_exit</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the following example, we bind the eBPF program to the <code>net:netif_rx</code> tracepoint and print out the name of the calling program on the console.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">bcc</span> <span class="kn">import</span> <span class="n">BPF</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bpf_source</span> <span class="o">=</span> <span class="s2">&#34;&#34;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s2">int trace_netif_rx(void *ctx) {
</span></span></span><span class="line"><span class="cl"><span class="s2">  char comm[16];
</span></span></span><span class="line"><span class="cl"><span class="s2">  bpf_get_current_comm(&amp;comm, sizeof(comm));
</span></span></span><span class="line"><span class="cl"><span class="s2">
</span></span></span><span class="line"><span class="cl"><span class="s2">  bpf_trace_printk(&#34;</span><span class="si">%s</span><span class="s2"> is doing netif_rx&#34;, comm);
</span></span></span><span class="line"><span class="cl"><span class="s2">  return 0;
</span></span></span><span class="line"><span class="cl"><span class="s2">}
</span></span></span><span class="line"><span class="cl"><span class="s2">&#34;&#34;&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bpf</span> <span class="o">=</span> <span class="n">BPF</span><span class="p">(</span><span class="n">text</span> <span class="o">=</span> <span class="n">bpf_source</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bpf</span><span class="o">.</span><span class="n">attach_tracepoint</span><span class="p">(</span><span class="n">tp</span> <span class="o">=</span> <span class="s2">&#34;net:netif_rx&#34;</span><span class="p">,</span> <span class="n">fn_name</span> <span class="o">=</span> <span class="s2">&#34;trace_netif_rx&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bpf</span><span class="o">.</span><span class="n">trace_print</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="networking">Networking</h3>
<p>eBPF programs have two main uses in networking: packet capture and filtering. User-space programs can add filters to any socket to extract information about packets, or to release, ban, redirect, etc. for specific types of packets.</p>
<h4 id="packet-filtering">Packet Filtering</h4>
<p>Packet filtering is one of the most common scenarios for eBPF and is used in three main situations.</p>
<ul>
<li>Real-time traffic drop, e.g., allowing only UDP traffic to pass and dropping other packets.</li>
<li>real-time observation of packets filtered by specific conditions.</li>
<li>subsequent analysis of network traffic captured in a real-time system.</li>
</ul>
<p><code>tcpdump</code> is a typical eBPF packet filtering application, and now we can write some custom networking programs in <em><a href="https://github.com/iovisor/bcc/tree/master/examples/networking">bcc/examples/networking</a></em> you can see some examples of usage</p>
<h4 id="flow-control-classifier">Flow Control Classifier</h4>
<p>A few examples of traffic control uses are as follows.</p>
<ul>
<li>prioritizing certain types of packets.</li>
<li>Dropping specific types of packets.</li>
<li>Bandwidth allocation.</li>
</ul>
<h4 id="xdp">XDP</h4>
<p>XDP (eXpress Data Path) provides a high-performance, programmable network data path for the Linux kernel. It gives Linux networks a huge performance boost because network packets are processed before they even enter the network stack.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/14/1f361990e81344d39038502ee7e31697.png" alt="Message reception process"></p>
<p>The above image shows a complete packet reception process, and the entire processing chain is long, requiring memory copies, context switches, hardware and software interrupts between the kernel and user states. Processing a large number of packets will take up a lot of CPU resources, making it difficult to meet the demands of a highly concurrent network.</p>
<p>XDP solves this problem. It is equivalent to adding a new layer to the Linux network stack. The processing is done at the earliest moment when the message arrives at the CPU, even avoiding the allocation of <code>sk_buff</code> and reducing the load on the memory copy. With the support of specific NIC hardware and drivers, it is even possible to offload XDP programs to the NIC, further reducing CPU usage.</p>
<p>XDP relies on eBPF technology and provides a complete, programmable packet processing scheme that allows us to forward, redirect and pass down packets using XDP. Examples can be found in <a href="https://github.com/iovisor/bcc/tree/master/examples/networking/xdp">bcc/examples/networking/xdp</a>.</p>
<h3 id="security">Security</h3>
<p>Seccomp (Secure Computing) was introduced to the Linux kernel in version 2.6.12 to limit the system calls available to processes to four: <code>read</code>, <code>write</code>, <code>_exit</code>, and <code>sigreturn</code>. Initially, Seccomp mode was implemented using a whitelist approach, in which the kernel terminates the process using SIGKILL or SIGSYS if any other system call is attempted, except for open file descriptors and the four allowed system calls.</p>
<p>Although Seccomp secures the host, it is too restrictive to be of much practical use. To address the need for more fine-grained restrictions in practical applications, Seccomp-BPF was introduced.</p>
<p>Seccomp-BPF is a combination of Seccomp and cBPF rules (note that it is not eBPF), which allows users to filter system calls using a configurable policy implemented using BPF rules, which can filter on any system call and its parameters.</p>
<p>An example of its use can be found in <a href="http://wh4lter.icu/2020/04/20/seccomp/">seccomp</a>.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/ebpf/">ebpf</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/fingerprint/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Introduction to Browser Fingerprinting Technology</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/google-btree/">
            <span class="next-text nav-default">Google B-Tree </span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
