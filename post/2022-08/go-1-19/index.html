<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>A few notable changes in Go 1.19 - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore the changes in Go 1.19 that we should focus on." /><meta name="keywords" content="golang 1.19, Soft memory limit, " />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/go-1-19/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="A few notable changes in Go 1.19" />
<meta property="og:description" content="Explore the changes in Go 1.19 that we should focus on." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/go-1-19/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-22T12:09:04+08:00" />
<meta property="article:modified_time" content="2022-08-22T12:09:04+08:00" />

<meta itemprop="name" content="A few notable changes in Go 1.19">
<meta itemprop="description" content="Explore the changes in Go 1.19 that we should focus on."><meta itemprop="datePublished" content="2022-08-22T12:09:04+08:00" />
<meta itemprop="dateModified" content="2022-08-22T12:09:04+08:00" />
<meta itemprop="wordCount" content="4812">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="A few notable changes in Go 1.19"/>
<meta name="twitter:description" content="Explore the changes in Go 1.19 that we should focus on."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">A few notable changes in Go 1.19</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-22 12:09:04 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4812 words </span>
          <span class="more-meta"> 23 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-overview">1. Overview</a></li>
        <li><a href="#2-revising-the-go-memory-model-documentation">2. Revising the Go memory model documentation</a>
          <ul>
            <li><a href="#1-what-is-the-memory-model">1. What is the memory model?</a></li>
            <li><a href="#2-go-memory-model-documentation">2. Go Memory Model Documentation</a></li>
            <li><a href="#3-what-has-changed-in-the-revised-memory-model-documentation">3. What has changed in the revised memory model documentation</a></li>
          </ul>
        </li>
        <li><a href="#3-introduction-of-soft-memory-limit">3. Introduction of Soft memory limit</a>
          <ul>
            <li><a href="#1-the-only-gc-tuning-option-gogc">1. The only GC tuning option: GOGC</a></li>
            <li><a href="#2-pacers-problem">2. Pacer&rsquo;s problem</a></li>
            <li><a href="#3-gc-tuning-solutions-from-the-go-community">3. GC tuning solutions from the Go community</a></li>
            <li><a href="#4-introducing-soft-memory-limit">4. Introducing Soft memory limit</a></li>
          </ul>
        </li>
        <li><a href="#4-summary">4. Summary</a></li>
        <li><a href="#5-reference">5. Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>We know that the Go team redefined the team&rsquo;s release cadence in 2015, setting the frequency of major Go releases to twice a year, with release windows set for February and August each year. <a href="https://tonybai.com/2015/07/10/some-changes-in-go-1-5/">The Go 1.5 release, which implements the bootstrap</a>, is the first release under this cadence. Generally, the Go team releases releases in the middle of these two windows, but there have been accidents in the past few years, for example, <a href="https://tonybai.com/2022/04/20/some-changes-in-go-1-18">Go 1.18</a>, which carries the responsibility of generalization implementation, was released with a month delay.</p>
<p>Just when we thought that Go 1.19 would not be released soon, on August 2, 2022 US time, <a href="https://go.dev/blog/go1.19">the Go core team officially released Go 1.19</a>, not only within the release window but also earlier than usual. Why? Simple, <strong>Go 1.19 is a &ldquo;small&rdquo; release</strong>, as opposed to a &ldquo;large&rdquo; release like Go 1.18. The development cycle for Go 1.19 is only about 2 months (March to early May), so the Go team has compressed the number of features added to Go 1.19.</p>
<p>But despite this, there are still a few changes in Go 1.19 that we should focus on, and I&rsquo;ll take a look at them with you in this article.</p>
<h2 id="1-overview">1. Overview</h2>
<p>In June (when Go 1.19 was already Freeze), I wrote a <a href="/post/2022-06/go-1-19/">&ldquo;Go 1.19 New Feature Preview&rdquo;</a>, which briefly introduced some of the new features of Go 1.19 that were basically confirmed at that time, and now it looks like Go 1.19 is not very different from the official version.</p>
<ul>
<li>
<p>Generics</p>
<p>Considering that Go 1.18 generic types have just landed, the generic types in Go 1.18 version are not the full version. However, Go 1.19 also did not rush to implement those features in the <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">generic design document</a>) that have not yet been implemented, but instead The main focus has been on fixing the <a href="https://github.com/golang/go/issues?q=is%3Aissue+label%3Agenerics+milestone%3AGo1.19">generic implementation issues</a> found in Go 1.18, in order to solidify the base of Go generic To lay the foundation for Go 1.20 and subsequent versions to achieve the full version of the generic type (details can be found in the article <a href="/post/2022-06/go-1-19/">&ldquo;Go 1.19 New Feature Preview&rdquo;</a>).</p>
</li>
<li>
<p>Other syntax aspects</p>
<p>None.</p>
<p>In this way, Go 1.19 still maintains the Go1 compatibility promise.</p>
</li>
<li>
<p>Officially support Longxin architecture on linux (GOOS=linux, GOARCH=loong64)</p>
<p>This has to be mentioned, because this change is all contributed by the domestic Longcore team. However, the minimum version of linux kernel currently supported by Longxin is also 5.19, which means that Longxin is not yet able to use Go on older versions of linux.</p>
</li>
<li>
<p>go env supports <code>CGO_CFLAGS</code>, <code>CGO_CPPFLAGS</code>, <code>CGO_CXXFLAGS</code>, <code>CGO_FFLAGS</code>, <code>CGO_LDFLAGS</code> and <code>GOGCCFLAGS</code></p>
</li>
</ul>
<p>When you want to set global rather than package level CGO build options, you can do so with these newly added CGO-related environment variables, which avoids having to use the cgo indicator in each Go source file that uses CGO to set them separately.</p>
<pre><code>The current default values for these go environment variables for CGO are as follows (using the default values on my macos as an example).

```txx
CGO_CFLAGS=&quot;-g -O2&quot;
CGO_CPPFLAGS=&quot;&quot;
CGO_CXXFLAGS=&quot;-g -O2&quot;
CGO_FFLAGS=&quot;-g -O2&quot;
CGO_LDFLAGS=&quot;-g -O2&quot;
GOGCCFLAGS=&quot;-fPIC -arch x86_64 -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/cz/sbj5kg2d3m3c6j650z0qfm800000gn/T/go-build1672298076=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;
```
</code></pre>
<p>Other more specific changes will not be elaborated, you can move to <a href="/post/2022-06/go-1-19/">&ldquo;Go 1.19 New Features Preview&rdquo;</a> to see them.</p>
<p>Let&rsquo;s focus on two important changes in Go 1.19: <strong>the new Go memory model document and the introduction of the Soft memory limit</strong> at Go runtime.</p>
<h2 id="2-revising-the-go-memory-model-documentation">2. Revising the Go memory model documentation</h2>
<p>I remember when I first learned Go, the most difficult of all the official Go documents was the <a href="https://go.dev/ref/mem">Go memory model document</a> (below), and I believe that many gophers must have had similar feelings to mine when they first read this document.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/9bd58cc1536e4d9981dfe4587d6600df.png" alt="Older versions of the Go memory model documentation"></p>
<blockquote>
<p>To view the old Go memory model documentation: <code>godoc -http=:6060 -goroot /Users/tonybai/.bin/go1.18.3</code>, where godoc is no longer distributed with the go installation package, you need to install it separately with the command: go install <code>go install golang.org/x/tools/cmd/godoc</code>.</p>
</blockquote>
<p>So, what does the old memory model document say? Why was it revised? By clarifying these two questions, we will have a general idea of what the new memory model document means. Let&rsquo;s start by looking at what is the memory model of a programming language.</p>
<h3 id="1-what-is-the-memory-model">1. What is the memory model?</h3>
<p>When it comes to the memory model, we have to start with the famous computer scientist and 2013 Turing Award winner <a href="https://www.microsoft.com/en-us/research/people/lamport/">Leslie Lamport</a>&rsquo;s 1979 paper titled &ldquo;<a href="https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs/">How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs</a>&rdquo;.</p>
<p>In this article, Lamport gives a condition for concurrent programs to run correctly on a multiprocessor computer with shared memory, i.e., for the multiprocessor to satisfy <strong>sequentially consistent</strong> .</p>
<p>It is mentioned in the text that a processor running at high speed does not necessarily execute in the order (code order) specified by the program. A processor is said to be <strong>sequential</strong> if the result of its execution (which may be chaotic) is the same as the result of execution in the order (code order) specified by the program.</p>
<p>For a multiprocessor with shared memory, on the other hand, it can be considered to satisfy <strong>sequential consistency</strong> only if the following conditions are met, i.e., if it has the conditions to guarantee the correct operation of a concurrent program.</p>
<ul>
<li>The result of any one execution is the same as the result of all processor operations executed in some order;</li>
<li>Each processor is also executed in the order specified by the program (code order) when each processor is viewed separately in &ldquo;some order of execution&rdquo;.</li>
</ul>
<p><strong>Sequential consistency is a typical shared-memory, multiprocessor memory model</strong> , a model that guarantees that all memory accesses are performed atomically and in programmatic order. The following is a schematic diagram of an abstract machine model for shared memory with sequential consistency, taken from <a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf">A Tutorial Introduction to the ARM and POWER Relaxed Memory Models</a>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/d44e62c956f4430d86b532e9ae79980a.png" alt="Sequential consistency"></p>
<p>Based on sequential consistency, the abstract machine in the above diagram has the following characteristics.</p>
<ul>
<li>There is no local reordering: each hardware thread executes instructions in the order specified by the program, completing each instruction (including any reads or writes to shared memory) before starting the next one.</li>
<li>Each write instruction is visible to all threads (including the thread doing the write) at the same time.</li>
</ul>
<p>From a programmer&rsquo;s point of view, a sequentially consistent memory model could not be more ideal. All read and write operations are directed to memory, there is no cache, and the value written to memory by one processor (or hardware thread) is observed by other processors (or hardware threads). With the sequential consistency (SC) provided by the hardware, we can achieve &ldquo;what you write is what you get&rdquo;.</p>
<p>But does such a machine really exist? Not really, at least not in mass-produced machines. Why? Because sequential consistency is not conducive to hardware and software performance optimization. A common machine model for real-world shared memory multiprocessor computers looks like this, also known as Total Store Ordering, the TSO model (diagram from <a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf">A Tutorial Introduction to the ARM and POWER Relaxed Memory Models</a>).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/a8486a8debef46acadfc5b3c996bc6fe.png" alt="A Tutorial Introduction to the ARM and POWER Relaxed Memory Models"></p>
<p>We see that in this machine, all processors are still connected to a single shared memory, but each processor&rsquo;s write memory operation changes from writing to the shared memory to writing to the processor&rsquo;s write buffer first, so that the processors do not have to wait for a write complete and the read memory operation on one processor also consults The processor&rsquo;s write buffer queue is consulted first (but not the write buffer queues of other processors). The existence of a write cache queue greatly improves the speed of processor write memory operations.</p>
<p>However, due to the existence of the write cache, the TSO model cannot satisfy sequential consistency, e.g., the property that &ldquo;each write instruction is visible to all threads (including the thread doing the writing) at the same time&rdquo;, because the data written to the local write cache queue is only visible to itself and not to other processors (hardware threads) until it is actually written to shared memory.</p>
<p>According to Lamport&rsquo;s theory, a programmer cannot develop a concurrent program (Data Race Free (DRF)) that runs correctly on a multiprocessor machine that does not satisfy SC, so what can be done? The processor provides synchronization instructions to the developer. For the developer, a non-SC machine with synchronization instructions has the properties of an SC machine. Only this is not automatic/transparent to the developer anymore, and requires the developer to be familiar with the synchronization instructions and use them correctly in appropriate situations, such as scenarios involving Data Race of data competition, which greatly increases the mental burden of the developer.</p>
<p>Developers usually do not face the hardware directly, which requires high-level programming languages to encapsulate the synchronization instructions provided by the hardware and provide them to developers, which is the <strong>synchronization primitives for programming languages</strong> . And which hardware synchronization instructions the programming language uses, what behavior of the synchronization primitives are encapsulated, how to apply them, examples of incorrect applications, etc. are all required to be explained to the users of the programming language. And these will be part of the programming language memory model documentation.</p>
<p>The memory model of today&rsquo;s mainstream programming languages is the <strong>Sequential Consistency (SC) model</strong> , which provides developers with an ideal SC machine (although in practice the machine is not SC) on which programs are built. But as stated earlier, developers must also understand the synchronization primitives encapsulated by the programming language and their semantics in order to implement a correct concurrent program. <strong>As long as the programmer follows the synchronization requirements of the concurrent program and uses these synchronization primitives wisely, then the concurrent program can be written to run sequentially consistent on non-SC machines</strong>.</p>
<p>Once you know what the programming language memory model means, let&rsquo;s take a look at what the old Go memory model document actually states.</p>
<h3 id="2-go-memory-model-documentation">2. Go Memory Model Documentation</h3>
<p>As stated above, the Go memory model documentation should describe the conditions <strong>that must be met in order to write a correct concurrent program in Go</strong>.</p>
<p>To be more specific, as the old memory model documentation begins: <strong>The Go memory model specifies conditions that, once satisfied, when a variable is read in one goroutine, Go can guarantee that it can observe the new value resulting from a write to the same variable in a different goroutine</strong>.</p>
<p>Next, the memory model documentation gives the various synchronization operations provided by Go and their semantics based on the regular happens-before definition, including.</p>
<ul>
<li>If a package p imports a package q, then the completion of q&rsquo;s init function occurs before the start of any of p&rsquo;s functions.</li>
<li>The start of function main.main occurs after the completion of all init functions.</li>
<li>The go statement that starts a new goroutine occurs before the start of the goroutine&rsquo;s execution.</li>
<li>A send operation on a channel occurs before the corresponding receive operation on that channel completes.</li>
<li>The closing of a channel occurs before a receive that returns a zero value (because the channel is already closed).</li>
<li>A receive on an unbuffered channel occurs before the completion of a send operation on that channel.</li>
<li>The kth receive operation on a channel with capacity C occurs before the completion of the kth+Cth send operation on that channel.</li>
<li>For any sync.Mutex or sync.RWMutex variable l, when n&lt;m, the nth l.Unlock call occurs before the mth call to l.Lock() returns.</li>
<li>The f() call in once.Do(f) occurs before the return of any call to once.Do(f).</li>
</ul>
<p>Next, the memory model document also defines some examples of misuse of the synchronization primitive.</p>
<p>So what exactly has been updated in the new memory model document? Let&rsquo;s move on to the next section.</p>
<h3 id="3-what-has-changed-in-the-revised-memory-model-documentation">3. What has changed in the revised memory model documentation</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/f42d41a8a03a45dba858c7087cfb6f2d.png" alt="Revised memory model documentation"></p>
<p>Russ Cox, who is responsible for updating the memory model documentation, first added the <strong>Go memory model&rsquo;s overall approach</strong> .</p>
<p>The general approach of Go is somewhere between C/C++ and Java/Js, neither defining a program with Data race as illegal like C/C++ and letting the compiler dispose of it with undefined behavior, i.e., exhibiting arbitrary possible behavior at runtime; nor is it exactly like Java/Js, which tries to specify various semantics in the case of Data race, so as to minimize the impact brought by Data race. The impact of data race is limited to a minimum, making the program more reliable.</p>
<p>Go outputs a race report and terminates the program for some cases of data race, such as concurrent reads and writes to a map by multiple goroutines without using synchronization. In addition, Go has explicit semantics for other data race scenarios, which makes the program more reliable and easier to debug.</p>
<p>Secondly, the new Go memory model documentation adds descriptions of the new APIs added to the sync package over the years, such as: mutex.TryLock, mutex.TryRLock and so on. Cond, Map, Pool, WaitGroup, etc. The documentation does not describe them one by one, but suggests looking at the API documentation.</p>
<p>In the old memory model documentation, there was no description of the sync/atom package. The new version of the documentation adds a description of the atom package and runtime.SetFinalizer.</p>
<p>Finally, the documentation adds a description of examples of incorrect compilation in addition to providing examples of incorrect synchronization.</p>
<p>By the way, Go 1.19 introduced some new atomic types in the atomic package, including: Bool, Int32, Int64, Uint32, Uint64, Uintptr and Pointer. these new types make it easier for developers to use the atomic package, for example, the following is a comparison between Go 1.18 and Go 1.19 code comparison using atomic variables of type Uint64.</p>
<p>Compare the two approaches to Uint64.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Go 1.18
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">i</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="nx">atomic</span><span class="p">.</span><span class="nf">AddUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">vs</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Go 1.19
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">i</span> <span class="nx">atomic</span><span class="p">.</span><span class="nx">Uint64</span> <span class="c1">// Default value is 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">i</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span> <span class="c1">// The initial value can also be set via Store
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">i</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">_</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>To fix a violation of this rule, use a consistent style (indentation or code fencing).</p>
<p>The specified style can be specific (<code>fenced</code>, <code>indented</code>) or simply require consistent usage across the document (<code>consistent</code>).</p>
<p>The rationale: consistent formatting makes the document easier to understand.</p>
<p>The new Pointer added to the atomic package avoids the hassle for developers to transform themselves using unsafe.Pointer when using atomic pointers. Pointer is a generic type, and if I remember correctly, it was the first time a generic-based standard library type was introduced into Go after Go 1.18 added comparable predefined generic types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// $GOROOT/src/sync/atomic/type.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// A Pointer is an atomic pointer of type *T. The zero value is a nil *T.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Pointer</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="nx">noCopy</span>
</span></span><span class="line"><span class="cl">    <span class="nx">v</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Load atomically loads and returns the value stored in x.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">Pointer</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Load</span><span class="p">()</span> <span class="o">*</span><span class="nx">T</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">T</span><span class="p">)(</span><span class="nf">LoadPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">.</span><span class="nx">v</span><span class="p">))</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Store atomically stores val into x.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">Pointer</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Store</span><span class="p">(</span><span class="nx">val</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="nf">StorePointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">.</span><span class="nx">v</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Swap atomically stores new into x and returns the previous value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">Pointer</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">new</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">old</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="nx">T</span><span class="p">)(</span><span class="nf">SwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">.</span><span class="nx">v</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">new</span><span class="p">)))</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// CompareAndSwap executes the compare-and-swap operation for x.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">Pointer</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">CompareAndSwap</span><span class="p">(</span><span class="nx">old</span><span class="p">,</span> <span class="nx">new</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="p">(</span><span class="nx">swapped</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">CompareAndSwapPointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">x</span><span class="p">.</span><span class="nx">v</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">old</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">new</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In addition, the new Int64 and Uint64 types of the atomic package have the added quality that Go guarantees that their addresses are automatically aligned to 8 bytes (i.e., the addresses are divisible by 64), even on 32-bit platforms, which is something that <a href="https://github.com/golang/go/issues/36606">even native int64 and uint64 are not yet able to do</a>.</p>
<p><a href="https://go101.org/">go101</a> shared a tip based on atomic Int64 and Uint64 on Twitter. Using the new atomic.Int64/Uint64 in go 1.19, we can guarantee that a field in a structure must be 8 byte aligned in the following way, i.e. the address of the field can be divided by 64.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;sync/atomic&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nx">atomic</span><span class="p">.</span><span class="nx">Int64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">x</span> <span class="kt">uint64</span> <span class="c1">// Ensure that x is 8-byte aligned
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The previous code, why not use <code>_atomic.Int64</code> it, why use an empty array it, it is because the empty array in go does not occupy space, you can try to output the above structure T size, see if it is 8.</p>
<h2 id="3-introduction-of-soft-memory-limit">3. Introduction of Soft memory limit</h2>
<h3 id="1-the-only-gc-tuning-option-gogc">1. The only GC tuning option: GOGC</h3>
<p>In the last few major releases, there have been no major changes/optimizations to Go GC. Compared to other programming languages with GC, Go GC is an oddity: for developers, before Go 1.19, Go GC had only one tuning parameter: <strong>GOGC</strong> (which can also be adjusted via <code>runtime/debug.SetGCPercent</code>).</p>
<p>The default value of GOGC is 100, and by adjusting its value, we can tune the timing of GC triggering. The formula to calculate the heap memory size for the next GC trigger is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Before Go version 1.18
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Target</span> <span class="nx">Heap</span> <span class="nx">Size</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="nx">GOGC</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="nx">live</span> <span class="nx">heap</span> <span class="c1">// live heap is the total size of the live objects on the heap after the last GC mark
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Go version 1.18 and later
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">Target</span> <span class="nx">Heap</span> <span class="nx">Size</span> <span class="p">=</span> <span class="nx">live</span> <span class="nx">heap</span> <span class="o">+</span> <span class="p">(</span><span class="nx">live</span> <span class="nx">heap</span> <span class="o">+</span> <span class="nx">GC</span> <span class="nx">roots</span><span class="p">)</span> <span class="o">*</span> <span class="nx">GOGC</span> <span class="o">/</span> <span class="mi">100</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Go 1.18 onwards incorporates GC roots (including goroutine stack size and size of pointer objects in global variables) into the calculation of target heap size</p>
</blockquote>
<p>Take the version before Go 1.18 as an example, when GOGC=100(default value), if the live heap after a certain GC is 10M, then the target heap heap size opened by the next GC is 20M, that is, between two GCs, the application can allocate 10M new heap objects.</p>
<p>It can be said that <strong>GOGC controls the frequency of GC operation</strong>. When the GOGC value is set to a smaller value, the GC runs more frequently and the proportion of cpu involved in GC work is more; when the GOGC value is set to a larger value, the GC runs less frequently and the proportion of cpu involved in GC work is smaller accordingly, but it has to take the risk that the memory allocation is close to the resource limit.</p>
<p>Thus, the problem in front of the developer is that the value of GOGC is hard to choose, and this only tuning option becomes a poser.</p>
<p>At the same time, Go runtime does not care about the resource limit, it just keeps allocating memory according to the application&rsquo;s needs and requests new memory resources from the OS when its own memory pool is insufficient, until it runs out of memory (or reaches the memory limit allocated to the application by the platform) and is oom killed!</p>
<p>Why is it that with GC, a Go application can still be oom killed by running out of system memory resources? Let&rsquo;s move on to the next section.</p>
<h3 id="2-pacers-problem">2. Pacer&rsquo;s problem</h3>
<p>The above formula for calculating the target heap size for triggering GC is called the pacer algorithm inside Go runtime. pacer is translated into Chinese as &ldquo;pacemaker&rdquo; or &ldquo;pacemaker&rdquo;. Regardless of the translation, in short, it is used to <strong>control the rhythm of GC trigger</strong>.</p>
<p>However, the current algorithm of pacer can not guarantee that your application will not be OOM killed, for example (see the following figure).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/bbf53753e3684fc093ba126220a82289.png" alt="pacer"></p>
<p>In this example.</p>
<ul>
<li>At first the live heap is always smooth, and the net increase in heap objects stays at 0, i.e. the newly allocated heap objects cancel each other out with the heap objects that are cleared out.</li>
<li>A subsequent jump in target heap (from h/2-&gt;h) occurs at (1), apparently because the live heap object becomes too many and they are all in use, and cannot be cleared even if GC is triggered. However, at this point target heap(h) is less than the hard memory limit.</li>
<li>The program continues to execute, and at (2), there is another jump in target heap (from h-&gt;2h), and the live heap object also becomes more and stabilizes at h. At this time, target heap becomes 2h, which is higher than the hard memory limit.</li>
<li>The subsequent program continues to execute, and when the live heap object reaches (3), the actual Go&rsquo;s heap memory (including the uncleared one) exceeds the hard memory limit, but since it has not yet reached the target heap (2h), the GC is not executed, so the application is oom killed.</li>
</ul>
<p>We see that in this example, it is not that the Go application really needs that much memory (the live heap object is at the height of (3) if there is a GC to clean it up in time), <strong>but rather the Pacer algorithm causes the GC not to be triggered in time</strong>.</p>
<p>So how can we avoid oom killed as much as possible? Let&rsquo;s look at the two &ldquo;folk remedies&rdquo; given by the Go community.</p>
<h3 id="3-gc-tuning-solutions-from-the-go-community">3. GC tuning solutions from the Go community</h3>
<p>These two &ldquo;prescriptions&rdquo;, one is <a href="https://es.blog.twitch.tv/tr-tr/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/">memory ballast from twitch games</a>, and the other is <a href="https://www.uber.com/en-US/blog/how-we-saved-70k-cores-across-30-mission-critical-services/">the automatic GC dynamic tuning solution used by big players like uber</a>. Of course these two schemes are not only to avoid oom, but also to optimize GC and improve the efficiency of program execution.</p>
<p>Let&rsquo;s briefly introduce each of them. Let&rsquo;s start with twitch&rsquo;s memory ballast. twitch&rsquo;s Go service runs on a VM with 64G of physical memory, and through observation the operations staff found that the service&rsquo;s resident physical memory consumption was just over 400M, but Go GCs were started very frequently, which resulted in a long response time for the service. twitch&rsquo;s engineers considered fully utilizing memory and reduce the frequency of GC starts, thus reducing the service&rsquo;s response latency.</p>
<p>So they came up with a way to do this by declaring a large 10G slice in the initialization of the service&rsquo;s main function like the following, and ensuring that the slice is not released by GC until the program exits.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Create a large heap allocation of 10 GiB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ballast</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">10</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Application execution continues
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">runtime</span><span class="p">.</span><span class="nf">Keepalive</span><span class="p">(</span><span class="nx">ballast</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This slice, being too large, will be allocated on the heap and tracked by runtime, but this slice does not bring a substantial physical memory consumption to the application, thanks to os&rsquo; <strong>delayed bookkeeping</strong> of the application process memory: only the memory read and written will cause a page out interrupt and have physical memory allocated for it by OS. From a tool like top, these 10 gigabytes will be recorded only on VIRT/VSZ (virtual memory) and not on RES/RSS (resident memory).</p>
<p>In this way, according to the principle of the previous Pacer algorithm, the next target heap size for triggering GC will be at least 20G. GC will not be triggered until the Go service allocates heap memory to 20G, and all cpu resources will be used to handle business, which is also consistent with twitch&rsquo;s actual test results (99% drop in GC count).</p>
<p>Once it reaches 20G, since the previous observation is that the service only needs 400+M physical memory, a lot of heap objects will be recycled and the Go service&rsquo;s live heap will go back to 400+M, but when the target heap memory is recalculated, the target heap memory will already be at least 20G due to the presence of the previous &ldquo;ballast&rdquo;. When the target heap memory is recalculated, the target heap memory will already be at least 20G, so there will be less GCs, less GCs, less time for the worker goroutine to participate in &ldquo;labor&rdquo;, higher cpu utilization, and lower latency of service response.</p>
<blockquote>
<p>The &ldquo;labor&rdquo; refers to the worker goroutine being forced to &ldquo;labor&rdquo; by the runtime when mallocgc memory: stopping its task at hand to assist the GC in doing the mark of the heap live object.</p>
</blockquote>
<p>However, the prerequisite for using this scheme is that you have an accurate knowledge of your Go service&rsquo;s memory consumption (busy and idle times) so that you can set a reasonable ballast value in conjunction with your hardware resources.</p>
<p>According to <a href="https://github.com/golang/proposal/blob/master/design/48409-soft-memory-limit.md">Soft memory limit proposal</a>, the drawbacks of this solution are as follows.</p>
<ul>
<li>Cannot be ported across platforms and is said to be inapplicable on Windows (the value of ballast would be directly reflected as the physical memory footprint of the application).</li>
<li>No guarantee that it will continue to work properly as the Go runtime evolves (e.g., once the pacer algorithm has changed dramatically).</li>
<li>Developers need to perform complex calculations and estimate runtime memory overhead to choose the right ballast size.</li>
</ul>
<p>Next, let&rsquo;s take a look at the automated GC dynamic tuning scheme.</p>
<p>Last December, uber shared on its official blog the <a href="https://www.uber.com/en-US/blog/how-we-saved-70k-cores-across-30-mission-critical-services/">semi-automated Go GC tuning scheme</a> used internally by uber , according to uber, the implementation of this scheme helped uber save 70K cpu cores of computing power. The principle behind it is still based on Pacer&rsquo;s algorithm formula, changing the original practice of keeping the GOGC value static throughout the life cycle of Go services, and dynamically calculating and setting the GOGC value based on the memory limit of the container and the current live heap size at each GC, so as to achieve the protection of memory shortage oom-killed, while maximizing the utilization of The GOGC value is dynamically calculated and set based on the memory limit of the container and the current live heap size.</p>
<p>Obviously this solution is more complex and requires a team of experts to ensure the setting of parameters and implementation of this auto-tuning solution.</p>
<h3 id="4-introducing-soft-memory-limit">4. Introducing Soft memory limit</h3>
<p>In fact, there are many more Go GC pacer problems, and Go core team developer Michael Knyszek has submitted a pacer problem <a href="https://github.com/golang/go/issues/42430">overview issue that summarizes these problems</a>. But the problems need to be solved one by one, in this version of Go 1.19, Michael Knyszek has brought his solution <a href="https://github.com/golang/proposal/blob/master/design/48409-soft-memory-limit.md">Soft memory limit</a>.</p>
<p>This solution adds a function called SetMemoryLimit and the <code>GOMEMLIMIT</code> environment variable to the <code>runtime/debug</code> package, either of which can set the Memory limit of a Go application.</p>
<p>Once the Memory limit is set, a GC round will be triggered when the Go heap size reaches the &ldquo;Memory limit minus non-heap memory&rdquo;. Even if you manually turn off GC (GOGC=off), GC will be triggered.</p>
<p>As we can see by the principle, this feature is the most direct solution to the oom-killed problem! Just like the example in the pacer problem diagram, if we set a soft memory limit that is smaller than the hard memory limit, then oom-killed will not occur at point (3) because the soft memory limit will trigger a GC before then, and some useless heap memory is reclaimed.</p>
<p>But we should also note that soft memory limit does not guarantee that oom-killed will not occur, which is also well understood. If the live heap object reaches the limit, it means that your application memory resources are really not enough, and it is time to expand the memory stick resources, which is a problem that GC can&rsquo;t solve anyway.</p>
<p>However, if a Go application&rsquo;s live heap object exceeds the soft memory limit but has not yet been killed, then the GC will be triggered continuously, but to ensure that business can still continue in this case, the soft memory limit scheme ensures that the GC will only use up to 50% of the CPU power to ensure that business processing still get cpu resources.</p>
<p>For the case that GC triggers frequently and the GC frequency should be reduced, the soft memory limit scheme is <strong>shutdown GC(GOGC=off)</strong>, so that GC will be triggered only when the heap memory reaches the soft memory limit value, which can improve cpu utilization. There is one case though, which is not recommended in <a href="https://go.dev/doc/gc-guide">Go&rsquo;s official GC guide</a>, and that is when your Go program is sharing some limited memory with other programs. At that point it is sufficient to keep the memory limit and set it to a smaller reasonable value, as it may help to suppress undesirable transient behavior.</p>
<p>So what is a reasonable value for the soft memory limit? A good rule of thumb when it comes to Go services monopolizing container resources is to leave an extra 5-10% to account for memory sources unknown to the Go runtime. uber&rsquo;s limit set in his blog at 70% of the resource limit is also a good rule of thumb.</p>
<h2 id="4-summary">4. Summary</h2>
<p>Maybe Go 1.19 doesn&rsquo;t bring you many surprises due to the compressed development cycle. But the features, though few, are very useful, such as the soft memory limit above, which once used well, can help solve big problems.</p>
<p>Go 1.20, which has a normal development cycle, is already under active development. From the features and improvements planned in the current <a href="https://github.com/golang/go/milestone/250">milestone</a>, the Go generic syntax will be further complemented and will move towards the full version, so it&rsquo;s worth waiting for that!</p>
<h2 id="5-reference">5. Reference</h2>
<ul>
<li><code>https://research.swtch.com/mm</code></li>
<li><code>https://github.com/golang/go/discussions/47141</code></li>
<li><code>https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs</code></li>
<li><code>https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf</code></li>
<li><code>https://people.eecs.berkeley.edu/~kubitron/courses/cs258-S08/handouts/papers/adve-isca90.pdf</code></li>
<li><code>https://www.hpl.hp.com/techreports/2008/HPL-2008-56.pdf</code></li>
<li><code>https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit</code></li>
<li><code>https://tonybai.com/2022/08/22/some-changes-in-go-1-19/</code></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/raft/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Principles of Raft, a distributed consistency protocol</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/argo-rollouts/">
            <span class="next-text nav-default">Implementing Progressive Release with Argo Rollouts</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
