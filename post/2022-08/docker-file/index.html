<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Customizing images with Dockerfile - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article is a detailed explanation of Docker custom images, how to build your own Docker images, and the Dockerfile instructions." /><meta name="keywords" content="Dockerfile" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/docker-file/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Customizing images with Dockerfile" />
<meta property="og:description" content="This article is a detailed explanation of Docker custom images, how to build your own Docker images, and the Dockerfile instructions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/docker-file/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-02T12:23:28+08:00" />
<meta property="article:modified_time" content="2022-08-02T12:23:28+08:00" />

<meta itemprop="name" content="Customizing images with Dockerfile">
<meta itemprop="description" content="This article is a detailed explanation of Docker custom images, how to build your own Docker images, and the Dockerfile instructions."><meta itemprop="datePublished" content="2022-08-02T12:23:28+08:00" />
<meta itemprop="dateModified" content="2022-08-02T12:23:28+08:00" />
<meta itemprop="wordCount" content="5468">
<meta itemprop="keywords" content="docker," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Customizing images with Dockerfile"/>
<meta name="twitter:description" content="This article is a detailed explanation of Docker custom images, how to build your own Docker images, and the Dockerfile instructions."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Customizing images with Dockerfile</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-02 12:23:28 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 5468 words </span>
          <span class="more-meta"> 26 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#i-using-dockerfile-to-customize-images">I. Using Dockerfile to customize images</a>
          <ul>
            <li><a href="#11-dockerfile-customization-image">1.1, Dockerfile customization image</a></li>
            <li><a href="#12from-specify-the-base-image">1.2、FROM Specify the base image</a></li>
            <li><a href="#13run-execute-command">1.3、RUN Execute command</a></li>
            <li><a href="#14-building-the-image">1.4. Building the image</a></li>
            <li><a href="#15-image-build-context-context">1.5, image build context (Context)</a></li>
            <li><a href="#16-other-uses-of-docker-build">1.6. Other uses of docker build</a></li>
          </ul>
        </li>
        <li><a href="#ii-dockerfile-directives">II. Dockerfile directives</a>
          <ul>
            <li><a href="#21-copy">2.1, COPY</a></li>
            <li><a href="#22add">2.2、ADD</a></li>
            <li><a href="#23-cmd">2.3, CMD</a></li>
            <li><a href="#24-entrypoint">2.4, ENTRYPOINT</a></li>
            <li><a href="#25-env">2.5, ENV</a></li>
            <li><a href="#26-volume">2.6. VOLUME</a></li>
            <li><a href="#27-expose">2.7. EXPOSE</a></li>
            <li><a href="#28-workdir">2.8, WORKDIR</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>This article is a detailed explanation of Docker custom images, how to build your own Docker images, and the Dockerfile instructions.</p>
<h2 id="i-using-dockerfile-to-customize-images">I. Using Dockerfile to customize images</h2>
<h3 id="11-dockerfile-customization-image">1.1, Dockerfile customization image</h3>
<p>Customization of images is actually customizing the configuration and files added to each layer. If we can write a script for each layer to modify, install, build, and operate the commands, and use this script to build and customize the image, the problem of not being able to repeat, the problem of transparency of image construction, and the problem of volume will all be solved. This script is <code>Dockerfile</code>.</p>
<p>A <code>Dockerfile</code> is a text file that contains a set of instructions, each of which builds a layer, so the content of each instruction describes how that layer should be built.</p>
<p>Let&rsquo;s take the <code>nginx</code> image as an example, this time we use <code>Dockerfile</code> to customize it.</p>
<p>In a blank directory, create a text file and name it <code>Dockerfile</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ mkdir mynginx
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> mynginx
</span></span><span class="line"><span class="cl">$ touch Dockerfile
</span></span></code></pre></td></tr></table>
</div>
</div><p>The contents are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">FROM nginx
</span></span><span class="line"><span class="cl">RUN <span class="nb">echo</span> <span class="s1">&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span> &gt; /usr/share/nginx/html/index.html
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>Dockerfile</code> is very simple, just two lines in total. It involves two directives, <code>FROM</code> and <code>RUN</code>.</p>
<h3 id="12from-specify-the-base-image">1.2、FROM Specify the base image</h3>
<p>The so-called custom image, that must be based on an image, on which to customize. Just like we ran a <code>nginx</code> image of the container before, and then modify it, the base image must be specified. And <code>FROM</code> is to specify the <strong>base image</strong>, so <code>FROM</code> is a required directive in a <code>Dockerfile</code>, and must be the first directive.</p>
<p>There are many high-quality official images on the <code>Docker Store</code>, including service images that can be used directly, such as <code>nginx</code>, <code>redis</code>, <code>mongo</code>, <code>mysql</code>, <code>httpd</code>, <code>php</code>, <code>tomcat</code>, etc. There are also images for developing, building, and running applications in various languages, such as <code>node</code>, <code>openjdk</code>, <code>python</code>, <code>ruby</code>, <code>golang</code> and so on. It is possible to find a image among them that best matches our ultimate goal as the base image for customization.</p>
<p>If you do not find a image that corresponds to the service, the official images also provide some more basic operating system images, such as <code>ubuntu</code>, <code>debian</code>, <code>centos</code>, <code>fedora</code>, <code>alpine</code>, etc. The software libraries of these operating systems provide us with a broader scope for expansion.</p>
<p>In addition to choosing existing images as the base image, <code>Docker</code> also has a special image called <code>scratch</code>. This image is a virtual concept and does not actually exist; it represents a blank image.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> scratch</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>If you use <code>scratch</code> as the base image, that means you don&rsquo;t base it on any image, and the next instructions written will exist as the first layer of the image to begin with.</p>
</blockquote>
<p>It is not uncommon to copy executables directly into images without any system base, e.g. <code>swarm</code>, <code>coreos/etcd</code>. For statically compiled programs on Linux, there is no need to have runtime support from the operating system, and all the libraries needed are already in the executable, so directly <code>FROM scratch</code> makes the image much smaller. Many applications developed in Go use this way to create images, which is one of the reasons why some people consider <code>Go</code> to be a particularly suitable language for container microservices architectures.</p>
<h3 id="13run-execute-command">1.3、RUN Execute command</h3>
<p>The <code>RUN</code> command is used to execute command line commands. Due to the power of the command line, the <code>RUN</code> command is one of the most common commands used when customizing images. It comes in two formats.</p>
<ul>
<li>
<p><em>shell</em> format: <code>RUN &lt;command&gt;</code>, which is like a command typed directly from the command line. The <code>RUN</code> command in <code>Dockerfile</code> that I just wrote is in this format.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">RUN <span class="nb">echo</span> <span class="s1">&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span> &gt; /usr/share/nginx/html/index.html
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><em>exec</em> format: <code>RUN [&quot;executable&quot;, &quot;argument1&quot;, &quot;argument2&quot;]</code>, which is more like the format used in function calls.</p>
</li>
</ul>
<p>Since <code>RUN</code> can execute commands just like <code>Shell</code> scripts, can we have a <code>RUN</code> for each command just like <code>Shell</code> scripts? For example, like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> debian:jessie</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get install -y gcc libc6-dev make<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> wget -O redis.tar.gz <span class="s2">&#34;http://download.redis.io/releases/redis-3.2.5.tar.gz&#34;</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> mkdir -p /usr/src/redis<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span class="o">=</span><span class="m">1</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> make -C /usr/src/redis<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> make -C /usr/src/redis install<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>As I said before, every command in <code>Dockerfile</code> creates a layer, and <code>RUN</code> is no exception. The behavior of each <code>RUN</code> is the same as the process we just used to create the image manually: create a new layer, execute the commands on it, and after that, <code>commit</code> the changes on that layer to form a new image.</p>
<p>The way it&rsquo;s written above, it creates 7 layers of images. This is completely pointless, and a lot of things that are not needed at runtime are loaded into the image, such as compiled environments, updated packages, and so on. The result is a very bloated, multi-layered image that not only increases the time to build and deploy, but is also error-prone. This is a common mistake that many people who are new to <code>Docker</code> make.</p>
<p><em>There is a maximum number of layers in <code>Union FS</code>, such as <code>AUFS</code>, which used to have a maximum of 42 layers and now has a maximum of 127 layers.</em></p>
<p>The correct way to write the above <code>Dockerfile</code> would be as follows:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> debian:jessie</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> <span class="nv">buildDeps</span><span class="o">=</span><span class="s1">&#39;gcc libc6-dev make&#39;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> apt-get update <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> apt-get install -y <span class="nv">$buildDeps</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> wget -O redis.tar.gz <span class="s2">&#34;http://download.redis.io/releases/redis-3.2.5.tar.gz&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> mkdir -p /usr/src/redis <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span class="o">=</span><span class="m">1</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> make -C /usr/src/redis <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> make -C /usr/src/redis install <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/* <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> rm redis.tar.gz <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> rm -r /usr/src/redis <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> apt-get purge -y --auto-remove <span class="nv">$buildDeps</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>First, all the previous commands have only one purpose, to compile and install the <code>Redis</code> executable. So there is no need to create many layers, this is just one layer. So, instead of using many <code>RUN</code> pairs corresponding to different commands, there is just one <code>RUN</code> command, and <code>&amp;&amp;</code> to concatenate all the required commands. This simplifies the previous 7 layers to 1 layer. When writing a <code>Dockerfile</code>, always remind yourself that you are not writing a <code>Shell</code> script, but rather defining how each layer should be built.</p>
<p>And, there are line breaks for formatting purposes. <code>Dockerfile</code> supports a command line feed with <code>\</code> at the end of the line for Shell classes, and a comment format with <code>#</code> at the beginning of the line. Good formatting, such as line breaks, indentation, comments, etc., will make maintenance and troubleshooting easier, which is a better habit.</p>
<p>Also, you can see the cleanup command added at the end of this set of commands, which removes the software needed in order to compile the build, cleans up all downloaded and expanded files, and also cleans up the <code>apt</code> cache file. This is a very important step, as we said before, images are multi-layer storage, and things on each layer are not deleted at the next layer, they stay with the image. So when building the image, make sure that you only add what you really need to add at each layer, and that anything extraneous is cleaned up.</p>
<p>One of the reasons why many people who are new to <code>Docker</code> create bloated images is that they forget to clean up extraneous files at the end of each build.</p>
<h3 id="14-building-the-image">1.4. Building the image</h3>
<p>Let&rsquo;s go back to the <code>Dockerfile</code> of the custom <code>Nginx</code> image we made earlier. Now that we understand the contents of the <code>Dockerfile</code>, let&rsquo;s build the image.</p>
<p>Execute the following command in the directory where the <code>Dockerfile</code> file is located.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker build -t nginx:v3 .
</span></span><span class="line"><span class="cl">Sending build context to Docker daemon 2.048 kB
</span></span><span class="line"><span class="cl">Step <span class="m">1</span> : FROM nginx
</span></span><span class="line"><span class="cl"> ---&gt; e43d811ce2f4
</span></span><span class="line"><span class="cl">Step <span class="m">2</span> : RUN <span class="nb">echo</span> <span class="s1">&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span> &gt; /usr/share/nginx/html/index.html
</span></span><span class="line"><span class="cl"> ---&gt; Running in 9cdc27646c7b
</span></span><span class="line"><span class="cl"> ---&gt; 44aa4490ce2c
</span></span><span class="line"><span class="cl">Removing intermediate container 9cdc27646c7b
</span></span><span class="line"><span class="cl">Successfully built 44aa4490ce2c
</span></span></code></pre></td></tr></table>
</div>
</div><p>From the output of the command, we can clearly see how the image was built. In <code>Step 2</code>, as we said before, the <code>RUN</code> command starts a container <code>9cdc27646c7b</code>, executes the requested command, and finally commits the layer <code>44aa4490ce2c</code>, and then deletes the used container <code>9cdc27646c7b</code>.</p>
<p>Here we used the <code>docker build</code> command to build the image. The format is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">docker build <span class="o">[</span>options<span class="o">]</span> &lt;context path/URL/-&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here we specify the name of the final image <code>-t nginx:v3</code>, and after a successful build, we can run this image as we did <code>nginx:v2</code> before, and the result will be the same as <code>nginx:v2</code>.</p>
<h3 id="15-image-build-context-context">1.5, image build context (Context)</h3>
<p>If you pay attention, you will see that the <code>docker build</code> command ends with a <code>.</code>, <code>.</code> means the current directory, and <code>Dockerfile</code> is in the current directory, so many beginners think that this path is specifying the path where <code>Dockerfile</code> is located, which is actually inaccurate. If you look at the command format above, you will probably find that it is specifying <strong>context path</strong>. So what is context?</p>
<p>First we need to understand how <code>docker build</code> works. <code>Docker</code> is divided at runtime into the <code>Docker</code> engine (also known as the server daemon) and the client tools. The <code>Docker</code> engine provides a set of REST APIs, called the <code>Docker Remote API</code>, and client tools like the <code>docker</code> command interact with the <code>Docker</code> engine through this set of <code>API</code>s to perform various functions. So, although it seems that we are executing various <code>docker</code> functions locally, in reality, everything is done on the server side (the <code>Docker</code> engine) using remote calls. This <code>C/S</code> design also makes it easy to manipulate the <code>Docker</code> engine on the remote server.</p>
<p>When we build an image, not all customizations are done with the <code>RUN</code> command, but often some local files are copied into the image, for example, with the <code>COPY</code> command, the <code>ADD</code> command, and so on. The <code>docker build</code> command builds the image, not locally, but on the server side, i.e. in the <code>Docker</code> engine. So in this client/server architecture, how can the server get the local files?</p>
<p>This introduces the concept of context. When building, the user specifies the path to the build image context, and the <code>docker build</code> command learns this path, packages everything under it, and uploads it to the <code>Docker</code> engine. Once the <code>Docker</code> engine receives the context package, it expands it and gets all the files it needs to build the image.</p>
<p>If you write this in the <code>Dockerfile</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">COPY</span> ./package.json /app/<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This is not a copy of <code>package.json</code> in the directory where the <code>docker build</code> command was executed, nor is it a copy of <code>package.json</code> in the directory where <code>Dockerfile</code> is located, but a copy of <code>package.json</code> in the <strong>context</strong> directory.</p>
<p>Therefore, the paths to the source files in commands like <code>COPY</code> are *<em>relative paths</em>. This is why beginners often ask why <code>COPY ... /package.json /app</code> or <code>COPY /opt/xxxx /app</code> does not work, because those paths are out of context and the Docker engine cannot get the files in those locations. If you really need those files, you should copy them to the context directory.</p>
<p>Now you can understand the command <code>docker build -t nginx:v3 .</code> in this <code>.</code>, you are actually specifying the context directory where the <code>docker build</code> command will package the contents of that directory to the Docker engine to help build the image.</p>
<p>If we look at the <code>docker build</code> output, we have actually seen this process of sending a context.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker build -t nginx:v3 .
</span></span><span class="line"><span class="cl">Sending build context to Docker daemon 2.048 kB
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>Understanding the build context is important for image building to avoid making mistakes you shouldn&rsquo;t make. For example, some beginners find that <code>COPY /opt/xxxx /app</code> doesn&rsquo;t work, so they simply put <code>Dockerfile</code> in the root of their hard drive to build it, only to find that <code>docker build</code> executes and sends a few dozen <code>GB</code> of stuff, which is extremely slow and prone to build failure. That&rsquo;s because this approach is asking <code>docker build</code> to pack the entire hard drive, which is clearly a misuse.</p>
<p>In general, you should put <code>Dockerfile</code> in an empty directory, or in the root of the project. If there are no required files in that directory, then you should make a copy of the required files. If there are things in the directory that you really don&rsquo;t want to pass to the Docker engine at build time, then you can write a <code>.dockerignore</code> with the same syntax as <code>.gitignore</code>, which is used to weed out files that don&rsquo;t need to be passed to the Docker engine as context.</p>
<p>So why would anyone mistakenly think that <code>.</code> is to specify the directory where the <code>Dockerfile</code> is located? This is because by default, if you don&rsquo;t specify <code>Dockerfile</code> additionally, a file named <code>Dockerfile</code> in the context directory will be used as the Dockerfile.</p>
<p>This is only the default behavior, in fact the filename of <code>Dockerfile</code> is not required to be <code>Dockerfile</code>, and it is not required to be located in the context directory, for example you can use <code>-f . /Dockerfile.php</code> parameter to specify a file as a <code>Dockerfile</code>.</p>
<p>Of course, it is customary to use the default filename <code>Dockerfile</code> and to place it in the image build context directory.</p>
<h3 id="16-other-uses-of-docker-build">1.6. Other uses of docker build</h3>
<h4 id="161-building-directly-from-the-git-repo">1.6.1. Building directly from the Git repo</h4>
<p><code>docker build</code> also supports building from a <code>URL</code>, for example, you can build directly from the <code>Git repo</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14
</span></span><span class="line"><span class="cl">docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="se">\#</span>:8.14
</span></span><span class="line"><span class="cl">Sending build context to Docker daemon 2.048 kB
</span></span><span class="line"><span class="cl">Step <span class="m">1</span> : FROM gitlab/gitlab-ce:8.14.0-ce.0
</span></span><span class="line"><span class="cl">8.14.0-ce.0: Pulling from gitlab/gitlab-ce
</span></span><span class="line"><span class="cl">aed15891ba52: Already exists
</span></span><span class="line"><span class="cl">773ae8583d14: Already exists
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>This command specifies the <code>Git repo</code> required for the build, and specifies the default <code>master</code> branch and the build directory as <code>/8.14/</code>, then Docker will go to the <code>git clone</code> project itself, switch to the specified branch, and go to the specified directory and start the build.</p>
<h4 id="162-build-with-the-given-tarball">1.6.2. Build with the given tarball</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker build http://server/context.tar.gz
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the URL given is not a <code>Git repo</code> but a <code>tar</code> archive, then the <code>Docker</code> engine will download the archive, unpack it automatically, and use it as a context to start the build.</p>
<h4 id="163-reading-a-dockerfile-from-standard-input-for-a-build">1.6.3. Reading a Dockerfile from standard input for a build</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">docker build - &lt; Dockerfile
</span></span></code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">cat Dockerfile <span class="p">|</span> docker build -
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the standard input is passed in as a text file, it is treated as a <code>Dockerfile</code> and the build begins. This form has no context since it reads the contents of the <code>Dockerfile</code> directly from the standard input, so it is not possible to do things like <code>COPY</code> the local file into the image like other methods can.</p>
<h4 id="164-read-the-contextual-zip-package-from-the-standard-input-for-construction">1.6.4, read the contextual zip package from the standard input for construction</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker build - &lt; context.tar.gz
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the standard input file format is <code>gzip</code>, <code>bzip2</code> and <code>xz</code>, it will be made a contextual archive, expand it directly, treat it as a context, and start building.</p>
<h2 id="ii-dockerfile-directives">II. Dockerfile directives</h2>
<p>We have already introduced <code>FROM</code>, <code>RUN</code>, and also mentioned <code>COPY</code>, <code>ADD</code>, in fact <code>Dockerfile</code> is very powerful, it provides more than ten directives. Let&rsquo;s continue to explain the other directives.</p>
<h3 id="21-copy">2.1, COPY</h3>
<p>Format.</p>
<ul>
<li>
<p><code>COPY &lt;source path&gt;... &lt;target path&gt;</code></p>
</li>
<li>
<p><code>COPY [&quot;&lt;source path1&gt;&quot;,... &quot;&lt;target path&gt;&quot;]</code></p>
</li>
</ul>
<p>Like the <code>RUN</code> command, there are two formats, one similar to a command line and one similar to a function call.</p>
<p>The <code>COPY</code> command copies files/directories from the <code>&lt;source path&gt;</code> in the build context directory to the <code>&lt;target path&gt;</code> location within the image of the new layer. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">COPY</span> package.json /usr/src/app/<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>&lt;source path&gt;</code> can be multiple, or even wildcards, with wildcard rules that satisfy <code>Go</code>&rsquo;s <code>filepath.Match</code> rule, e.g.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">COPY</span> hom* /mydir/<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">COPY</span> hom?.txt /mydir/<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>&lt;target path&gt;</code> can be either an absolute path within the container or a relative path to the working directory (the working directory can be specified with the <code>WORKDIR</code> command). The target path does not need to be created beforehand, if the directory does not exist, the missing directory will be created before copying the file.</p>
<p>It is also important to note that with the <code>COPY</code> command, all metadata of the source file is preserved. For example, read, write, execute permissions, file change time, etc. This feature is useful for image customization. Especially if the build-related files are being managed using <code>Git</code>.</p>
<h3 id="22add">2.2、ADD</h3>
<p>The format and nature of the <code>ADD</code> command is basically the same as that of <code>COPY</code>. But it adds some features to <code>COPY</code>.</p>
<p>For example, <code>&lt;source path&gt;</code> can be a <code>URL</code>, in which case the Docker engine will try to download the linked file to <code>&lt;destination path&gt;</code>. The downloaded file permissions are automatically set to <code>600</code>, and if this is not the desired permissions, then an additional layer of <code>RUN</code> will be added to adjust the permissions. So it makes more sense to just use the <code>RUN</code> command and then use the <code>wget</code> or <code>curl</code> tool to download, handle permissions, unzip, and then clean up the useless files. Therefore, this feature is not really practical and is not recommended.</p>
<p>If <code>&lt;source&gt;</code> is a <code>tar</code> zip file in <code>gzip</code>, <code>bzip2</code> or <code>xz</code> format, the <code>ADD</code> command will automatically decompress the zip file to <code>&lt;destination&gt;</code>.</p>
<p>This is useful in some cases, such as in the official image <code>ubuntu</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> scratch</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ADD</span> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>However, in some cases, if we really want to copy a zip file without unzipping it, we can&rsquo;t use the <code>ADD</code> command.</p>
<p>The official <code>Dockerfile best practices document</code> asks to use <code>COPY</code> whenever possible, because the semantics of <code>COPY</code> are clear: it&rsquo;s just copying a file, while <code>ADD</code> contains more complex functionality and its behavior is not always clear. The most suitable situation for using <code>ADD</code> is the one mentioned, where automatic decompression is required.</p>
<p>Also note that the <code>ADD</code> command will invalidate the image build cache, which may make image builds slower.</p>
<p>Therefore, when choosing between the <code>COPY</code> and <code>ADD</code> directives, you can follow the principle of using the <code>COPY</code> directive for all file copying, and using <code>ADD</code> only when automatic decompression is required.</p>
<h3 id="23-cmd">2.3, CMD</h3>
<p>The format of the <code>CMD</code> command is similar to that of <code>RUN</code>, which is also in two formats.</p>
<ul>
<li><code>shell</code> format: <code>CMD &lt;command&gt;</code></li>
<li><code>exec</code> format: <code>CMD [&quot;executable&quot;, &quot;parameter1&quot;, &quot;parameter2&quot;...]</code></li>
<li>Parameter list format: <code>CMD [&quot;parameter1&quot;, &quot;parameter2&quot;...]</code>. After specifying the <code>ENTRYPOINT</code> directive, specify the specific parameters with <code>CMD</code>.</li>
</ul>
<p>As we said before when introducing containers, Docker is not a virtual machine, containers are processes. Since it is a process, when you start the container, you need to specify the program and parameters to run. The <code>CMD</code> command is used to specify the default container main process start command.</p>
<p>For example, the default <code>CMD</code> for the <code>ubuntu</code> image is <code>/bin/bash</code>. If we run <code>docker run -it ubuntu</code>, we will go directly to <code>bash</code>. We can also specify another command to run at runtime, such as <code>docker run -it ubuntu cat /etc/os-release</code>. This replaces the default <code>/bin/bash</code> command with the <code>cat /etc/os-release</code> command, which outputs the system version information.</p>
<p>In terms of command format, the <code>exec</code> format is recommended. This format will be parsed as a <code>JSON</code> array, so be sure to use double quotes <code>&quot;</code> instead of single quotes.</p>
<p>If you use the <code>shell</code> format, the actual command will be wrapped as a <code>sh -c</code> argument. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">CMD</span> <span class="nb">echo</span> <span class="nv">$HOME</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>In the actual implementation, this will be changed to</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">CMD</span> <span class="p">[</span> <span class="s2">&#34;sh&#34;</span><span class="p">,</span> <span class="s2">&#34;-c&#34;</span><span class="p">,</span> <span class="s2">&#34;echo $HOME&#34;</span> <span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This is why we can use environment variables, because they are parsed by the shell.</p>
<p>Speaking of <code>CMD</code>, we have to mention the issue of foreground and background execution of applications in containers. This is a common confusion for beginners.</p>
<p>Docker is not a virtual machine, applications in containers should be executed in the foreground, not like virtual machines or physical machines, using <code>upstart/systemd</code> to start background services, there is no concept of background services in containers.</p>
<p>Some beginners write <code>CMD</code> as.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">CMD</span> service nginx start<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Then I found that the container exited immediately after execution. Even inside the container to use the <code>systemctl</code> command but found that it does not execute at all. This is because they do not understand the concept of foreground and background, do not distinguish the difference between containers and virtual machines, still in the traditional virtual machine perspective to understand the container.</p>
<p>For the container, its startup program is the container application process, the container is for the main process and exists, the main process exit, the container will lose the meaning of existence, and thus exit, other auxiliary processes are not something it needs to care about.</p>
<p>Using the <code>service nginx start</code> command, you want upstart to start the <code>nginx</code> service as a background daemon. And as I said earlier <code>CMD service nginx start</code> will be interpreted as <code>CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>, so the primary process is actually <code>sh</code>. Then when the <code>service nginx start</code> command finishes, <code>sh</code> also finishes, and <code>sh</code> exits as the master process, which naturally causes the container to exit.</p>
<p>The correct way to do this is to execute the <code>nginx</code> executable directly and require it to be run as a foreground. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;nginx&#34;</span><span class="p">,</span> <span class="s2">&#34;-g&#34;</span><span class="p">,</span> <span class="s2">&#34;daemon off;&#34;</span><span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="24-entrypoint">2.4, ENTRYPOINT</h3>
<p>The format of <code>ENTRYPOINT</code> is the same as that of the <code>RUN</code> command, which is divided into <code>exec</code> format and <code>shell</code> format.</p>
<p>The purpose of <code>ENTRYPOINT</code> is the same as <code>CMD</code>, it is to start the program and parameters in the specified container. <code>ENTRYPOINT</code> can also be substituted at runtime, but is slightly more cumbersome than <code>CMD</code> and needs to be specified via the <code>-entrypoint</code> argument to <code>docker run</code>.</p>
<p>When <code>ENTRYPOINT</code> is specified, the meaning of <code>CMD</code> changes and instead of running its command directly, the contents of <code>CMD</code> are passed as an argument to the <code>ENTRYPOINT</code> command, in other words, when actually executed, it becomes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl">&lt;ENTRYPOINT&gt; <span class="s2">&#34;&lt;CMD&gt;&#34;</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>So why do we need <code>ENTRYPOINT</code> after we have <code>CMD</code>? Is there any benefit to this <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code>? Let&rsquo;s look at a few scenarios.</p>
<h4 id="241-scenario-1-make-the-image-look-like-a-command">2.4.1, Scenario 1: Make the image look like a command</h4>
<p>Suppose we need a image that knows our current public <code>IP</code>, then we can start with <code>CMD</code> to achieve.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> ubuntu:16.04</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> apt-get install -y curl <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/*<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="p">[</span> <span class="s2">&#34;curl&#34;</span><span class="p">,</span> <span class="s2">&#34;-s&#34;</span><span class="p">,</span> <span class="s2">&#34;http://ip.cn&#34;</span> <span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If we use <code>docker build -t myip .</code> to build the image, if we need to query the current public IP, we just need to run</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker run myip
</span></span><span class="line"><span class="cl">....
</span></span></code></pre></td></tr></table>
</div>
</div><p>So it looks like we can use the image as a command, but there are always parameters to the command, what if we want to add parameters? For example, as you can see from the <code>CMD</code> above, the actual command is <code>curl</code>, so if we want to display HTTP headers, we need to add the <code>-i</code> argument. Can we just add the <code>-i</code> argument to <code>docker run myip</code>?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker run myip -i
</span></span><span class="line"><span class="cl">docker: Error response from daemon: invalid header field value <span class="s2">&#34;oci runtime error: container_linux.go:247: starting container process caused \&#34;exec: \\\&#34;-i\\\&#34;: executable file not found in </span><span class="nv">$PATH</span><span class="s2">\&#34;\n&#34;</span>.
</span></span></code></pre></td></tr></table>
</div>
</div><p>We can see the error that the executable file is not found, <code>executable file not found</code>. As we said before, the image name is followed by <code>command</code>, which replaces the default value of <code>CMD</code> when run. So here <code>-i</code> replaces the original <code>CMD</code>, instead of being added after the original <code>curl -s http://ip.cn</code>. And <code>-i</code> is not a command at all, so naturally it is not found.</p>
<p>So if we want to add the <code>-i</code> parameter, we have to retype the command in its entirety.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker run myip curl -s http://ip.cn -i
</span></span></code></pre></td></tr></table>
</div>
</div><p>This is obviously not a very good solution, and using <code>ENTRYPOINT</code> solves the problem. Now let&rsquo;s reuse <code>ENTRYPOINT</code> to implement this image.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> ubuntu:16.04</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> apt-get update <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> apt-get install -y curl <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/*<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENTRYPOINT</span> <span class="p">[</span> <span class="s2">&#34;curl&#34;</span><span class="p">,</span> <span class="s2">&#34;-s&#34;</span><span class="p">,</span> <span class="s2">&#34;http://ip.cn&#34;</span> <span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This time let&rsquo;s try it again directly with <code>docker run myip -i</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker run myip
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ docker run myip -i
</span></span><span class="line"><span class="cl">HTTP/1.1 <span class="m">200</span> OK
</span></span><span class="line"><span class="cl">Server: nginx/1.8.0
</span></span><span class="line"><span class="cl">Date: Tue, <span class="m">22</span> Nov <span class="m">2016</span> 05:12:40 GMT
</span></span><span class="line"><span class="cl">Content-Type: text/html<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
</span></span><span class="line"><span class="cl">Vary: Accept-Encoding
</span></span><span class="line"><span class="cl">X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
</span></span><span class="line"><span class="cl">X-Cache: MISS from cache-2
</span></span><span class="line"><span class="cl">X-Cache-Lookup: MISS from cache-2:80
</span></span><span class="line"><span class="cl">X-Cache: MISS from proxy-2_6
</span></span><span class="line"><span class="cl">Transfer-Encoding: chunked
</span></span><span class="line"><span class="cl">Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006
</span></span><span class="line"><span class="cl">Connection: keep-alive
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>As you can see, it worked this time. This is because when <code>ENTRYPOINT</code> exists, the contents of the <code>CMD</code> will be passed as an argument to <code>ENTRYPOINT</code>, and here <code>-i</code> is the new <code>CMD</code>, so it will be passed as an argument to <code>curl</code>, thus achieving the desired effect.</p>
<h4 id="242-scenario-2-preparations-before-running-the-application">2.4.2, Scenario 2: Preparations before running the application</h4>
<p>Starting the container is to start the main process, but there are times when some preparatory work is needed before starting the main process.</p>
<p>For example, a <code>mysql</code> class database may require some database configuration, initialization work that has to be solved before the final mysql server can be run.</p>
<p>In addition, you may want to avoid using the <code>root</code> user to start the service to improve security, and you may need to perform some necessary preparation work as <code>root</code> before starting the service, and then switch to the service user to start the service. In addition to the service, other commands can still be executed as <code>root</code> to facilitate debugging, etc.</p>
<p>These preparations are not related to the container <code>CMD</code>, no matter what <code>CMD</code> is, a pre-processing work is needed beforehand. In this case, you can write a script and put it in <code>ENTRYPOINT</code>, which will take the received parameters (i.e. <code>&lt;CMD&gt;</code>) as commands and execute them at the end of the script. This is how it is done in the official image <code>redis</code>, for example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">FROM</span><span class="s"> alpine:3.4</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> addgroup -S redis <span class="o">&amp;&amp;</span> adduser -S -G redis redis<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>...<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&#34;docker-entrypoint.sh&#34;</span><span class="p">]</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 6379</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">CMD</span> <span class="p">[</span> <span class="s2">&#34;redis-server&#34;</span> <span class="p">]</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>You can see that the <code>Redis</code> user is created for the <code>Redis</code> service, and the <code>ENTRYPOINT</code> is specified at the end for the <code>docker-entrypoint.sh</code> script.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="cp">#!/bin/sh
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>...
</span></span><span class="line"><span class="cl"><span class="c1"># allow the container to be started with `--user`</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="o">[</span> <span class="s2">&#34;</span><span class="nv">$1</span><span class="s2">&#34;</span> <span class="o">=</span> <span class="s1">&#39;redis-server&#39;</span> -a <span class="s2">&#34;</span><span class="k">$(</span>id -u<span class="k">)</span><span class="s2">&#34;</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="cl"> chown -R redis .
</span></span><span class="line"><span class="cl"> <span class="nb">exec</span> su-exec redis <span class="s2">&#34;</span><span class="nv">$0</span><span class="s2">&#34;</span> <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="k">fi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nb">exec</span> <span class="s2">&#34;</span><span class="nv">$@</span><span class="s2">&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The script is based on the contents of the <code>CMD</code>, if it is <code>redis-server</code> then switch to the <code>redis</code> user identity to start the server, otherwise it will continue to use the <code>root</code> identity. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ docker run -it redis id
</span></span><span class="line"><span class="cl"><span class="nv">uid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span> <span class="nv">groups</span><span class="o">=</span>0<span class="o">(</span>root<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="25-env">2.5, ENV</h3>
<p>There are two formats.</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>This directive is simple, it just sets the environment variables, either for other directives like <code>RUN</code> or for runtime applications, you can use the environment variables defined here directly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">ENV</span> <span class="nv">VERSION</span><span class="o">=</span><span class="m">1</span>.0 <span class="nv">DEBUG</span><span class="o">=</span>on <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>    <span class="nv">NAME</span><span class="o">=</span><span class="s2">&#34;Happy Feet&#34;</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This example demonstrates how to break lines and enclose values containing spaces in double quotes, which is consistent with the behavior under <code>Shell</code>.</p>
<p>Once an environment variable is defined, it can then be used in subsequent commands. For example, in the official <code>node</code> image <code>Dockerfile</code>, there is code like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">ENV</span> NODE_VERSION 7.2.0<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> curl -SLO <span class="s2">&#34;https://nodejs.org/dist/v</span><span class="nv">$NODE_VERSION</span><span class="s2">/node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> curl -SLO <span class="s2">&#34;https://nodejs.org/dist/v</span><span class="nv">$NODE_VERSION</span><span class="s2">/SHASUMS256.txt.asc&#34;</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> grep <span class="s2">&#34; node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz\$&#34;</span> SHASUMS256.txt <span class="p">|</span> sha256sum -c - <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> tar -xJf <span class="s2">&#34;node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz&#34;</span> -C /usr/local --strip-components<span class="o">=</span><span class="m">1</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> rm <span class="s2">&#34;node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz&#34;</span> SHASUMS256.txt.asc SHASUMS256.txt <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>  <span class="o">&amp;&amp;</span> ln -s /usr/local/bin/node /usr/local/bin/nodejs<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The environment variable <code>NODE_VERSION</code> is defined here first, and <code>$NODE_VERSION</code> is used several times in the subsequent <code>RUN</code> layer to customize the operation. As you can see, when you upgrade your image build in the future, you only need to update <code>7.2.0</code>, making <code>Dockerfile</code> build maintenance much easier.</p>
<p>The following directives can support environment variable expansion: <code>ADD</code>, <code>COPY</code>, <code>ENV</code>, <code>EXPOSE</code>, <code>LABEL</code>, <code>USER</code>, <code>WORKDIR</code>, <code>VOLUME</code>, <code>STOPSIGNAL</code>, <code>ONBUILD</code>.</p>
<p>You can feel from this list of commands that environment variables can be used in many powerful places. Through environment variables, we can make one copy of <code>Dockerfile</code> make more images, just by using different environment variables.</p>
<h3 id="26-volume">2.6. VOLUME</h3>
<p>The format is.</p>
<ul>
<li>
<p><code>VOLUME [&quot;&lt;path1&gt;&quot;, &quot;&lt;path2&gt;&quot;...]</code></p>
</li>
<li>
<p><code>VOLUME &lt;path&gt;</code></p>
</li>
</ul>
<p>As we said before, container runtime should try to keep the container storage layer free from write operations. For database applications that need to save dynamic data, their database files should be saved in a volume, and we will further introduce the concept of Docker volume in later sections. In order to prevent users from forgetting to mount the directory where dynamic files are stored as a volume at runtime, in <code>Dockerfile</code>, we can specify some directories to be mounted as anonymous volumes in advance, so that if users do not specify the mount at runtime, their applications can also run normally without writing a lot of data to the container storage layer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl"><span class="k">VOLUME</span><span class="s"> /data</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>/data</code> directory here is automatically mounted as an anonymous volume at runtime, and any information written to <code>/data</code> is not recorded into the container storage layer, thus ensuring statelessness of the container storage layer. Of course, this mount setting can be overridden at runtime. For example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">docker run -d -v mydata:/data xxxx
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this line, the named volume <code>mydata</code> is mounted to the <code>/data</code> location, replacing the anonymous volume mount configuration defined in the <code>Dockerfile</code>.</p>
<h3 id="27-expose">2.7. EXPOSE</h3>
<p>The format is <code>EXPOSE &lt;port 1&gt; [&lt;port 2&gt;...]</code>.</p>
<p>The <code>EXPOSE</code> directive is a declaration that the container provides a service port at runtime. This is just a declaration, and the application will not turn on services on this port at runtime because of this declaration. Writing such a declaration in <code>Dockerfile</code> has two advantages: one is to help image users understand the daemon port of the image service to facilitate configuration mapping; the other is that when random port mapping is used at runtime, i.e. <code>docker run -P</code>, the port of <code>EXPOSE</code> is automatically mapped randomly.</p>
<p>In addition, there is a special use in earlier versions of <code>Docker</code>. Previously, all containers ran on the default bridge network, so all containers had direct access to each other, which had some security issues. So there is a <code>-Docker</code> engine parameter <code>-icc=false</code>, when specified, containers will not be able to access each other by default, unless they use the <code>-links</code> parameter, and only the ports declared by <code>EXPOSE</code> in the image will be accessible. The use of <code>--icc=false</code> has been largely eliminated with the introduction of <code>docker network</code>, and interconnection and isolation between containers can be easily achieved with a custom network.</p>
<p>It is important to distinguish <code>-EXPOSE</code> from the use of <code>-p &lt;host port&gt;:&lt;container port&gt;</code> at runtime. <code>-p</code>, which maps the host port to the container port, in other words, exposes the container&rsquo;s corresponding port service to the outside world, while <code>EXPOSE</code> simply declares what port the container intends to use, and does not automatically map the port at the host.</p>
<h3 id="28-workdir">2.8, WORKDIR</h3>
<p>The format is <code>WORKDIR &lt;working directory path&gt;</code>.</p>
<p>You can use the <code>WORKDIR</code> command to specify the working directory (or called the current directory), and the current directory is changed to the specified directory at each subsequent level. If the directory does not exist, <code>WORKDIR</code> will create it for you.</p>
<p>As mentioned before, some beginners often make the mistake of writing <code>Dockerfile</code> as if it were a <code>Shell</code> script, and this misunderstanding can also lead to errors like the following.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="cl">UN <span class="nb">cd</span> /app<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="k">RUN</span> <span class="nb">echo</span> <span class="s2">&#34;hello&#34;</span> &gt; world.txt<span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If you run this <code>Dockerfile</code> as a build image, you will find that you cannot find the <code>/app/world.txt</code> file, or its content is not <code>hello</code>. The reason for this is simple: in the shell, two consecutive lines are in the same process execution environment, so the memory state modified by the previous command will directly affect the latter command; in <code>Dockerfile</code>, the execution environment of the two <code>RUN</code> commands is fundamentally different, and they are two completely different containers. This is a mistake caused by not understanding the concept of <code>Dockerfile</code> building tiered storage.</p>
<p>As I said before, each <code>RUN</code> starts a container, executes the command, and then commits the storage tier file changes. The execution of <code>RUN cd /app</code> in the first tier is just a change in the working directory of the current process, a memory change, which does not result in any file changes. When you get to the second tier, you start a brand new container, which has nothing to do with the first tier container, so it is not possible to inherit the memory changes from the previous tier build process.</p>
<p>So if you need to change the location of the working directory of each subsequent layer, then you should use the <code>WORKDIR</code> command.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/docker/">docker</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/go-assembly/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go Assembly Overview</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/hashcorp-vault/">
            <span class="next-text nav-default">Hashcorp Vault Basic Tutorial</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
