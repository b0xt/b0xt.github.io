<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Implementation principle of BoltDB - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article provides a brief analysis of the design principles of BoltDB." /><meta name="keywords" content="Boltdb" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/boltdb/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Implementation principle of BoltDB" />
<meta property="og:description" content="This article provides a brief analysis of the design principles of BoltDB." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/boltdb/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-21T12:04:24+08:00" />
<meta property="article:modified_time" content="2022-08-21T12:04:24+08:00" />

<meta itemprop="name" content="Implementation principle of BoltDB">
<meta itemprop="description" content="This article provides a brief analysis of the design principles of BoltDB."><meta itemprop="datePublished" content="2022-08-21T12:04:24+08:00" />
<meta itemprop="dateModified" content="2022-08-21T12:04:24+08:00" />
<meta itemprop="wordCount" content="3722">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Implementation principle of BoltDB"/>
<meta name="twitter:description" content="This article provides a brief analysis of the design principles of BoltDB."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Implementation principle of BoltDB</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-21 12:04:24 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3722 words </span>
          <span class="more-meta"> 18 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#mmap">MMAP</a></li>
        <li><a href="#data-structure">Data Structure</a>
          <ul>
            <li><a href="#page">Page</a></li>
            <li><a href="#node">Node</a></li>
            <li><a href="#serialization">Serialization</a></li>
          </ul>
        </li>
        <li><a href="#bucket">Bucket</a>
          <ul>
            <li><a href="#data-structure-1">Data structure</a></li>
            <li><a href="#data-querying">Data Querying</a></li>
            <li><a href="#bucket-nesting">Bucket nesting</a></li>
          </ul>
        </li>
        <li><a href="#transactions">Transactions</a>
          <ul>
            <li><a href="#mvcc">MVCC</a></li>
            <li><a href="#freelist">Freelist</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>BoltDB is an embedded K/V database implemented in Go language with the goal of providing a simple, fast and reliable embedded database for projects that do not require full database services such as Postgres or MySQL. boltDB has been implemented as the underlying database in projects such as etcd, Bitcoin, etc. This article provides a brief analysis of the design principles of BoltDB.</p>
<p><a href="https://github.com/boltdb/bolt#getting-started">BoltDB</a> is currently archived by the original author, so the version analyzed in this article is the one maintained by etcd: <em><a href="https://github.com/etcd-io/bbolt">etcd-io/bbolt</a></em> .</p>
<p>BoltDB is mainly designed from LMDB, supports ACID transaction, lock-free concurrent transaction MVCC, provides B+Tree index, BoltDB uses a single file as persistent storage, uses <code>mmap</code> to map the file into memory, and divides the file into equal size Page to store data, and uses copy-on-write technique to write dirty pages to the file.</p>
<h2 id="mmap">MMAP</h2>
<p>The Memory-Mapped File (mmap) technique maps a file into the virtual memory of the calling process and accesses the contents of the mapped file by manipulating the corresponding memory area. The <code>mmap()</code> system call function is typically used when frequent reads and writes to a file are required, replacing I/O reads and writes with memory reads and writes to achieve higher performance.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/21/1c222378a316424789b510f43eab5760.png" alt="mmap"></p>
<p>Traditional UNIX or Linux systems have multiple buffers in the kernel. When we call the <code>read()</code> system call to read data from a file, the kernel usually copies that data to a buffer first, and then copies the data to the process memory space.</p>
<p>When using <code>mmap</code>, the kernel creates a memory map area in the virtual address space of the calling process, and the application process can access this memory directly to get data, saving the overhead of copying data from kernel space to user process space. <code>mmap</code> does not actually copy the contents of the file to memory in real time, but rather copies the file data to memory only when a page-out interrupt is triggered during the read process.</p>
<p>Paging is a common memory management technique used in modern operating systems to divide the virtual memory space into equally sized Pages, which are usually 4KB in size, and in UNIX-like systems, we can use the following command to get the page size.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ getconf PAGESIZE
</span></span><span class="line"><span class="cl"><span class="m">4096</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Therefore, in order to reduce the number of random I/Os, the data files in BoltDB are also divided by 4KB size. However, in the process of use, frequent reading and writing data will still cause too many random I/Os and affect the performance.</p>
<blockquote>
<p>Writing to files in BoltDB does not use the <code>mmap</code> technique, but writes data to files directly through two system calls <code>Write()</code> and <code>fdatasync()</code>.</p>
</blockquote>
<h2 id="data-structure">Data Structure</h2>
<p>BoltDB&rsquo;s data file is organized into multiple Pages. When the database is initialized, 4 Pages are pre-allocated, page 0 and page 1 are initialized as <code>meta</code> pages, page 2 is initialized as a <code>freelist</code> page, and page 3 is initialized as an empty <code>leafPage</code> for writing key-value pairs data. While these types of Pages are described below, we first analyze the data structure of the page.</p>
<h3 id="page">Page</h3>
<p>Each Page has a fixed size <code>Header</code> area, which is used to mark the id, page type and other information of the page. Since BoltDB uses B+Tree indexing, in addition to <code>leafPage</code> which holds data, there will be <code>branchPage</code> which is used as data index.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">branchPageFlag</span> <span class="p">=</span> <span class="mh">0x01</span>   <span class="c1">// Branch Nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">leafPageFlag</span> <span class="p">=</span> <span class="mh">0x02</span>     <span class="c1">// Leaf Nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">metaPageFlag</span> <span class="p">=</span> <span class="mh">0x04</span>     <span class="c1">// meta page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">freelistPageFlag</span> <span class="p">=</span> <span class="mh">0x10</span> <span class="c1">// freelist page that holds an empty page id with no data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">pgid</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">page</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">id</span> <span class="nx">pgid</span>         <span class="c1">// page id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">flags</span> <span class="kt">uint16</span>    <span class="c1">// The specific data types stored on this page, i.e. the four Flags above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">count</span> <span class="kt">uint16</span>    <span class="c1">// Data Counting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">overflow</span> <span class="kt">uint32</span> <span class="c1">// Whether there is a backorder page, and if so, the overflow indicates the number of subsequent pages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>In older implementations there was an extra <code>ptr</code> field pointing to the data storage address, but in Go 1.14 it did not pass the pointer safety check, so this field has been removed, for details see: <em><a href="https://github.com/etcd-io/bbolt/pull/201">PR#201 Fix unsafe pointer conversions caught by Go 1.14 checkptr</a></em></p>
</blockquote>
<p>BoltDB assigns a unique identifier id to each <code>page</code> and looks up the corresponding page by its id. The <code>pageHeader</code> is followed by a concrete data storage structure. Each key-value pair is represented by an <code>Element</code> structure, and the address of the key-value pair is obtained by a pointer operation using the offset <code>pos</code>: <code>&amp;Element + pos == &amp;key</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">branchPageElement</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pos</span> <span class="kt">uint32</span>   <span class="c1">// The offset of the key storage location of the Element relative to the current Element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ksize</span> <span class="kt">uint32</span> <span class="c1">// The size of the element corresponding to the key, in byte units
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pgid</span> <span class="nx">pgid</span>    <span class="c1">// The page id of the child node pointed to by Element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">leafPageElement</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">flags</span> <span class="kt">uint32</span> <span class="c1">// Whether the current Element represents a Bucket, if so the value is 1, if not then the value is 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pos</span> <span class="kt">uint32</span>   <span class="c1">// Offset of the key-value pair storage location of the Element relative to the current Element
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ksize</span> <span class="kt">uint32</span> <span class="c1">// The size of the element corresponding to the key, in byte units
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">vsize</span> <span class="kt">uint32</span> <span class="c1">// The size of the element corresponding to the value, in byte units
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above two different <code>Element</code> structures are used in different types of <code>page</code>, if it is used for data indexing <code>branchPage</code>, only the size field <code>ksize</code> of the key and the <code>pgid</code> of the next level page will be stored in a <code>branchPageElement</code> for data indexing.</p>
<p>The <code>leafPageElement</code> is used to store real key-value pair data, so the <code>vsize</code> field is added to quickly get the key-value pair information for queries. The meaning of the <code>flags</code> field will be described in the <strong>Bucket</strong> section.</p>
<p>The memory layout of <code>branchPage</code> and <code>leafPage</code> can be derived from the analysis of <code>Element</code> as shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/21/37850f17092b41deb467ff72ef1d1665.png" alt="page layout"></p>
<p>Storing <code>Element</code> and key-value pairs separately reduces the lookup time because the size of the <code>Element</code> structure is fixed and we can get all <code>Element</code>s in <em>O(1)</em> time complexity, whereas if they were stored in <code>[Element header][key value][...]</code> format, we need to iterate through them in order to find them.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="nf">leafPageElements</span><span class="p">()</span> <span class="p">[]</span><span class="nx">leafPageElement</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">[]</span><span class="nx">leafPageElement</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">reflect</span><span class="p">.</span><span class="nx">SliceHeader</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Data</span><span class="p">:</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Len</span><span class="p">:</span>  <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Cap</span><span class="p">:</span>  <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">}))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="node">Node</h3>
<p><code>page</code> is the layout format of the data in the disk file, which is deserialized to <code>node</code> when the Page is loaded into memory for data modification operations. A <code>node</code> is represented as a B+Tree node, so additional <code>unbalanced</code> and <code>spilled</code> fields are needed to indicate whether the node needs to be rotated and split. The <code>node</code> also stores a pointer to the parent and child nodes, which can be used for range queries on the key.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bucket</span> <span class="o">*</span><span class="nx">Bucket</span>  <span class="c1">// Each Bucket is a complete B+ Tree
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">isLeaf</span> <span class="kt">bool</span>     <span class="c1">// Distinguish between branch and leaf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">unbalanced</span> <span class="kt">bool</span> <span class="c1">// Is it balanced
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">spilled</span>    <span class="kt">bool</span> <span class="c1">// Overflow or not
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">key</span>  <span class="p">[]</span><span class="kt">byte</span>     <span class="c1">// The starting key of the node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pgid</span> <span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">    <span class="nx">parent</span> <span class="o">*</span><span class="nx">node</span>    <span class="c1">// Pointer to parent node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">children</span> <span class="nx">nodes</span>  <span class="c1">// Child Node Pointer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">inodes</span> <span class="nx">inodes</span>   <span class="c1">// Array of structures to store key-value pairs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">inode</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">flags</span> <span class="kt">uint32</span>    <span class="c1">// For leaf node, whether it represents a subbucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pgid</span>  <span class="nx">pgid</span>      <span class="c1">// The page id for the branch node, child node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">key</span>   <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">inodes</span> <span class="p">[]</span><span class="nx">inode</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The key-value pairs in <code>page</code> are stored in <code>node.inodes</code> and correspond one-to-one, so that a key-value pair can be accessed by the index of the slice.</p>
<h3 id="serialization">Serialization</h3>
<p>To facilitate data modification operations in BoltDB, the corresponding <code>page</code> needs to be instantiated as <code>node</code> and then serialized back to <code>page</code> for writing to disk after the modification is done. The conversion of <code>node</code> and <code>page</code> is realized by the methods <code>node.read(p *page)</code> and <code>node.write(p *page)</code>. Take the deserialization process of <code>page</code> as an example, the conversion process is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">read</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="p">=</span> <span class="p">((</span><span class="nx">p</span><span class="p">.</span><span class="nx">flags</span> <span class="o">&amp;</span> <span class="nx">leafPageFlag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">inodes</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">count</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">inode</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">elem</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">leafPageElement</span><span class="p">(</span><span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="nx">inode</span><span class="p">.</span><span class="nx">flags</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">flags</span>
</span></span><span class="line"><span class="cl">            <span class="nx">inode</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">key</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="nx">inode</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">value</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">elem</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">branchPageElement</span><span class="p">(</span><span class="nb">uint16</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="nx">inode</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">            <span class="nx">inode</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">elem</span><span class="p">.</span><span class="nf">key</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">inode</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;read: zero-length inode key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Save first key so we can find the node in the parent when we spill.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">key</span>
</span></span><span class="line"><span class="cl">        <span class="nf">_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;read: zero-length node key&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span><span class="p">.</span><span class="nx">key</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When filling inodes with key-value pairs. If it is <code>leafPage</code>, <code>inode.flags</code> is the <code>flags</code> of the element, key and value are the corresponding Key and Value of the element respectively; if it is <code>branchPage</code>, <code>inode.pgid</code> is the page number of the child node, and inode corresponds to <code>Element</code> in the page one by one.</p>
<h2 id="bucket">Bucket</h2>
<p>Buckets are higher-level data structures, and each Bucket is a complete B+Tree that organizes multiple node pages.</p>
<h3 id="data-structure-1">Data structure</h3>
<p>Bucket is defined by the <code>Bucket</code> structure, which contains a Header field defined by <code>bucket</code> containing the page id of the root node and uniquely identifying the self-incrementing id. buckets are independent of each other and are conceptually equivalent to namespaces.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Bucket</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="nx">bucket</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span> <span class="c1">// the associated transaction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">buckets</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Bucket</span> <span class="c1">// subbucket cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">page</span> <span class="o">*</span><span class="nx">page</span> <span class="c1">// inline page reference
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">rootNode</span> <span class="o">*</span><span class="nx">node</span> <span class="c1">// materialized node for the root page.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">nodes</span> <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">node</span> <span class="c1">// node cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">FillPercent</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// In the case of inline buckets, the &#34;root&#34; will be 0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">bucket</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">root</span> <span class="nx">pgid</span> <span class="c1">// page id of the bucket&#39;s root-level page
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">sequence</span> <span class="kt">uint64</span> <span class="c1">// monotonically incrementing, used by NextSequence()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The nodes in the Bucket may be either instantiated <code>nodes</code> or serialized stored <code>pages</code>. When you need to find the key-value pair of a page from the Bucket, you will first check if the corresponding <code>node</code> exists from the <code>Bucket.nodes</code> cache (only pages that have been modified with data are cached as <code>node</code>), if not, then you will look for it from <code>page</code>.</p>
<p>The <code>Bucket.FillPercent</code> field records the fill percentage of the node. When the used space in a node exceeds a certain percentage of the entire node capacity, the node must be split to reduce the probability of triggering a rebalance operation when inserting key-value pairs in the B+ Tree. The default value is 50%, and increasing this value is only helpful if the large number of multi-write operations is added at the end.</p>
<h3 id="data-querying">Data Querying</h3>
<p>To facilitate data queries, a Bucket may hold multiple iterators, defined by <code>Cursor</code>, containing the Bucket the iterator is traversing and the stack on which the search path is stored.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Cursor</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">bucket</span> <span class="o">*</span><span class="nx">Bucket</span>  <span class="c1">// bucket
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stack</span> <span class="p">[]</span><span class="nx">elemRef</span> <span class="c1">// Record the search path of the cursor, the last element points to the current position of the cursor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">elemRef</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">page</span> <span class="o">*</span><span class="nx">page</span>      <span class="c1">// The page of the current node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">node</span> <span class="o">*</span><span class="nx">node</span>      <span class="c1">// The node of the current node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">index</span> <span class="kt">int</span>       <span class="c1">// Index in page or node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>stack</code> is a slice, each <code>elemRef</code> points to a node of the B+ Tree, which may be an instantiated <code>node</code> or an uninstantiated <code>page</code>, <code>elemRef</code> stores a pointer to the corresponding structure, another pointer is empty, and records the location of the key-value pair.</p>
<p>When querying, the Cursor starts with a recursive lookup from the page corresponding to <code>Bucket.root</code> to the final leaf node. The path to the corresponding key is stored in <code>Cursor.stack</code>, and the node and location of the key are stored at the top of the stack. In addition to regular key-value lookup operations, Cursor also supports the <code>First</code>, <code>Last</code>, <code>Next</code>, and <code>Prev</code> methods of the lookup Bucket for optimization of related scenarios.</p>
<h3 id="bucket-nesting">Bucket nesting</h3>
<p>Buckets in BoltDB can form nested relationships, which are divided into <code>subBucket</code> and <code>inlineBucket</code> depending on the nesting form. In use, we usually create a new Bucket and set a name in the following way.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">db</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">CreateBucket</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&#34;NewBucket&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;create bucket: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>A <code>subBucket</code> itself is also a complete B+Tree, with its name as key and a <code>bucket</code> structure as value, indexed to the page where the root node of the subBucket is located.</p>
<p>BoltDB holds a <code>rootBucket</code> that stores the root nodes of all B+ Trees in the database, and every <code>Bucket</code> we create is a <code>subBucket</code> of the <code>rootBucket</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/21/a1a62e92c18549a2adf67dfcf3217869.png" alt="subBucket"></p>
<p>As you can see from the above figure, only the <code>bucket</code> field of <code>subBucket</code> is stored in the parent bucket, each <code>subBucket</code> takes up extra page to store data, usually the nested sub-buckets do not have a lot of data, which causes a waste of space. to solve this problem by storing the values of smaller child buckets directly in the leaf nodes of the parent bucket, thus reducing the number of pages used.</p>
<p><code>inlineBucket</code> is an optimization of <code>subBucket</code>, as we can deduce from the following code, it is essentially appending a complete page structure to the value of <code>subBucket</code> and writing it to a file as a byte array.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">)</span> <span class="nf">inlineable</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">n</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">rootNode</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Bucket must only contain a single leaf node.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="p">!</span><span class="nx">n</span><span class="p">.</span><span class="nx">isLeaf</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Bucket is not inlineable if it contains subbuckets or if it goes beyond
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// our threshold for inline bucket size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">size</span> <span class="p">=</span> <span class="nx">pageHeaderSize</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">inode</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">n</span><span class="p">.</span><span class="nx">inodes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">size</span> <span class="o">+=</span> <span class="nx">leafPageElementSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">inode</span><span class="p">.</span><span class="nx">key</span><span class="p">))</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">inode</span><span class="p">.</span><span class="nx">value</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">inode</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">bucketLeafFlag</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">size</span> <span class="p">&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nf">maxInlineBucketSize</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In order to ensure the stable operation of the program, BoltDB has made some restrictions on <code>inlineBucket</code>.</p>
<ol>
<li>the size of <code>inlineBucket</code> cannot exceed 1/4 of pageSize.</li>
<li><code>inlineBucket</code> can contain only one leaf node.</li>
<li>the <code>bucket.root</code> field of <code>inlineBucket</code> has a value of 0 to indicate the structure type.</li>
</ol>
<h2 id="transactions">Transactions</h2>
<p>BoltDB supports ACID transactions and uses a read/write locking mechanism to support multiple read operations and one write operation to execute concurrently, allowing applications to handle complex operations more easily. Each transaction has a <code>txid</code>, where <code>db.meta.txid</code> holds the largest committed write transaction id.</p>
<p>BoltDB enforces different id assignment policies for write and read transactions.</p>
<ul>
<li>Read transactions: <code>txid == db.meta.txid</code>.</li>
<li>Write transactions: <code>txid == db.meta.txid + 1</code>.</li>
<li>When the write transaction is successfully committed, <code>db.meta.txid</code> is updated to the current write transaction id.</li>
</ul>
<h3 id="mvcc">MVCC</h3>
<p>BoltDB implements multi-version concurrency control through the <code>meta</code> copy mechanism. The <code>meta</code> page is the entry point for transactions to read data, which records the version information of the data and the starting point of the query. The definition of <code>meta</code> is as follows, with a selection of important fields.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">meta</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">root</span> <span class="nx">bucket</span>     <span class="c1">// Store the page where the rootBucket is located
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">freelist</span> <span class="nx">pgid</span>   <span class="c1">// The pgid where the freelist is located, initialized to 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pgid</span> <span class="nx">pgid</span>       <span class="c1">// The number of pages requested, the value is max_pgid + 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">txid</span> <span class="nx">txid</span>       <span class="c1">// The id of the last write transaction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">checksum</span> <span class="kt">uint64</span> <span class="c1">// 64-bit FNV hash checks for the fields above
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When the database is initialized, the two pages with page numbers 0 and 1 are set as <code>meta</code> pages. Each transaction gets a <code>txid</code> and selects the <code>meta</code> page with <code>txid % 2</code> as the read object of the transaction, and the <code>meta</code> page is updated alternately after each write. When one of them is inconsistent, the other <code>meta</code> page is used.</p>
<p>BoltDB write operations are performed in memory, if the transaction is not committed when the error occurs, it will not affect the database; if the error occurs in the process of commit, the order of BoltDB write file also ensures that it will not affect: because the data will be written in the new page without overwriting the original data, and the information in <code>meta</code> will not change at this time.</p>
<ol>
<li>start a write transaction with a copy of the <code>meta</code> data.</li>
<li>starting from <code>rootBucket</code>, traverse the B+ Tree to find the location of the data and modify it.</li>
<li>when the modification operation is complete, a transaction commit is performed, which writes the data to a new page.</li>
<li>finally update the information of <code>meta</code>.</li>
</ol>
<h3 id="freelist">Freelist</h3>
<p>BoltDB works by allocating 4KB pages and organizing them into a B+ Tree, and allocating more pages at the end as needed. BoltDB uses copy-on-write technology when writing to a file. When a page is updated, its contents are copied to a new page and the old page is freed.</p>
<p>When after repeated additions and deletions, there will be parts of the file without data. The page that is emptied of data may be located anywhere, BoltDB does not intend to move data, truncate the file to return this part of space, but to add this part of the empty page, to the internal <code>freelist</code> to maintain, and reuse this space when new data is written.</p>
<blockquote>
<p>So the persistence file of <code>BoltDB</code> will only grow, not decrease as data is deleted.</p>
</blockquote>
<p><code>freelist</code> is a complex structure that contains a number of function definitions. For ease of understanding, a few important fields are listed below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">freelist</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">freelistType</span>   <span class="nx">FreelistType</span>        <span class="c1">// freelist type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ids</span>            <span class="p">[]</span><span class="nx">pgid</span>              <span class="c1">// all free and available free page ids.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">allocs</span>         <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="nx">txid</span>       <span class="c1">// mapping of txid that allocated a pgid.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">pending</span>        <span class="kd">map</span><span class="p">[</span><span class="nx">txid</span><span class="p">]</span><span class="o">*</span><span class="nx">txPending</span> <span class="c1">// mapping of soon-to-be free page ids by tx.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">cache</span>          <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="kt">bool</span>       <span class="c1">// fast lookup of all free and pending 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">txPending</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ids</span>              <span class="p">[]</span><span class="nx">pgid</span>
</span></span><span class="line"><span class="cl">    <span class="nx">alloctx</span>          <span class="p">[]</span><span class="nx">txid</span> <span class="c1">// txids allocating the ids
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">lastReleaseBegin</span> <span class="nx">txid</span>   <span class="c1">// beginning txid of last matching releaseRange
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>freelist</code> has two types, <code>FreelistArrayType</code> and <code>FreelistMapType</code>, the default is <code>FreelistArrayType</code> format, the following content is also based on the array type for analysis. When the cache record is in array format, the <code>freelist.ids</code> field records the pgid of the current empty page, and when the program needs the page, it will call the corresponding <code>freelist.arrayAllocate(txid txid, n int) pgid</code> method to iterate through the <code>ids</code> and select n consecutive empty <code>pages</code> for the caller to use.</p>
<p>When a write transaction produces a useless page, <code>freelist.free(txid txid, p *page)</code> is called to put the specified page into the <code>freelist.pending</code> pool and set the page to true in <code>freelist.cache</code>, noting that the data is not cleared at this point. When the next write transaction is opened, the <code>freelist.release(txid txid)</code> method is called to move the page from the <code>pending</code> pool that is not used by any transaction to the <code>ids</code> pool.</p>
<p>BoltDB is designed to achieve multi-version concurrency control, speed up the rollback of transactions, and avoid interference with read transactions.</p>
<ol>
<li>when the write transaction updates data, it does not directly overwrite the page where the old data is located, and allocates a new page to write the updated data, and then puts the page occupied by the old data into the <code>freelist.pending</code> pool and creates a new index. When the transaction needs to be rolled back, just delete the page in the <code>pending</code> pool and roll back the index to the original page.</li>
<li>When a read transaction is initiated, a separate copy of the <code>meta</code> information is made, and the data pointed to by the <code>meta</code> can be read from this unique <code>meta</code> as the entry point. At this time, even if a write transaction modifies the data of the related key, the modified data will only be written to the new page, and the old page referenced by the read transaction will enter the <code>pending</code> pool, and the data related to the read transaction will not be modified. The data associated with the read transaction will not be modified until all the read transactions associated with the page are finished.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/21/ecb6b4e752ba4ed7810162e5a0b0fdf9.png" alt="page freelist"></p>
<p><code>freelist</code> implements MVCC with space reuse, only when the remaining space does not meet the write requirements will the file map grow, when the data file is less than 1GB, each remapping size doubles, when the file is larger than 1GB, each growth of 1GB to make full use of space.</p>
<h2 id="summary">Summary</h2>
<p>BoltDB is a streamlined database implementation model, using <code>mmap</code> to map the page on disk to the page in memory, realizing zero copy of data, using B+ Tree for indexing, which is helpful to understand the concepts related to database system. It provides a way of thinking about the problem. The operating system uses COW (Copy-On-Write) technology for Page management, and through copy-on-write technology, the system can achieve lock-free read-write concurrency, but cannot achieve lock-free write-write concurrency, which predestines this kind of database to have high read performance, but poor random write performance, so it is suitable for the scenario of &lsquo;read more write less&rsquo;.</p>
<p>The use of write-time replication technology also creates certain disadvantages, if the long execution of read-only transactions, it will lead to dirty pages can not be recycled; if the long execution of the read-write transactions, it will cause other read-write transactions to hang and wait. In the process of using BoltDB, you should be careful to avoid long-running transactions as much as possible.</p>
<p><strong>The text does not describe the B+Tree data structure in detail, you can read the article yourself</strong> : <em><a href="https://www.tutorialcup.com/dbms/b-tree.htm">Concepts of B+ Tree and Extensions - B+ and B Tree index files in DBMS</a></em></p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://wingsxdu.com/posts/database/boltdb/">https://wingsxdu.com/posts/database/boltdb/</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/mmap.2.html">http://man7.org/linux/man-pages/man2/mmap.2.html</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/fdatasync.2.html">http://man7.org/linux/man-pages/man2/fdatasync.2.html</a></li>
<li><a href="https://blog.csdn.net/letterwuyu/article/details/80927226">https://blog.csdn.net/letterwuyu/article/details/80927226</a></li>
<li><a href="http://blog.decaywood.me/2017/04/10/Linux-mmap/">http://blog.decaywood.me/2017/04/10/Linux-mmap/</a></li>
<li><a href="https://github.com/boltdb/bolt/issues/308">https://github.com/boltdb/bolt/issues/308</a></li>
<li><a href="https://youjiali1995.github.io/storage/boltdb/#%E5%AE%9E%E7%8E%B0">https://youjiali1995.github.io/storage/boltdb/#%E5%AE%9E%E7%8E%B0</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/docker-health/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Health check for docker containers</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/promql-sli-slo/">
            <span class="next-text nav-default">Calculating SLI and SLO with PromQL</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
