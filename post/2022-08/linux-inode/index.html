<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Inode in the Linux file system - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Exploring inode in the Linux file system." /><meta name="keywords" content="Linux, Inode" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/linux-inode/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Inode in the Linux file system" />
<meta property="og:description" content="Exploring inode in the Linux file system." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/linux-inode/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-13T11:24:02+08:00" />
<meta property="article:modified_time" content="2022-08-13T11:24:02+08:00" />

<meta itemprop="name" content="Inode in the Linux file system">
<meta itemprop="description" content="Exploring inode in the Linux file system."><meta itemprop="datePublished" content="2022-08-13T11:24:02+08:00" />
<meta itemprop="dateModified" content="2022-08-13T11:24:02+08:00" />
<meta itemprop="wordCount" content="4923">
<meta itemprop="keywords" content="Linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Inode in the Linux file system"/>
<meta name="twitter:description" content="Exploring inode in the Linux file system."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Inode in the Linux file system</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-13 11:24:02 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4923 words </span>
          <span class="more-meta"> 24 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#file-system">File System</a>
          <ul>
            <li><a href="#are-directory-entries-and-directories-the-same-thing">Are directory entries and directories the same thing?</a></li>
            <li><a href="#how-is-the-file-data-stored-on-the-disk">How is the file data stored on the disk?</a></li>
          </ul>
        </li>
        <li><a href="#virtual-file-system">Virtual File System</a>
          <ul>
            <li><a href="#vfs-structure">VFS structure</a></li>
            <li><a href="#inode-content">inode content</a></li>
          </ul>
        </li>
        <li><a href="#hard-and-soft-links">Hard and soft links</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="file-system">File System</h2>
<p>The file system is the subsystem of the operating system responsible for managing persistent data. To put it simply, it is responsible for saving the user&rsquo;s files to the disk hardware, because even if the computer loses power, the data in the disk is not lost, so the files can be saved persistently.</p>
<p>The basic data unit of a file system is the file, and its purpose is to organize and manage the files on disk, and the different ways of organizing them result in different file systems.</p>
<p>The most classic Linux saying is &ldquo;everything is a file&rdquo;. Not only common files and directories, but also block devices, pipes, sockets, etc., are unified and given to the file system for management.</p>
<p>The Linux file system assigns two data structures to each file: index node and directory entry, which are mainly used to record meta information and directory hierarchy of files.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/5074409e25fe44bab7a2e78bde43440e.png" alt="File System"></p>
<ul>
<li>
<p>Index nodes, also known as inodes, are used to record meta-information about a file, such as inode number, file size, access rights, creation time, modification time, location of data on disk, and so on. Index nodes are unique identifiers of files, they correspond to each other one by one, and they are also stored in the hard disk, so index nodes also occupy disk space.</p>
</li>
<li>
<p>A directory entry, or dentry, is used to record the name of a file, a pointer to the index node, and a hierarchical association with other directory entries. Multiple directory entries are associated to form a directory structure, but it differs from an index node in that a directory entry is a data structure maintained by the kernel and is not stored on disk, but is cached in memory.</p>
</li>
</ul>
<p>Since an index node uniquely identifies a file and a directory entry records the name of the file, the relationship between a directory entry and an index node is many-to-one, that is, a file can have multiple directories. For example, a hard link is implemented as multiple index nodes in a directory entry pointing to the same file.</p>
<p>Note that a directory is also a file, also uniquely identified by an index node. The difference with a normal file is that a normal file holds file data inside the disk, while a directory file holds subdirectories or files inside the disk.</p>
<h3 id="are-directory-entries-and-directories-the-same-thing">Are directory entries and directories the same thing?</h3>
<p>Although the names are similar, they are not the same thing. A directory is a file that is persistently stored on disk, while a directory entry is a data structure in the kernel that is cached in memory.</p>
<p>If a directory is read frequently from disk, it will be very inefficient, so the kernel will cache the read directory in memory with the data structure of the directory entry, and the next time the same directory is read again, it will be read from memory, which greatly improves the efficiency of the file system.</p>
<p>Note that the data structure &ldquo;directory entry&rdquo; is not just for directories, but also for files.</p>
<h3 id="how-is-the-file-data-stored-on-the-disk">How is the file data stored on the disk?</h3>
<p>The smallest unit of disk reading and writing is the sector, the size of the sector is only 512 bytes, so if the data is larger than 512 bytes, the disk needs to keep moving the head to find the data, we know that the general file can easily exceed 512 bytes then if multiple sectors are combined into one block, then the disk can be more efficient. Then the head reads multiple sectors at a time as a block (called a block on Linux, or a cluster on Windows). Therefore, the file system consists of multiple sectors into a logical block, and the smallest unit for each read/write is the logical block (data block), which is 4KB in size in Linux, i.e., 8 sectors are read/written at once, which will greatly improve the efficiency of disk read/write.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/ba26b7bb7e1342bf935c9193692c1eb1.png" alt="file system"></p>
<p>The data recorded by the file system, in addition to its own, there is data permission information, owner and other attributes, these information are stored in the inode, so who will record the inode information and the file system itself, such as the file system format, the number of inode and data? Then there is a super block to record this information.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/80fffa078cac47469f3eb425bbb9f201.png" alt="file system"></p>
<ul>
<li>superblock: records the overall information of the filesystem, including the total number of inodes/blocks, usage, remaining amount, and the format and related information of the filesystem.</li>
<li>inode: Record the attribute information of the file, you can use the stat command to view the inode information.</li>
<li>block: the actual file content, if a file is larger than one block, then it will occupy more than one block, but a block can only store one file. (Because the data is pointed by inode, if there are two files of data stored in the same block, it will be messed up)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/3fd9d90186214bddba871c057c88ec5e.png" alt="file system"></p>
<p>node is used to point to the data block, then as long as the inode is found, and then the block number is found by the inode, then the actual data can be found.</p>
<p>The index node is the data stored on the hard disk. In order to speed up the file access, the index node is usually loaded into the memory. We can&rsquo;t load all the superblock and index node area into memory, so the memory will definitely not hold up, so they are loaded into memory only when they need to be used, and they are loaded into memory at different times as follows.</p>
<ul>
<li>Superblock: enters memory when the file system is mounted.</li>
<li>Index node area: into memory when the file is accessed.</li>
</ul>
<h2 id="virtual-file-system">Virtual File System</h2>
<p>There are many different types of file systems, and the operating system wants to provide a uniform interface to the user, so it introduces an intermediate layer between the user layer and the file system layer, which is called the Virtual File System (VFS). VFS defines a set of data structures and standard interfaces supported by all file systems, so that programmers do not need to understand how the file system works, but only the uniform interfaces provided by VFS. The relationships between user space, system calls, virtual machine file systems, caches, file systems, and storage in the Linux file system are as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/bb597211a4764197abd8123b8a1f04b9.png" alt="Virtual File System"></p>
<p>There are quite a few file systems supported by Linux, and depending on the storage location, file systems can be divided into three categories.</p>
<ul>
<li>Disk-based file systems, which store data directly in the disk, such as Ext 2/3/4, XFS, etc. are this type of file systems.</li>
<li>In-memory file systems, which store data not on the hard disk but in memory. The /proc and /sys file systems we often use belong to this category.</li>
<li>Network file systems, file systems used to access data from other computer hosts, such as NFS, SMB, etc.</li>
</ul>
<p>The file system must first be mounted to a directory before it can be used properly, for example, Linux mounts the file system to the root directory at boot time.</p>
<p>Linux uses a hierarchical architecture that separates the user interface layer, the file system implementation and the storage device drivers, thus making it compatible with different file systems. The Virtual File System (VFS) is a software layer in the Linux kernel that provides a standard, abstract set of file operations in the kernel, allows different file system implementations to coexist, and provides a uniform file system interface to user space programs. The following diagram illustrates the overall structure of the Linux virtual file system.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/2269ee65ec274cd096365c47e93d92af.png" alt="the overall structure of the Linux virtual file system"></p>
<p>As you can see from the diagram above, the user-space application performs file operations either directly or indirectly by calling the System Call interface provided by the kernel (e.g., open(), write(), etc.) through library functions provided by the programming language.</p>
<p>The System Call interface then passes the application&rsquo;s parameters to the virtual file system for processing.</p>
<p>Each file system implements a set of common interfaces for the VFS, and the specific file system operates on the data according to its own organization of the data on the disk. When an application operates on a file, VFS finds the corresponding mount point based on the file path, gets the specific file system information, and then calls the corresponding operation function for that file system.</p>
<p>VFS provides two caches for file system objects, INode Cache and DEntry Cache, which cache recently used file system objects and are used to speed up accesses to INode and DEntry. The Linux kernel also provides Buffer Cache buffers to cache requests between the file system and associated block devices, reducing the number of accesses to physical devices and speeding up accesses. The Buffer Cache manages buffers in the form of LRU lists.</p>
<p>The benefit of VFS is that it decouples the application&rsquo;s file operations from the specific file system, making it easier to program.</p>
<ul>
<li>Application-level programs can perform file operations simply by using the read(), write(), and other interfaces provided externally by VFS, without caring about the details of the underlying file system implementation.</li>
<li>The file system only needs to implement the VFS interface to be compatible with Linux, making it easy to port and maintain.</li>
<li>Cross-file system file operations are implemented without concern for specific implementation details.</li>
</ul>
<p>After understanding the overall structure of the Linux file system, the following is an analysis of the technical principles of Linux VFS. Since the implementation of the file system and device drivers is very complex, and I have not been exposed to this area, I will not cover the implementation of specific file systems in this article.</p>
<h3 id="vfs-structure">VFS structure</h3>
<p>Linux views all file systems in terms of a set of generic objects, and the relationship between objects at each level is shown in the diagram below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/9a8fe42f53764d58b3b97ea49b68d403.png" alt=" VFS structure"></p>
<h4 id="fd-vs-file">fd vs file</h4>
<p>each process holds an array of fd[], which holds a pointer to a file structure; different fd&rsquo;s of the same process can point to the same file object.</p>
<p>file is a data structure in the kernel that represents a file that is opened by a process and associated with the process. When the application calls the open() function, VFS creates the corresponding file object. It holds the status of the opened file, such as file permissions, paths, offsets, etc.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L936 Structs are truncated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">path</span>                   <span class="n">f_path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">inode</span>                  <span class="o">*</span><span class="n">f_inode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>  <span class="o">*</span><span class="n">f_op</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span>                  <span class="n">f_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">fmode_t</span>                       <span class="n">f_mode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">loff_t</span>                        <span class="n">f_pos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">fown_struct</span>            <span class="n">f_owner</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/path.h#L8
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">path</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">vfsmount</span>  <span class="o">*</span><span class="n">mnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">dentry</span>    <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As you can see from the code above, the path to the file is actually a pointer to the DEntry structure, and VFS indexes to the location of the file via DEntry.</p>
<p>Except for the file offset f_pos, which is private to the process, all other data comes from INode and DEntry and is shared with all processes. The file objects of different processes can point to the same DEntry and Inode, thus enabling file sharing.</p>
<h4 id="dentry-and-inode">DEntry and INode</h4>
<p>The Linux file system assigns two data structures to each file, a Directory Entry (DEntry) and an Index Node (INode).</p>
<p>DEntry is used to hold the mapping between file paths and INodes, thus supporting movement within the file system. DEntry is maintained by VFS, shared by all file systems, and is not associated with a specific process. dentry objects start at the root directory &ldquo;/&rdquo;, and each dentry object holds its own Each dentry object holds its own subdirectories and files, thus forming a file tree. For example, if you want to access the file &ldquo;/home/beihai/a.txt&rdquo; and operate on it, the system will resolve the file path, starting with the dentry object in the root directory &ldquo;/&rdquo;, and then find the &ldquo;home/&rdquo; directory, followed by &ldquo;beihai/&rdquo;, and finally the dentry structure of &ldquo;a.txt&rdquo;, in which the d_inode field corresponds to that file.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/dcache.h#L89 Structs are truncated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_parent</span><span class="p">;</span>     <span class="c1">// Parent Directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">qstr</span> <span class="n">d_name</span><span class="p">;</span>          <span class="c1">// File name
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">d_inode</span><span class="p">;</span>       <span class="c1">// Associated inode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_child</span><span class="p">;</span>    <span class="c1">// Subdirectories and files in the parent directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_subdirs</span><span class="p">;</span>  <span class="c1">// Subdirectories and files in the current directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Each dentry object holds a corresponding inode object, representing a specific directory entry or file in Linux. inode contains all the metadata needed to manage objects in the file system, as well as the operations that can be performed on that file object.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L628 Structs are truncated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">umode_t</span>                 <span class="n">i_mode</span><span class="p">;</span>          <span class="c1">// File permissions and types
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">kuid_t</span>                  <span class="n">i_uid</span><span class="p">;</span>           <span class="c1">// user id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">kgid_t</span>                  <span class="n">i_gid</span><span class="p">;</span>           <span class="c1">// group id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span>    <span class="o">*</span><span class="n">i_op</span><span class="p">;</span>  <span class="c1">// inode functions such as create, mkdir, lookup, rename, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">super_block</span>      <span class="o">*</span><span class="n">i_sb</span><span class="p">;</span>           <span class="c1">// Affiliated SuperBlock
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">loff_t</span>                  <span class="n">i_size</span><span class="p">;</span>          <span class="c1">// File Size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">timespec</span>         <span class="n">i_atime</span><span class="p">;</span>         <span class="c1">// File last access time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">timespec</span>         <span class="n">i_mtime</span><span class="p">;</span>         <span class="c1">// File last modified time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">timespec</span>         <span class="n">i_ctime</span><span class="p">;</span>         <span class="c1">// File metadata last modified time (including file name)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>    <span class="o">*</span><span class="n">i_fop</span><span class="p">;</span>  <span class="c1">// File manipulation functions, open, write, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span>                    <span class="o">*</span><span class="n">i_private</span><span class="p">;</span>      <span class="c1">// Private data of the file system
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The virtual file system maintains a DEntry Cache, which is used to store the most recently used DEntry and speed up query operations. When a file is opened by calling the open() function, the kernel will first search the DEntry Cache for the corresponding DEntry based on the file path, and then construct a file object and return it if it is found. If the file is not in the cache, then VFS will load it down one level according to the nearest directory found until it finds the corresponding file. During this time, VFS caches all the dentry generated by the load.</p>
<p>The data stored in an INode is stored on disk and organized by a specific file system. when an INode needs to be accessed, the file system loads the corresponding data from disk and constructs an INode. an INode may be associated with more than one DEntry, i.e. it is equivalent to creating multiple file paths for a particular file (usually by creating hard links to the files).</p>
<h4 id="superblock">SuperBlock</h4>
<p>SuperBlock represents a specific loaded file system, used to describe and maintain the state of the file system, defined by VFS, but populated with data based on the specific file system. Each SuperBlock represents a specific disk partition and contains information about the current disk partition, such as file system type, remaining space, etc. An important member of the SuperBlock is the chain s_list, which contains all modified INodes, using which it is easy to distinguish which files have been modified and to write the data back to disk with the kernel thread. Another important member of the SuperBlock is s_op, which defines all operations on its INode, such as marking, releasing index nodes, and a number of other operations.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// https://elixir.bootlin.com/linux/v5.4.93/source/include/linux/fs.h#L1425 Structs are truncated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">super_block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">s_list</span><span class="p">;</span>               <span class="c1">// Pointer to a linked list
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">dev_t</span>               <span class="n">s_dev</span><span class="p">;</span>                <span class="c1">// Device Identifier
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">s_blocksize</span><span class="p">;</span>          <span class="c1">// Block size in bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loff_t</span>              <span class="n">s_maxbytes</span><span class="p">;</span>           <span class="c1">// File Size Limit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">file_system_type</span>    <span class="o">*</span><span class="n">s_type</span><span class="p">;</span>       <span class="c1">// File System Type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span>    <span class="o">*</span><span class="n">s_op</span><span class="p">;</span>   <span class="c1">// SuperBlock operation functions, write_inode, put_inode, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">dquot_operations</span>    <span class="o">*</span><span class="n">dq_op</span><span class="p">;</span>  <span class="c1">// Disk limit function
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">dentry</span>        <span class="o">*</span><span class="n">s_root</span><span class="p">;</span>             <span class="c1">// Root directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>A SuperBlock is a very complex structure that allows us to mount a physical file system on Linux or to add, delete, or check an INode. That&rsquo;s why file systems usually store multiple copies of SuperBlock on the disk to prevent accidental data corruption that could make the whole partition unreadable.</p>
<h3 id="inode-content">inode content</h3>
<p>The inode contains a lot of file meta-information, but not the file name, such as the number of bytes, the owner UserID, the group GroupID, the read/write execution permissions, the timestamp, and so on. While filenames are stored in directories, Linux systems do not use filenames internally, but use inode numbers to identify files. For the system the file name is just an alias for the inode number for easy identification.</p>
<h4 id="stat">stat</h4>
<p>View inode information</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># mkdir test</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># echo &#34;this is test file&#34; &gt; test.txt</span>
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># stat test.txt</span>
</span></span><span class="line"><span class="cl">  File: <span class="s1">&#39;test.txt&#39;</span>
</span></span><span class="line"><span class="cl">  Size: <span class="m">18</span>              Blocks: <span class="m">8</span>          IO Block: <span class="m">4096</span>   regular file
</span></span><span class="line"><span class="cl">Device: fd00h/64768d    Inode: <span class="m">33574994</span>    Links: <span class="m">1</span>
</span></span><span class="line"><span class="cl">Access: <span class="o">(</span>0644/-rw-r--r--<span class="o">)</span>  Uid: <span class="o">(</span>    0/    root<span class="o">)</span>   Gid: <span class="o">(</span>    0/    root<span class="o">)</span>
</span></span><span class="line"><span class="cl">Context: unconfined_u:object_r:admin_home_t:s0
</span></span><span class="line"><span class="cl">Access: 2019-08-28 19:55:05.920240744 +0800
</span></span><span class="line"><span class="cl">Modify: 2019-08-28 19:55:05.920240744 +0800
</span></span><span class="line"><span class="cl">Change: 2019-08-28 19:55:05.920240744 +0800
</span></span><span class="line"><span class="cl"> Birth: -
</span></span></code></pre></td></tr></table>
</div>
</div><p>Three main time attributes.</p>
<ul>
<li>ctime: change time is the time when the file or directory (attribute) was last changed, e.g. by executing commands such as chmod, chown, etc.</li>
<li>atime: access time is the time when the file or directory was last accessed.</li>
<li>mtime: modify time is the time when the file or directory (content) was last modified.</li>
</ul>
<h4 id="file">file</h4>
<p>View file type</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># file test</span>
</span></span><span class="line"><span class="cl">test: directory
</span></span><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># file test.txt</span>
</span></span><span class="line"><span class="cl">test.txt: ASCII text
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="inode-number">inode number</h4>
<p>On the surface, the user opens the file by its name, but in fact, the system internally divides this process into three steps.</p>
<ul>
<li>The system finds the inode number corresponding to this file name.</li>
<li>Getting the inode information by the inode number.</li>
<li>According to the inode information, find the block where the file data is located and read out the data.</li>
</ul>
<p>In fact, the system also has to see whether the user has access rights according to the inode information, and if so, it points to the corresponding data block, and if not, it returns permission denied.</p>
<h4 id="ls--i">ls -i</h4>
<p>View the file i-node number directly, or you can view the i-node number by viewing the file inode information via stat.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ls -i</span>
</span></span><span class="line"><span class="cl"><span class="m">33574991</span> anaconda-ks.cfg      <span class="m">2086</span> <span class="nb">test</span>  <span class="m">33574994</span> test.txt
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="inode-size">inode size</h4>
<p>The inode also consumes hard disk space, so when formatting, the operating system automatically divides the hard disk into two areas. One is the data area, which holds the file data; the other is the inode area, which holds the information contained in the inode. The size of each inode is typically 128 bytes or 256 bytes. Usually it is not necessary to focus on the size of individual inodes, but rather on the total number of inodes. the total number of inodes is determined at formatting time.</p>
<h4 id="df--i">df -i</h4>
<p>View the total number of inodes and used status of the hard disk partitions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># df -i</span>
</span></span><span class="line"><span class="cl">Filesystem               Inodes IUsed   IFree IUse% Mounted on
</span></span><span class="line"><span class="cl">/dev/mapper/centos-root <span class="m">8910848</span> <span class="m">26029</span> <span class="m">8884819</span>    1% /
</span></span><span class="line"><span class="cl">devtmpfs                 <span class="m">230602</span>   <span class="m">384</span>  <span class="m">230218</span>    1% /dev
</span></span><span class="line"><span class="cl">tmpfs                    <span class="m">233378</span>     <span class="m">1</span>  <span class="m">233377</span>    1% /dev/shm
</span></span><span class="line"><span class="cl">tmpfs                    <span class="m">233378</span>   <span class="m">487</span>  <span class="m">232891</span>    1% /run
</span></span><span class="line"><span class="cl">tmpfs                    <span class="m">233378</span>    <span class="m">16</span>  <span class="m">233362</span>    1% /sys/fs/cgroup
</span></span><span class="line"><span class="cl">/dev/sda1                <span class="m">524288</span>   <span class="m">328</span>  <span class="m">523960</span>    1% /boot
</span></span><span class="line"><span class="cl">tmpfs                    <span class="m">233378</span>     <span class="m">1</span>  <span class="m">233377</span>    1% /run/user/0
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="file-reading-and-writing">File reading and writing</h4>
<p>When the file system opens a file, it does the following.</p>
<ul>
<li>The system finds the inode corresponding to this file name: it looks up the item corresponding to this file name in the directory table, from which it gets the inode number corresponding to this file</li>
<li>Get the inode information of the disk through the inode number, the most important part of which is the disk address table.</li>
<li>The disk address table in the inode information is used by the file system to connect the physical blocks of the file that are scattered into the logical structure of the file. There are 13 block numbers in the disk address table, and the file will read the corresponding blocks in the order in which the block numbers appear in the disk address table. Find the block where the file data is located and read out the data.</li>
</ul>
<p>According to the above process, we can find that inode should have a special storage area for the system to find it quickly. In fact, when a disk is created, the operating system automatically divides the hard disk into two areas: the data area, where file data is stored, and the inode area (inode table), where inode information is stored.</p>
<p>The size of each inode is usually 128B or 256B. the total number of inode nodes is given at formatting time, usually one inode for every 1KB or 2KB. suppose that in a 1GB hard disk, each inode node is 128 bytes in size, and one inode is set for every 1KB, then the size of the inode table will will reach 128MB, which is 12.8% of the entire hard disk.</p>
<p>In other words, the total number of inodes per partition is fixed from the time it is formatted, so there is a possibility that the storage space is not full, but the inodes are exhausted because of too many small files. At this time, you can only clear the files or directories with high inode occupancy or modify the number of inodes. Of course, inode adjustment requires reformatting the disk and you need to make sure that the data has been effectively backed up before doing this operation.</p>
<p>A new question arises: which inode number should be assigned to the file when it is created? That is, how to ensure that the assigned inode number is not occupied?</p>
<p>Since it is a question of &ldquo;whether it is occupied or not&rdquo;, using a bitmap is the best solution, just like a bmap records the occupation of a block. The bitmap that identifies whether an inode number has been assigned is called an inodemap or imap, and to assign an inode number to a file you simply scan the imap to know which inode number is free.</p>
<p>(The so-called bitmap, which uses each bit to hold some kind of state, is suitable for large-scale data, but not a lot of data state.)
Like a bmap block bitmap, inode numbers are pre-programmed. inode numbers are allocated, and inode numbers are released when files are deleted. The allocated and released inode numbers are like digging up a piece of a map and replacing it when it is used up.</p>
<p>The imap suffers from the same problem as the bmap and inode table that needs to be solved: if the file system is large, the imap itself will be large, and scanning every time a file is stored will result in a lack of efficiency. Again, the optimization is to divide the blocks occupied by the file system into block groups, each with its own imap range, to reduce retrieval time.</p>
<p>Use the <code>df -i</code> command to view information on the number of inodes.</p>
<h4 id="operation-of-files">Operation of files</h4>
<p>System operations on files may affect inode.</p>
<ul>
<li>Copy: Creates a new file containing all data with a new inode number</li>
<li>Move: When moving under the same disk, the directory changes and neither the node number nor the location of the actual data storage block changes. Moving across disks will of course delete the data on this disk and create a new entry on another disk.</li>
<li>Hard links: The same inode number represents a file with multiple filenames, i.e. the same data can be accessed with different filenames, but they point to the same inode number and the number of links in the file metadata is increased. It is not possible to create hard links to directories.</li>
<li>Soft links: A soft link is essentially a linked file, which stores a pointer to another file. Therefore, if a soft link is created to a file with a different inode number, the number of links to the soft link file will not increase. Soft links can be created to directories.</li>
<li>Delete: When a file is deleted, the number of links in the inode is checked first. If the link number is greater than 1, only one hard link will be deleted without affecting the data. If the number of links is equal to 1, the inode will be freed and the corresponding block pointed to by the inode will be marked as free (the data will not be set to zero, so the hard disk data can be recovered if no new data is written after it is deleted by mistake). In the case of soft links, the linked file becomes a dangling link after the original file is deleted and cannot be accessed normally.</li>
</ul>
<p>The use of inode can also delete some files with escape characters or control characters in the file name, most typically files that start with a minus sign -. If you can&rsquo;t use the rm command directly, you can find out their inode numbers before deleting them.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">find . / -inum <span class="m">10086</span> -exec rm <span class="o">{}</span> <span class="se">\
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="peculiarities">Peculiarities</h4>
<p>The separation of inode numbers from filenames has led to the following phenomena unique to some Unix/Linux systems.</p>
<ul>
<li>The file name contains special characters, which may not be deleted properly. In this case, deleting the inode directly can serve to delete the file: <code>find . /* -inum node number -delete</code></li>
<li>Moving a file or renaming a file, which only changes the file name and does not affect the inode number.</li>
<li>After opening a file, the system identifies the file by its inode number and no longer considers the file name.</li>
</ul>
<p>This situation makes software updates easy and can be done without closing the software and without rebooting. This is because the system recognizes running files by their inode numbers, not by their filenames. When updating, the new version of the file takes the same filename and generates a new inode that does not affect the running file. When the software is next run, the filename automatically points to the new version of the file, and the inode of the old version is recycled.</p>
<h4 id="inode-exhaustion-failure">inode exhaustion failure</h4>
<p>Since the total number of inodes on a hard disk partition is fixed after formatting, and each file must have an inode, it is possible to run out of inode nodes, but there is still a lot of space left on the hard disk, but no new files can be created. Also this is a way to attack, so some public file systems have to do disk limits to prevent affecting the normal operation of the system. As for fixing it, it&rsquo;s easy, just find out which files that are taking up a lot of i-nodes and delete them.</p>
<h2 id="hard-and-soft-links">Hard and soft links</h2>
<p>Linux has a special kind of file called link. There are two types of links in Linux, hard links and soft links. In simple terms, a hard link is equivalent to a source file and a link file sharing an inode on disk and in memory, so the link file has a different dentry from the source file, so this feature means that a hard link cannot span the file system, and we cannot create a hard link for a directory. Soft links are different from hard links, firstly, soft links can span the file system, secondly, linked files and source files have different inode and dentry, therefore, the properties and contents of the two files are very different, the file contents of soft link files are the file names of the source files.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/6f750f6172a247cd9b514e5c6d60564f.png" alt="hard link vs soft link"></p>
<p>Hard links are &ldquo;index nodes&rdquo; in multiple directory entries pointing to a single file, i.e. to the same inode, but inodes cannot span file systems, each file system has its own inode data structure and list, so hard links cannot be used across file systems. Since multiple directory entries are pointing to one inode, the system will only delete the file completely if all hard links to the file and the source file are deleted.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/da89b03fa0674956a684190cecc445a2.png" alt="index nodes"></p>
<p>The soft link is equivalent to re-creating a file with a separate inode, but the content of this file is the path of another file, so when accessing the soft link, it is actually equivalent to accessing another file, so the soft link can cross the file system, even if the target file is deleted, the linked file is still there, but the file it points to is not found.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/206d537674db45b6a9e012c4242afe61.png" alt="index nodes"></p>
<ul>
<li>The principles of soft and hard links are different
<ul>
<li>A hard link creates a directory entry that contains the file name and the inode of the file, but the inode is the inode number of the original file, and does not create the data corresponding to it. So a hard link does not occupy the inode.</li>
<li>A soft link also creates a directory entry, which also contains the file name and the inode of the file, but its inode does not point to the inode of the data pointed to by the original file name, but creates a new inode and creates the data, which points to the original file name, so the number of characters of the original file name is the number of bytes occupied by the soft link.</li>
</ul>
</li>
<li>There is a difference in the targets that can be created by soft and hard links
<ul>
<li>Because each partition has a different set of inode tables, hard links cannot be created across partitions while soft links can, because soft links point to file names.</li>
</ul>
</li>
<li>A hard link cannot point to a directory
<ul>
<li>If a directory has a hard link, it may introduce a dead loop, but you may wonder if a soft link will also be in a loop. The answer is of course not, because a soft link has its own data and can check its own file properties. But hard links can&rsquo;t, because their inode numbers are the same, so they can&rsquo;t be judged as hard links, so they will be in a dead loop.</li>
</ul>
</li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">Linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/flannel/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Flannel for Cloud-Native Virtual Networks</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/tekton/">
            <span class="next-text nav-default">Tekton Practices</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
