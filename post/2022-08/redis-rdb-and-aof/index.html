<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Redis RDB and AOF Persistence - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore Redis RDB and AOF persistence mechanisms." /><meta name="keywords" content="redis, Rdb, Aof" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/redis-rdb-and-aof/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Redis RDB and AOF Persistence" />
<meta property="og:description" content="Explore Redis RDB and AOF persistence mechanisms." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/redis-rdb-and-aof/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-23T13:03:27+08:00" />
<meta property="article:modified_time" content="2022-08-23T13:03:27+08:00" />

<meta itemprop="name" content="Redis RDB and AOF Persistence">
<meta itemprop="description" content="Explore Redis RDB and AOF persistence mechanisms."><meta itemprop="datePublished" content="2022-08-23T13:03:27+08:00" />
<meta itemprop="dateModified" content="2022-08-23T13:03:27+08:00" />
<meta itemprop="wordCount" content="3321">
<meta itemprop="keywords" content="redis," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis RDB and AOF Persistence"/>
<meta name="twitter:description" content="Explore Redis RDB and AOF persistence mechanisms."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Redis RDB and AOF Persistence</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-23 13:03:27 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3321 words </span>
          <span class="more-meta"> 16 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#disk-synchronization">Disk synchronization</a>
          <ul>
            <li><a href="#delayed-write">Delayed write</a></li>
            <li><a href="#persistence-process">Persistence Process</a></li>
          </ul>
        </li>
        <li><a href="#rdb-snapshot">RDB Snapshot</a>
          <ul>
            <li><a href="#data-structure">Data structure</a></li>
            <li><a href="#manually-triggered">Manually triggered</a></li>
            <li><a href="#automatic-triggering">Automatic triggering</a></li>
          </ul>
        </li>
        <li><a href="#aof-logging">AOF Logging</a>
          <ul>
            <li><a href="#data-structures">Data structures</a></li>
            <li><a href="#aof-file-rewrites">AOF file rewrites</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Redis is an in-memory database that stores data in memory in exchange for faster read speeds. However, because memory is volatile, Redis stored data can be lost once a process quits or a hardware device fails. To solve the data persistence problem, Redis provides two solutions, RDB snapshot and AOF write operation logging, and this article analyzes the implementation of these two sub-cases.</p>
<p>The so-called persistence is to back up the server data at a certain point in time to a disk file, so that when the program exits or the server is down, the data can be recovered at the next restart using the previously persisted file. There are generally three common strategies to perform persistence operations to prevent data loss.</p>
<ul>
<li>Method 1: Setting up backup files or snapshots to recover through data backup or snapshots after equipment failure.</li>
<li>Method 2: Use independent logs to record the operational behavior of the database in order to recover to a consistent state through logs after a failure, since logs are written in a sequential append fashion, so there is no log corruption.</li>
<li>Method 3: The database is not modified with old data, and write operations are done in an appended manner, and the data itself is a log.</li>
</ul>
<p>The first two strategies are RDB and AOF persistence in Redis, and the third scheme is not used for Redis. One is that Redis is often used in buffering scenarios with a lot of read and write operations, and modifying data in an appending manner will take up a lot of memory space. Second, the third option does not back up the data to disk, and once the device fails, it will still cause data loss.</p>
<h2 id="disk-synchronization">Disk synchronization</h2>
<p>Traditional UNIX or Linux systems have multiple buffers in the kernel, classified as cache or page cache, and most disk I/O is performed through the buffers. When data is written to a file, the kernel usually copies the data to a buffer first. If the buffer is not full, it is not queued to the output queue, but rather waits until the buffer is full or when the kernel runs out of free memory and needs to reuse the buffer to store other disk blocks. When this buffer reaches the head of the output queue, the actual I/O operation is performed. This type of output is called a delayed write.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/23/91989c88b70b4b4b8c3c39187efe8418.png" alt="delayed write"></p>
<h3 id="delayed-write">Delayed write</h3>
<p>When we call the <code>write()</code> function to write data, the function writes the data to the kernel&rsquo;s buffer (just to the buffer) and then returns immediately. Due to the design of the operating system, the data is written to the file for the caller and can be read by other processes, but it does not mean that they have been written to an external permanent storage medium, even after the <code>close()</code> function is called to close the file, because the data in the buffer may still be waiting to be output.</p>
<p>At the hardware level, data written with the <code>write()</code> function is not written to disk synchronously, <strong>the data is written by a dedicated <code>flusher</code> kernel thread when certain conditions are met (e.g., a certain time interval, a certain percentage of dirty pages in memory)</strong> . The time interval for this asynchronous operation depends on the operating system&rsquo;s buffer refresh time, which is typically 30s in the Linux kernel, depending on the amount of data written and the state of the I/O buffers. This interval is indeed long for some scenarios, such as Redis persistence, where seconds of data loss may be unavoidable if the server fails while the data is in the kernel buffer.</p>
<blockquote>
<p>The data in the kernel buffer is &ldquo;written&rdquo; to the disk file. The &ldquo;write&rdquo; here is not to move the data in the buffer to the disk file, but to copy it to the disk file, which means that the buffer contents are not cleared at this time. There is a reason for this design. Suppose the write is done to the disk file and the disk is bad or full, etc. If the buffer is cleared, the data will be lost. The kernel will wait until the write to disk operation is complete before deleting the data from the buffer.</p>
</blockquote>
<p>Delayed writes reduce the number of disk writes, but reduce the speed of file content updates. To ensure consistency between the actual file system on disk and the contents of the buffer cache, the UNIX system provides three system calls, <code>sync()</code>, <code>fsync()</code> and <code>fdatasync()</code>, for refreshing the buffer in the kernel. <code>fsync</code> function.</p>
<p>The <code>fsync()</code> system call works only on a single file specified by the file descriptor fd, immediately adds that file&rsquo;s block buffer to the output queue, and waits for the <code>flusher</code> kernel thread to finish writing that buffer to disk and then returns.</p>
<p><code>fsync()</code> synchronizes not only the update of file data, but also the update of file attributes (atime, mtime, etc.), and is commonly used in database applications, which need to ensure that modified buffer blocks are written to disk immediately.</p>
<p>To put it simply, the <code>write()</code> system call is called to write data to the kernel buffer, and the <code>*sync</code> function queues the buffer to the output queue, where the daemon is responsible for writing the buffer in the queue to disk.</p>
<h3 id="persistence-process">Persistence Process</h3>
<p>A brief overview of the Redis persistence process is given in <a href="http://antirez.com/post/redis-persistence-demystified.html">Redis persistence demystified</a> by Reids author antirez.</p>
<ol>
<li>the client sends a write command to the database (the data is in the client&rsquo;s memory)</li>
<li>the database receives the write command (the data is in the server&rsquo;s memory)</li>
<li>the database calls the <code>write()</code> system call to write the data to disk (the data is in the system kernel buffer)</li>
<li>the operating system transfers the data to the disk controller (data is on the disk cache)</li>
<li>the disk controller writes the data to the physical media</li>
</ol>
<p>As you can see from the previous summary, the <code>write()</code> system call can control step 3, the <code>fsync</code> system call can control step 4, but step 5 depends on the disk hardware and is out of our hands.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/23/9f700e09a2d04a35966c33c22305a9ef.png" alt="redis Persistence"></p>
<p>If the failure we are considering involves only the database software level and not the OS kernel (e.g., the database process is killed or crashed), the write operation can be considered safe after a successful return from step 3. After the <code>write()</code> system call returns, the data is transferred to the kernel, which writes the data to disk even if the database process crashes. If you consider a sudden power outage or a more catastrophic situation where all caches have been invalidated, the write operation can be considered safe only after step 5 is completed.</p>
<p>After understanding the deferred write and persistence process, let&rsquo;s analyze how Redis persists.</p>
<h2 id="rdb-snapshot">RDB Snapshot</h2>
<p>RDB (Redis DataBase) is a snapshot storage persistence method that saves the in-memory data of Redis at a certain point in time to a file on disk, with the default file name <code>dump.rdb</code>. When the Redis server starts, it will reload the data from the <code>dump.rdb</code> file into the memory to restore the data.</p>
<p>There are two ways to start RDB snapshot backup, one is the client sends execute RDB command to the server to start backup manually, the other is to set the conditions to trigger RDB snapshot, and the program automatically checks whether backup is needed.</p>
<p>No matter which backup method is used, the backup process of RDB is as follows.</p>
<ol>
<li>write the memory data to a temporary rdb file.</li>
<li>replace the original official rdb file with the temporary one after the data is written.</li>
<li>delete the original rdb file.</li>
</ol>
<h3 id="data-structure">Data structure</h3>
<p>Since the structure definition about RDB snapshot is rather complicated, involving RDB state, pipeline communication, sub-process information, etc., only the main variable definitions are listed below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* RDB persistence */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">dirty</span><span class="p">;</span>                <span class="cm">/* Changes to DB from the last save */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="kt">long</span> <span class="n">dirty_before_bgsave</span><span class="p">;</span>  <span class="cm">/* Used to restore dirty on failed BGSAVE */</span>
</span></span><span class="line"><span class="cl">    <span class="n">pid_t</span> <span class="n">rdb_child_pid</span><span class="p">;</span>            <span class="cm">/* PID of RDB saving child */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">saveparam</span> <span class="o">*</span><span class="n">saveparams</span><span class="p">;</span>   <span class="cm">/* Save points array for RDB */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">saveparamslen</span><span class="p">;</span>              <span class="cm">/* Number of saving points */</span>
</span></span><span class="line"><span class="cl">    <span class="n">time_t</span> <span class="n">rdb_save_time_last</span><span class="p">;</span>      <span class="cm">/* Time used by last RDB save run. */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rdb_bgsave_scheduled</span><span class="p">;</span>       <span class="cm">/* BGSAVE when possible if true. */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">lastbgsave_status</span><span class="p">;</span>          <span class="cm">/* C_OK or C_ERR */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="manually-triggered">Manually triggered</h3>
<p>There are two scenarios to trigger a manual backup, one is to execute a Redis program command (not to force kill the process), where the program will perform an RDB snapshot backup to load the data the next time Redis is started. The other is that the client sends <code>SAVE</code> or <code>BGSAVE</code> commands to the server, the <strong>difference between these two commands is that the <code>SAVE</code> command uses Redis&rsquo; main process to perform the backup</strong>, which causes the Redis server to block and all command requests sent by the client will be rejected until the RDB file is created. <strong>The <code>BGSAVE</code> command will fork a child process to perform I/O writes</strong>, while the main process can still process the command requests. Note that the child process snapshot backs up the data as it was when it was created; data added, modified, or deleted during the execution of the backup is not backed up.</p>
<p>Both commands eventually call the <code>rdbSave()</code> function to save the database to disk, and <code>fsync</code> is executed immediately after executing <code>write</code> to avoid data being left in the kernel buffer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">rdbSave</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="n">rdbSaveInfo</span> <span class="o">*</span><span class="n">rsi</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">rioInitWithFile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdb</span><span class="p">,</span><span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Start backup
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">startSaving</span><span class="p">(</span><span class="n">RDBFLAGS_NONE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">rdb_save_incremental_fsync</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">rioSetAutoSync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdb</span><span class="p">,</span><span class="n">REDIS_AUTOSYNC_BYTES</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">rdbSaveRio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdb</span><span class="p">,</span><span class="o">&amp;</span><span class="n">error</span><span class="p">,</span><span class="n">RDBFLAGS_NONE</span><span class="p">,</span><span class="n">rsi</span><span class="p">)</span> <span class="o">==</span> <span class="n">C_ERR</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">errno</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="n">werr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fflush</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span> <span class="k">goto</span> <span class="n">werr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fsync</span><span class="p">(</span><span class="n">fileno</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">goto</span> <span class="n">werr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span> <span class="k">goto</span> <span class="n">werr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the <code>BGSAVE</code> command is executed, Redis will store the child process IDs in <code>redisServer.rdb_child_pid</code>, which will be set to -1 when the <code>BGSAVE</code> command is executed, to determine if there are any child processes executing the task.</p>
<p>For performance and avoiding concurrency problems, Redis checks the current server state when executing RDB commands, and does not allow any more persistence operations during the <code>BGSAVE</code> command, and the AOF command is also delayed until the RDB snapshot is completed to avoid conflicts caused by multiple processes doing a lot of write operations. In addition, before <code>BGSAVE</code> (and AOF and MODULE related commands) is executed, the program will check if there are other sub-processes running, and if there are, it will terminate the execution and return an error.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">rdbSaveBackground</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="n">rdbSaveInfo</span> <span class="o">*</span><span class="n">rsi</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">hasActiveChildProcess</span><span class="p">())</span> <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">hasActiveChildProcess</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">server</span><span class="p">.</span><span class="n">rdb_child_pid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">           <span class="n">server</span><span class="p">.</span><span class="n">aof_child_pid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">           <span class="n">server</span><span class="p">.</span><span class="n">module_child_pid</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="automatic-triggering">Automatic triggering</h3>
<p>In addition to letting clients send commands to trigger backups manually, Redis also provides automatic interval RDB backups, where we can set one or more trigger conditions with the <code>save &lt;seconds&gt; &lt;changes&gt;</code> command, indicating that if at least <code>changes</code> of data changes occur within <code>seconds</code> seconds, it will automatically trigger the <code>bgsave</code> command.</p>
<p>The trigger conditions are stored in <code>redisServer.saveparams</code> and are represented using the structure <code>saveparam</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">saveparam</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">time_t</span> <span class="n">seconds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">changes</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Redis also holds a <code>redisServer.dirty</code> counter that holds the number of times the database has been modified since the last successful RDB execution, and <code>redisServer.lastsave</code> that keeps track of the time since the last successful RDB execution. In the server-side cycle function <code>serverCron()</code> will periodically check if there is currently a child process performing persistence tasks, and if not, it will check if RDB or AOF persistence needs to be performed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">serverCron</span><span class="p">(</span><span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">hasActiveChildProcess</span><span class="p">()</span> <span class="o">||</span> <span class="n">ldbPendingChildren</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Whether a child process completes the task
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">checkChildrenDone</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// Check if the BGSAVE command needs to be executed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">server</span><span class="p">.</span><span class="n">saveparamslen</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">struct</span> <span class="n">saveparam</span> <span class="o">*</span><span class="n">sp</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">saveparams</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">changes</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="o">-</span><span class="n">server</span><span class="p">.</span><span class="n">lastsave</span> <span class="o">&gt;</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">seconds</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">unixtime</span><span class="o">-</span><span class="n">server</span><span class="p">.</span><span class="n">lastbgsave_try</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">                 <span class="n">CONFIG_BGSAVE_RETRY_DELAY</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                 <span class="n">server</span><span class="p">.</span><span class="n">lastbgsave_status</span> <span class="o">==</span> <span class="n">C_OK</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_NOTICE</span><span class="p">,</span><span class="s">&#34;%d changes in %d seconds. Saving...&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">sp</span><span class="o">-&gt;</span><span class="n">changes</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">seconds</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">rdbSaveInfo</span> <span class="n">rsi</span><span class="p">,</span> <span class="o">*</span><span class="n">rsiptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">rsiptr</span> <span class="o">=</span> <span class="n">rdbPopulateSaveInfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsi</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">rdbSaveBackground</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">rdb_filename</span><span class="p">,</span><span class="n">rsiptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// Whether to execute AOF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">aof_state</span> <span class="o">==</span> <span class="n">AOF_ON</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="o">!</span><span class="n">hasActiveChildProcess</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="n">server</span><span class="p">.</span><span class="n">aof_rewrite_perc</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="n">server</span><span class="p">.</span><span class="n">aof_current_size</span> <span class="o">&gt;</span> <span class="n">server</span><span class="p">.</span><span class="n">aof_rewrite_min_size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">long</span> <span class="kt">long</span> <span class="n">base</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="n">aof_rewrite_base_size</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">                <span class="n">server</span><span class="p">.</span><span class="nl">aof_rewrite_base_size</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="kt">long</span> <span class="kt">long</span> <span class="n">growth</span> <span class="o">=</span> <span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">aof_current_size</span><span class="o">*</span><span class="mi">100</span><span class="o">/</span><span class="n">base</span><span class="p">)</span> <span class="o">-</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">growth</span> <span class="o">&gt;=</span> <span class="n">server</span><span class="p">.</span><span class="n">aof_rewrite_perc</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">serverLog</span><span class="p">(</span><span class="n">LL_NOTICE</span><span class="p">,</span><span class="s">&#34;Starting automatic rewriting of AOF on %lld%% growth&#34;</span><span class="p">,</span><span class="n">growth</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">rewriteAppendOnlyFileBackground</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This section also posts the code to execute AOF, and the detailed process is described below.</p>
<h2 id="aof-logging">AOF Logging</h2>
<p>AOF is an Append Only File persistence scheme that records each modified database command as an append independent log. AOF files are saved in Redis RESP communication protocol format for AOF data recovery. For example, execute the following command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">redis 127.0.0.1:6379&gt; <span class="nb">set</span> key1 Hello
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">redis 127.0.0.1:6379&gt; append key1 <span class="s2">&#34; World!&#34;</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">12</span>
</span></span><span class="line"><span class="cl">redis 127.0.0.1:6379&gt; del key1
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">redis 127.0.0.1:6379&gt; del non_existing_key
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The first 3 of these commands change the database, while the 4th command does not, because the key does not exist in the database. The AOF logs generated are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ cat appendonly.aof 
</span></span><span class="line"><span class="cl">*2<span class="nv">$6</span>SELECT<span class="nv">$10</span>*3<span class="nv">$3</span>set<span class="nv">$4</span>key1<span class="nv">$5</span>Hello*3<span class="nv">$6</span>append<span class="nv">$4</span>key1<span class="nv">$7</span> World!*2<span class="nv">$3</span>del<span class="nv">$4</span>key1
</span></span></code></pre></td></tr></table>
</div>
</div><p>You can see that the last delete command is not logged to avoid unnecessary I/O write operations affecting performance.</p>
<h3 id="data-structures">Data structures</h3>
<p>There are also many variables associated with AOF, and some of the main ones are selected here as well.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">redisServer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* AOF persistence */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">aof_state</span><span class="p">;</span>                  <span class="cm">/* AOF_(ON|OFF|WAIT_REWRITE) */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">aof_fsync</span><span class="p">;</span>                  <span class="cm">/* Kind of fsync() policy */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">aof_no_fsync_on_rewrite</span><span class="p">;</span>    <span class="cm">/* Don&#39;t fsync if a rewrite is in prog. */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">aof_rewrite_perc</span><span class="p">;</span>           <span class="cm">/* Rewrite AOF if % growth is &gt; M and... */</span>
</span></span><span class="line"><span class="cl">    <span class="n">off_t</span> <span class="n">aof_rewrite_min_size</span><span class="p">;</span>     <span class="cm">/* the AOF file is at least N bytes. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">off_t</span> <span class="n">aof_fsync_offset</span><span class="p">;</span>         <span class="cm">/* AOF offset which is already synced to disk. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">pid_t</span> <span class="n">aof_child_pid</span><span class="p">;</span>            <span class="cm">/* PID if rewriting process */</span>
</span></span><span class="line"><span class="cl">    <span class="n">sds</span> <span class="n">aof_buf</span><span class="p">;</span>      <span class="cm">/* AOF buffer, written before entering the event loop */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">aof_fd</span><span class="p">;</span>       <span class="cm">/* File descriptor of currently selected AOF file */</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Indicates whether fsync() needs to be actively executed every time a certain amount of data is written
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">aof_rewrite_incremental_fsync</span><span class="p">;</span><span class="cm">/* fsync incrementally while aof rewriting? */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rdb_save_incremental_fsync</span><span class="p">;</span>   <span class="cm">/* fsync incrementally while rdb saving? */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The AOF feature provides three <code>aof_fsync</code> policies to perform logging functions at different time frequencies, and Redis adds commands and parameters to the buffer <code>redisServer.aof_buf</code> before entering the event loop. Depending on the fsync policy, the size of the buffer may change.</p>
<ul>
<li><strong>always</strong>: Redis calls the <code>write()</code> system call in each event loop to write everything in the AOF buffer to the kernel cache and immediately calls the <code>fsync()</code> system call to synchronize the AOF file. always is the least efficient of the three policies, but it is also the safest, and in the event of a failover, the AOF persistence also only loses command data from the most recent event loop.</li>
<li><strong>everysec</strong>: Redis calls the <code>write()</code> system call in each event loop to write all the contents of the AOF buffer to the kernel cache, and the <code>fsync()</code> system call every second to synchronize the AOF file. This process is performed in a subthread, which is more efficient and only loses up to the last second of data.</li>
<li><strong>no</strong>: Redis calls the <code>write()</code> system call in each event loop to write all the contents of the AOF buffer to the kernel cache, while the synchronization of the AOF file is controlled by the operating system. The speed in this mode is comparable to the RDB method, but the synchronization interval is longer and more data may be lost in case of failure.</li>
</ul>
<p>Of the three file synchronization policies provided by Redis, the more frequently the system call <code>fsync()</code> is used, the less efficient it is to read and write, but the more secure it is and the less data is lost in the event of downtime.</p>
<h3 id="aof-file-rewrites">AOF file rewrites</h3>
<p>Because AOF persistence records Redis state by storing the executed write commands, as Redis runs longer, the size of the AOF file grows, and if left unchecked, an oversized AOF file is likely to impact the server.</p>
<p>To address the problem of AOF file size bloat, Redis provides an AOF file rewrite feature that creates a new AOF file to replace the existing AOF file. Both the old and new AOF files hold the same Redis state, but are typically much smaller than the old AOF file because the new AOF file does not contain redundant commands, as in the following example.</p>
<ul>
<li>Expired data is no longer written to the AOF file.</li>
<li>Invalid commands are no longer written to the AOF file.</li>
<li>Multiple commands can be combined into a single one. For example: <code>sadd myset v1, sadd myset v2, sadd myset v3</code> can be merged into <code>sadd myset v1 v2 v3</code>.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/23/0552826790204e4ba618a69cb805cd35.png" alt="AOF Rewrite"></p>
<p>Enabling AOF rewriting can be triggered manually by executing <code>BGREWRITEAOF</code>, or you can set the following two configuration items to let the program determine the trigger timing automatically.</p>
<ul>
<li>auto-aof-rewrite-min-size: the minimum size of the file when performing AOF rewrites, the default value is 64MB.</li>
<li>auto-aof-rewrite-percentage: the ratio of the current AOF size (aof_current_size) to the last rewritten AOF size (aof_base_size) when performing AOF rewrites.</li>
</ul>
<p>When the user executes the <code>BGREWRITEAOF</code> command, Redis calls the <code>rewriteAppendOnlyFileBackground()</code> function, which forks a child process that rewrites the AOF file in a temporary file, at which point the main process appends the newly entered write command to the <code>redisServer .aof_rewrite_buf</code> buffer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">rewriteAppendOnlyFileBackground</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">pid_t</span> <span class="n">childpid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Whether other child processes exist
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">hasActiveChildProcess</span><span class="p">())</span> <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">aofCreatePipes</span><span class="p">()</span> <span class="o">!=</span> <span class="n">C_OK</span><span class="p">)</span> <span class="k">return</span> <span class="n">C_ERR</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">openChildInfoPipe</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">redisFork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">tmpfile</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="cm">/* Child */</span>
</span></span><span class="line"><span class="cl">        <span class="n">redisSetProcTitle</span><span class="p">(</span><span class="s">&#34;redis-aof-rewrite&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Create temporary files and perform AOF rewrites
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">snprintf</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="s">&#34;temp-rewriteaof-bg-%d.aof&#34;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">rewriteAppendOnlyFile</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">)</span> <span class="o">==</span> <span class="n">C_OK</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">sendChildCOWInfo</span><span class="p">(</span><span class="n">CHILD_INFO_TYPE_AOF</span><span class="p">,</span> <span class="s">&#34;AOF rewrite&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">exitFromChild</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">exitFromChild</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The Redis server-side cycle executor constantly checks to see if any child processes have finished executing their tasks (this code is posted in the RDB auto-trigger subsection). When a child process completes an AOF rewrite, the parent process calls the <code>backgroundRewriteDoneHandler()</code> function, which writes the accumulated rewrite cache to a temporary file, renames the new file, and sets the fd of the new file as the write target of the AOF program.</p>
<h2 id="summary">Summary</h2>
<p>Finally, to summarize the advantages and disadvantages of RDB and AOF.</p>
<ul>
<li>RDB will call <code>fsync()</code> to write data to disk cache immediately after calling <code>write()</code>, while AOF will write data to disk at different timing according to <code>aof_fsync</code> policy.</li>
<li>RDB is a compact compressed binary file representing a backup of Redis data at a point in time, suitable for full replication scenarios, such as performing a <code>BGSAVE</code> backup every 6 hours and copying the RDB file to a remote machine or file system for disaster recovery.</li>
<li>Redis loads RDB to recover data much faster than the AOF approach.</li>
<li>RDB way data can&rsquo;t do real-time persistence, whether AOF way can do real-time persistence, you need to set <code>aof_fsync</code> policy to always.</li>
</ul>
<p>Redis&rsquo; persistence scheme makes some trade-offs between performance and speed, using subprocesses to improve performance for non-real-time persistence. While there is some performance loss in <strong>performing true real-time persistence</strong>, the most common scenario for Redis is as a data cache, possibly as a fallback option.</p>
<h2 id="reference">Reference</h2>
<ul>
<li><code>https://wingsxdu.com/posts/database/redis/rdb-and-aof/</code></li>
<li><code>http://antirez.com/post/redis-persistence-demystified.html</code></li>
<li><code>http://byteliu.com/2019/03/09/Linux-IO%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0-sync%E3%80%81fsync%E3%80%81fdatasync/</code></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/redis/">redis</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/redis-slowlog/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Redis Slowlog</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/redis-single-thread/">
            <span class="next-text nav-default">How Redis achieves high performance with &#34;single thread&#34;</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
