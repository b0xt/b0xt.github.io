<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Reverse mapping of anonymous pages in Linux - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Exploring the reverse mapping of anonymous pages in Linux." /><meta name="keywords" content="linux, Reverse mapping of anonymous pages" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/linux-anonymous-pages-reverse-mapping/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Reverse mapping of anonymous pages in Linux" />
<meta property="og:description" content="Exploring the reverse mapping of anonymous pages in Linux." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/linux-anonymous-pages-reverse-mapping/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-15T09:55:48+08:00" />
<meta property="article:modified_time" content="2022-08-15T09:55:48+08:00" />

<meta itemprop="name" content="Reverse mapping of anonymous pages in Linux">
<meta itemprop="description" content="Exploring the reverse mapping of anonymous pages in Linux."><meta itemprop="datePublished" content="2022-08-15T09:55:48+08:00" />
<meta itemprop="dateModified" content="2022-08-15T09:55:48+08:00" />
<meta itemprop="wordCount" content="1974">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Reverse mapping of anonymous pages in Linux"/>
<meta name="twitter:description" content="Exploring the reverse mapping of anonymous pages in Linux."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Reverse mapping of anonymous pages in Linux</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-15 09:55:48 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1974 words </span>
          <span class="more-meta"> 10 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#vma">vma</a></li>
        <li><a href="#anon_vma">anon_vma</a>
          <ul>
            <li><a href="#introduction-of-reverse-mapping">Introduction of reverse mapping</a></li>
            <li><a href="#object-based-reverse-mapping">Object-based reverse mapping</a></li>
            <li><a href="#reverse-mapping-of-anonymous-pages">Reverse mapping of anonymous pages</a></li>
          </ul>
        </li>
        <li><a href="#anon_vma_chain">anon_vma_chain</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Linux provides the memory map feature, which implements the mapping of physical memory pages into the process address space for efficient data manipulation or transfer. The kernel uses three important data structures <code>struct vm_area_struct</code> , <code>struct anon_vma</code> and <code>struct anon_vma_chain</code> to handle this feature, so it is important to understand these three data structures, and this article tries to clarify the origin and connection between them.</p>
<h2 id="vma">vma</h2>
<p>The <a href="http://elixir.free-electrons.com/linux/v2.6.35.14/source/include/linux/mm_types.h#L130">struct vm_area_struct</a> is often referred to as <code>vma</code> in kernel code, so This structure is referred to by <code>vma</code> in the following.</p>
<p><code>vma</code> is a unit of memory mapping, which represents a contiguous segment of the process address space, where the fields <code>vm_start</code> and <code>vm_end</code> indicate the starting virtual address of this contiguous segment. When creating a map using the <code>mmap</code> system call, the user specifies the <strong>start address (optional)</strong> and <strong>length</strong>, and the kernel will look for a legal <code>vma</code> in the process address space for the map accordingly. <code>cat /proc/&lt;pid&gt;/maps</code> allows you to see all the mapped intervals for a process.</p>
<h2 id="anon_vma">anon_vma</h2>
<p>The introduction of <a href="http://elixir.free-electrons.com/linux/v2.6.35.14/source/include/linux/rmap.h#L27">anon_vma</a> needs some explanation.</p>
<h3 id="introduction-of-reverse-mapping">Introduction of reverse mapping</h3>
<p>When the Linux system runs out of memory, the swap subsystem releases some pages and swaps them into the swap device to free up extra memory pages. The idea of virtual memory is to maintain a mapping of virtual addresses to physical addresses through <strong>page-tables</strong>. However, <strong>page-table</strong> is a <strong>one-way mapping</strong>, i.e., it is easy to find a physical address through a virtual address, but conversely it is troublesome to find a virtual address through a physical address. This problem is more serious in the case of shared memory. The swap subsystem encounters this problem when releasing a page. For a particular page (physical address), it has to find the ``Page Table Entry (PTE)` mapped to it and modify the <strong>PTE</strong> to point to the location of that page in the swap device. In pre-2.4 kernels, this was a time-consuming task because the kernel had to traverse all page tables for each process to find all page table entries that mapped to that page.</p>
<p>The solution to this problem is to introduce the concept of <strong>reverse mapping</strong>. This is done by maintaining a data structure for each memory page (<code>struct page</code>) that contains all the <code>PTEs</code> mapped to that page, so that when looking for the reverse mapping of a memory page, one can simply scan this structure, which greatly improves efficiency. This is exactly what Rik van Riel did by adding a <code>pte_chain</code> field to the <code>struct page</code>, which is a pointer to a chain of all the PTEs mapped to that page.</p>
<p>Of course, it comes at a cost.</p>
<ul>
<li>Each <code>struct page</code> adds a field, and each memory page in the system corresponds to a <code>struct page</code> structure, which means that a considerable amount of memory is used to maintain this field. This means that a significant amount of memory is used to maintain this field. Since <code>struct page</code> is an important kernel data structure stored in limited low-end memory, adding a field wastes a significant amount of valuable low-end memory, and this is especially true when the physical memory is large, which causes <strong>scalability</strong> problems.</li>
<li>Other functions that need to manipulate a large number of pages slow down. The <code>fork()</code> system call is one. Since Linux adopts the semantics of <strong>Copy On Write (COW)</strong>, which means that the new process shares the parent&rsquo;s page table, all pages in the process address space have a new PTE pointing to it, so a new reverse map is needed for each page, which slows things down significantly.</li>
</ul>
<h3 id="object-based-reverse-mapping">Object-based reverse mapping</h3>
<p>This cost was clearly intolerable, so Dave McCracken proposed a solution called <strong>object-based reverse mapping</strong>. His observation was that the costs described earlier came from the introduction of the reverse mapping field, whereas if there were all the page table entries that could be fetched from a <code>struct page</code> that mapped to that page, the field would not be needed, and there would be no need for these costs. He did find a way to do this.</p>
<p>Linux user state memory pages are divided into <strong>two broad usage cases</strong>:</p>
<ul>
<li>A large part of them is called <strong>file-backed page</strong>, which, as the name implies, is a memory page whose contents are associated with a file in the backing storage system, such as program code, or a normal text file, which is generally mapped into address space using the <code>mmap</code> system call mentioned above, and, in case of memory crunch, can simply be This type of memory page is usually mapped to address space by the <code>mmap</code> system call described above, and can be simply discarded when memory is tight because it can be easily recovered from a backup file.</li>
<li>This is a general type of memory page, such as stack or heap memory, which has no backup file, which is why it is called <strong>anonymous</strong>.</li>
</ul>
<p>The <strong>object</strong> in Dave&rsquo;s scheme refers to the first type of memory page <strong>backup file</strong>. He calculates the PTE in a roundabout way by <strong>backing file object</strong>, which will not be described too much in this paper.</p>
<h3 id="reverse-mapping-of-anonymous-pages">Reverse mapping of anonymous pages</h3>
<p>Dave&rsquo;s solution only solves the first kind of reverse mapping of memory pages, so Andrea Arcangeli follows Dave&rsquo;s lead and gives a solution for reverse mapping of anonymous pages.</p>
<p>As mentioned earlier, there is no such thing as a <strong>backup file</strong> for anonymous pages, but one of the characteristics of anonymous pages is that they are private, not shared (e.g., stacks and vertex memory are process-independent and not shared). This means that <strong>for each anonymous memory page, there is only one PTE associated with it, that is, there is only one vma associated with it</strong> . Andrea&rsquo;s solution is to reuse the <code>mapping</code> field of the <code>struct page</code>, because for anonymous pages, <code>mapping</code> is <code>null</code> and does not point to a fallback space. In the case of anonymous pages, the <code>mapping</code> field is not a pointer to the <code>struct address_space</code>, but to the unique <code>vma</code> associated with the memory page, using the C language <code>union</code>. This also makes it easy to calculate the PTE.</p>
<p>However, things are not so simple. When a process is copied by fork, as already mentioned, due to the semantics of COW, the new process just copies the page table of the parent process, which means that now <strong>one anonymous page has two page tables pointing to it</strong>, so the above simple reuse of the <code>mapping</code> field doesn&rsquo;t work, because how can one pointer, represent two vma&rsquo;s.</p>
<p>Andrea&rsquo;s approach is to <strong>add an extra layer</strong>. Create a new <code>struct anon_vma</code> structure, which now has the <code>mapping</code> field pointing to it, and <code>anon_vma</code> which, not surprisingly, contains a link to all the <code>vma</code>s. Whenever a process forks a child process, the child process copies the <code>vma</code> of the parent process due to the COW mechanism, and this new <code>vma</code> is linked to the <code>anon_vma</code> of the parent process. In this way, every time a memory page is unmaped, the <code>anon_vma</code> pointed by the <code>mapping</code> field can find the <code>vma</code> chain that may be associated with that page, and traverse the chain to find all the PTEs mapped to that anonymous page.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/15/7e23ddf7be214191aa02dcd80f73cc97.png" alt="struct anon_vma"></p>
<p>This has a cost, too, in that</p>
<ul>
<li>Each <code>struct vm_area_struct</code> structure has an extra <code>list_head</code> structure field to string together all the <code>vma</code>s.</li>
<li>Additional memory needs to be allocated for the <code>anon_vma</code> structure.</li>
</ul>
<p>However, this solution requires much less memory than adding a reverse mapping field to each <code>struct page</code> as mentioned above, so it is acceptable.</p>
<p>This is the end of the introduction of the <code>anon_vma</code> structure and its role.</p>
<h2 id="anon_vma_chain">anon_vma_chain</h2>
<p>The <code>anon_vma</code> structure was proposed to improve the reverse mapping mechanism, and it seems to be a perfect solution in terms of efficiency and memory usage. However, reality continues to pose problems. Rik van Riel, mentioned at the beginning, cites a workload <a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=5beb49305251e5669852ed541e8e2f2f7696c53e">example</a> to argue against the flawed solution.</p>
<p>The previous anonymous page reverse mapping mechanism, when unmapping a page, accesses the <code>vma</code> linked list by accessing <code>anon_vma</code> and traversing the entire <code>vma</code> linked list, to find a PTE that might map to that page.</p>
<p>However, this approach misses one point: if a write access occurs to a <code>vma</code> in a child process copied by a process fork, a new anonymous page will be allocated and the <code>vma</code> will be pointed to this new anonymous page, which is no longer related to the original anonymous page, but the original <code>vma</code> linked list does not reflect this change, resulting in unnecessary access to the <code>vma</code>. This leads to unnecessary checking of the <code>vma</code>. The example given by Rik describes this extreme case.</p>
<p>Rik&rsquo;s solution is to add another layer, a new structure called <a href="http://elixir.free-electrons.com/linux/v2.6.35.14/source/include/linux/rmap.h#L65">anon_vma_chain</a>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The copy-on-write semantics of fork mean that an anon_vma
</span></span></span><span class="line"><span class="cl"><span class="cm"> * can become associated with multiple processes. Furthermore,
</span></span></span><span class="line"><span class="cl"><span class="cm"> * each child process will have its own anon_vma, where new
</span></span></span><span class="line"><span class="cl"><span class="cm"> * pages for that process are instantiated.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * This structure allows us to find the anon_vmas associated
</span></span></span><span class="line"><span class="cl"><span class="cm"> * with a VMA, or the VMAs associated with an anon_vma.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The &#34;same_vma&#34; list contains the anon_vma_chains linking
</span></span></span><span class="line"><span class="cl"><span class="cm"> * all the anon_vmas associated with this VMA.
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The &#34;same_anon_vma&#34; list contains the anon_vma_chains
</span></span></span><span class="line"><span class="cl"><span class="cm"> * which link all the VMAs associated with this anon_vma.
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">anon_vma_chain</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">anon_vma</span> <span class="o">*</span><span class="n">anon_vma</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">same_vma</span><span class="p">;</span>   <span class="cm">/* locked by mmap_sem &amp; page_table_lock */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">same_anon_vma</span><span class="p">;</span> <span class="cm">/* locked by anon_vma-&gt;lock */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Each <code>anon_vma_chain</code> (AVC) maintains two linked lists</p>
<ul>
<li>same_vma: all the <code>anon_vma</code> associated with the given <code>vma</code></li>
<li>same_anon_vma: all <code>vma</code> associated with the given <code>anon_vma</code></li>
</ul>
<p>Initially, we have a process with an anonymous <code>vma</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/15/1f66c2e40836451cb9cebe0e4a8a1ebc.png" alt="a process with an anonymous vma"></p>
<p>Here, &ldquo;AV&rdquo; is <code>anon_vma</code> and &ldquo;AVC&rdquo; is the <code>anon_vma_chain</code> seen above. AVC links directly to <code>anon_vma</code> and <code>vma</code> via pointers. （The (blue) linked list is the same_anon_vma linked list, and the (red) linked list is the same_vma linked list.</p>
<p>Imagine that the process performs a fork operation, causing the child process to copy <code>vma</code>; now there is a new <code>vma</code> in isolation.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/15/f2d83d94ff834427a60ad9af61c2c816.png" alt="An isolated new vma"></p>
<p>The kernel needs to link this <code>vma</code> to the <code>anon_vma</code> of the parent process; this requires adding a new <code>anon_vma_chain</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/15/05bfa964edde4bd6b47f52c06ed49aa7.png" alt="anon_vma_chain"></p>
<p>Note that the new AVC has been added to the same_anon_vma chain. The new <code>vma</code> also needs its own <code>anon_vma</code> :</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/15/9797d82af5dc4257bf7f04d7f2406b4f.png" alt="anon_vma"></p>
<p>There is now another <code>anon_vma_chain</code> linked in the new <code>anon_vma</code>. The new AVC has been added to the same_vma linked list.</p>
<p>At this moment, according to the figure above, you can verify the role of the two chains in <code>anon_vma_chain</code> (AVC).</p>
<blockquote>
<p>The &ldquo;same_vma&rdquo; list contains the anon_vma_chains linking all the anon_vmas associated with this VMA.
The &ldquo;same_anon_vma&rdquo; list contains the anon_vma_chains which link all the VMAs associated with this anon_vma.</p>
</blockquote>
<p>When a child process writes a memory page, COW occurs and the child process&rsquo;s <code>vma</code> will point to its own anonymous page, and at the same time, this new anonymous page points to the child process&rsquo;s <code>anon_vma</code> (at this point the same_anon_vma chain is unlinked from the same_vma chain).</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/15/c2004530eeed4bbebf54db100b7d883c.png" alt="same_anon_vma chain is unlinked from the same_vma chain"></p>
<p>In this way, when unmapping a page, for the child process&rsquo;s own anonymous page, it only needs to traverse the <code>vma</code> chain under the child process&rsquo;s own <code>anon_vma</code>. This greatly reduces the number of <code>vma</code>s that the parent process needs to traverse.</p>
<p>The name <code>anon_vma_chain</code> is like a glue and a chain that links the <code>vma</code> and <code>anon_vma</code> associated with the parent and child processes at the beginning, and when the child process has its own anonymous page through the COW, it will unlink the chain and manage it separately with a split policy, thus reducing the number of <code>vma vma</code>s traversed by the parent process when unmapping a page, which also reduces the corresponding lock conflicts and thus improves efficiency.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/google-cpp-style/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Google C&#43;&#43; Style Excerpt Notes</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/fingerprint/">
            <span class="next-text nav-default">Introduction to Browser Fingerprinting Technology</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
