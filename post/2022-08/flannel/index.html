<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Flannel for Cloud-Native Virtual Networks - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore how Flannel works." /><meta name="keywords" content="Flannel" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/flannel/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Flannel for Cloud-Native Virtual Networks" />
<meta property="og:description" content="Explore how Flannel works." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/flannel/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-13T11:58:48+08:00" />
<meta property="article:modified_time" content="2022-08-13T11:58:48+08:00" />

<meta itemprop="name" content="Flannel for Cloud-Native Virtual Networks">
<meta itemprop="description" content="Explore how Flannel works."><meta itemprop="datePublished" content="2022-08-13T11:58:48+08:00" />
<meta itemprop="dateModified" content="2022-08-13T11:58:48+08:00" />
<meta itemprop="wordCount" content="2192">
<meta itemprop="keywords" content="cloud-native," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Flannel for Cloud-Native Virtual Networks"/>
<meta name="twitter:description" content="Explore how Flannel works."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Flannel for Cloud-Native Virtual Networks</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-13 11:58:48 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2192 words </span>
          <span class="more-meta"> 11 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#installation">Installation</a></li>
        <li><a href="#subnet">Subnet</a></li>
        <li><a href="#flannel-backend">Flannel backend</a>
          <ul>
            <li><a href="#udp">udp</a></li>
            <li><a href="#vxlan">VXLAN</a></li>
            <li><a href="#host-gw">host-gw</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>When I used to look at k8s related knowledge, my network knowledge was relatively weak, so I didn&rsquo;t understand the Flannel network. So recently I researched some knowledge of cloud-native virtual networks and wrote two articles: <a href="/post/2022-07/vxlan/">VXLAN Protocol for Cloud-Native Virtual Networks</a> and <a href="/post/2022-07/cloud-native-virtual-networking/">Cloud-native virtual networking tun/tap &amp; veth-pair</a> which introduced some knowledge of virtual networks. These are all for flannel, and now we finally come to the Flannel article.</p>
<h2 id="overview">Overview</h2>
<p>Before we discuss Flannel, let&rsquo;s take a look at Docker&rsquo;s networking model. By default, Docker uses the bridge network mode.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/a3cfc7ae03b24076a44a74b8c9af5e04.png" alt="By default, Docker uses the bridge network mode"></p>
<p>Docker will create a docke0 virtual bridge during installation, then when running the container, create a virtual NIC veth pair device on the host. veth pair devices come in pairs, thus forming a data channel, data coming in from one device will come out from the other. Put one end of the veth pair device in the newly created container named eth0, and the other end in the host docker0, named with the prefix veth, which I described in the previous article <a href="/post/2022-07/cloud-native-virtual-networking/">Cloud-native virtual networking tun/tap &amp; veth-pair</a>.</p>
<p>Under the default configuration of Docker, the docker0 bridges on one host are not associated with the docker0 bridges on other hosts, and there is no way for them to connect to each other. Therefore, the containers connected to these bridges have no way to communicate with each other.</p>
<p>This is where Flannel comes in, which is the main container networking solution from CoreOS. The implementation principle is equivalent to adding an overlay network on top of the original network, where the nodes can be seen as connected by virtual or logical links.</p>
<p>Flannel runs a flanneld agent on each host, which is responsible for pre-assigning a <strong>Subnet subnet</strong> to the host and assigning an ip address to the Pod. Flannel uses Kubernetes or etcd to store network configuration, assigned subnet and host public ip information, and packets are forwarded via VXLAN, UDP or host-gw types of <strong>backend mechanisms</strong>.</p>
<h2 id="installation">Installation</h2>
<p>I used kubeasz for the installation, and generally refer to this document: <a href="https://github.com/easzlab/kubeasz/blob/master/docs/setup/00-planning_and_overall_intro.md">https://github.com/easzlab/kubeasz/blob/master/docs/setup/00-planning_and_overall_intro.md</a>, based on which we can quickly We can build a complete k8s cluster quickly.</p>
<p>After using the command <code>docker exec -it kubeasz ezctl new cluster name</code>, the corresponding cluster configuration will be generated in the <code>/etc/kubeasz/clusters/</code> directory.</p>
<p>As we want to customize the network plugins, remember to modify the <code>/etc/kubeasz/clusters/clusters/hosts</code> file to configure the node information and network plugins.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl"># master node(s)
</span></span><span class="line"><span class="cl">[kube_master]
</span></span><span class="line"><span class="cl">192.168.13.130
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># work node(s)
</span></span><span class="line"><span class="cl">[kube_node]
</span></span><span class="line"><span class="cl">192.168.13.150
</span></span><span class="line"><span class="cl">192.168.13.140
</span></span><span class="line"><span class="cl">192.168.13.130
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Cluster Network Scope
</span></span><span class="line"><span class="cl">CLUSTER_CIDR=&#34;172.20.0.0/16&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># Network plugins supported: calico, flannel, kube-router, cilium, kube-ovn
</span></span><span class="line"><span class="cl">CLUSTER_NETWORK=&#34;flannel&#34;
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>Then modify the Flannel backend configuration <code>/etc/kubeasz/clusters/cluster name/config.yml</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># pod segment mask length on node nodes (determines the maximum number of pod ip addresses that can be assigned to each node) 
</span></span><span class="line"><span class="cl"># i.e. the subnet segmentation range
</span></span><span class="line"><span class="cl">NODE_CIDR_LEN: 24
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># [flannel] Set flannel backend &#34;host-gw&#34;, &#34;vxlan&#34;, etc.
</span></span><span class="line"><span class="cl">FLANNEL_BACKEND: &#34;vxlan&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>You can destroy the environment after each use and then reinstall it. Each reinstallation and destruction is automatic, and believe me, it&rsquo;s the fastest.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">docker <span class="nb">exec</span> -it kubeasz ezctl destroy &lt;Cluster Name&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note that the udp mode is too old and now deprecated, so it is not possible to install it this way. I haven&rsquo;t found a better way to install it yet.</p>
<h2 id="subnet">Subnet</h2>
<p>Flannel To create an overlay network for a cluster, the first step is to plan the ip address of each host container. For example, if I have a three-node k8s cluster, we can see the subnets by running the following command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># cat /run/flannel/subnet.env</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_NETWORK</span><span class="o">=</span>172.20.0.0/16
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_SUBNET</span><span class="o">=</span>172.20.0.1/24
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_MTU</span><span class="o">=</span><span class="m">1450</span>
</span></span><span class="line"><span class="cl"><span class="nv">FLANNEL_ipMASQ</span><span class="o">=</span><span class="nb">true</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>By examining the other two nodes, we can see that in the Flannel network, each pod is assigned a unique ip address and each k8s node has a non-overlapping subnet with no intersection.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/9675c561e5f644aa8d74977ca0e7da6c.png" alt="k8s node"></p>
<p>Let&rsquo;s take a look at how subnets are assigned.</p>
<p>When Flannel is installed, the network segments for the entire cluster are typically set up, as well as the length of the subnets.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span><span class="nt">&#34;Network&#34;</span><span class="p">:</span><span class="s2">&#34;172.20.0.0/16&#34;</span><span class="p">,</span><span class="nt">&#34;SubnetLen&#34;</span><span class="p">:</span><span class="mi">24</span><span class="p">,</span><span class="nt">&#34;Backend&#34;</span><span class="p">:{</span><span class="nt">&#34;Type&#34;</span><span class="p">:</span><span class="s2">&#34;vxlan&#34;</span><span class="p">}}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When you first start Flannel, you run flanneld as an agent in the host, then select an unused subnet from the corresponding network segmentation range as the local subnet, e.g. <code>172.20.0.1/24</code>, and report it to etcd, using the k8s api or etcd for storing the network configuration of the entire cluster. The network segment used by the cluster is recorded according to the configuration.</p>
<p>etcd ensures that the configuration seen by flanned on all nodes is the same. At the same time, the flanned on each node listens to the data changes on etcd and senses the changes of the nodes in the cluster in real time, so that the IPs of the whole cluster are not conflicting with each other.</p>
<h2 id="flannel-backend">Flannel backend</h2>
<p>About Flannel backend The following is about udp, vxlan, host-gw.</p>
<h3 id="udp">udp</h3>
<p>udp is the earliest mode supported by Flannel. There are two main components in this mode: flanneld and flannel0. The flanneld process is responsible for listening to network changes on etcd and sending and receiving packets, while flannel0 is a Layer 3 tun device that is used to pass ip packets between the OS kernel and user applications.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/31bb087955c5438eb2318462b3ad00da.png" alt="Flannel"></p>
<p>As shown above, the tun device is a Layer 3 network layer device, which is used to emulate a virtual NIC and can access each other directly through its virtual IP. tun device reads and writes packets from the /dev/net/tun character device file, and application process A listens to the packets coming from a port and is responsible for sealing and unpacking the data.</p>
<p>All packets sent from application process B to another virtual ip will be packetized by application process A and then sent out; data sent to that virtual NIC will first be sent to the port that application process A is listening to, and then unpacketized by it and sent to application process A. So it is the same for flannel0.</p>
<p>The following diagram shows the data processing process in udp mode.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/5b4b2594eb894148963569caae3a8acf.png" alt="the data processing process in udp mode"></p>
<p>As shown in the diagram, the container with ip <code>172.20.0.8</code> wants to send data to the <code>172.20.1.8</code> container of another node, this packet will be given to the flannel0 device first according to the ip route, then flannel0 will take this ip packet and give it to the application that created this device, which is the flanneld process. process is a udp process that handles the packets sent by flannel0.</p>
<p>The flanneld process will listen to the etcd network information, then match the destination ip address to the corresponding subnet, find the IP address of the host node corresponding to this subnet from etcd, then encapsulate this packet directly in the udp packet and send it to node 2.</p>
<p>Since flanneld on each host listens to port 8285, the flanneld process on the node 2 machine will get the incoming data from port 8285, parse it out and send it to the source ip address encapsulated in it.</p>
<p>flanneld sends this ip packet directly to the tun device it manages, which is the flannel0 device. The network stack then sends the packet based on the route to the cni0 bridge, which acts as a layer 2 switch and sends the packet to the correct port, which then enters the container through the veth pair device.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/276facea067546eba0e648a50c49e544.png" alt="flanneld"></p>
<p>As for the veth-pair, it is a pair of virtual device interfaces that come in pairs, with one end connected to the protocol stack and one end connected to each other, so that data entered at one end of the veth device will flow out of the other end of the device unchanged. The veth in k8s is directly connected to the cni0 bridge, which can be used to send data to different containers on the same node.</p>
<p>The Flannel udp mode described above is now deprecated because it goes through three copies of data between the user and kernel states. The container sends the packet once through the cni0 bridge into the kernel state; the packet goes from the flannel0 device to the flanneld process once more; and the third time, flanneld reenters the kernel state after udp blocking and sends the UDP packet through the eth0 of the host.</p>
<h3 id="vxlan">VXLAN</h3>
<p>Before talking about VXLAN mode, let&rsquo;s see what VXLAN (Virtual Extensible Local Area Network) is, it is a network virtualization technology supported by Linux kernel itself.</p>
<p>VXLAN uses the L2 over L4 (MAC in UDP) message encapsulation mode, which puts the Ethernet frames originally transmitted at Layer 2 into the message body of Layer 4 UDP protocol, and adds its own VXLAN Header, which has 24 Bits of VLAN IDs directly in the VXLAN Header, and can store 16.77 million different values. VXLAN works on Layer 2 networks (the ip network layer) and can be deployed on any network that is Layer 3 reachable (able to communicate with each other via ip). the entire message structure of VXLAN is shown below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/738f4c4af0a24accb7165796522f07b7.png" alt="The entire message structure of the VXLAN"></p>
<p>Through the above message, we can know that it is actually the inner layer of data messages wrapped in another layer, and then through a process called VTEP is responsible for unpacking and sealing packets.</p>
<p>There is also a VNI flag in the VXLAN header, which is mainly used to mark whether the packet belongs to the current tenant and is used for network isolation.</p>
<p>When VXLAN is communicating, VTEP will determine the destination VTEP address by querying the forwarding table FDB before communication. The forwarding table FDB is used to store the MAC address of the remote VM/container, the remote VTEP IP, and the VNI mapping relationship, which is automatically updated by Flannel on k8s through the flanneld process.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/9e296e4c85dd4da9b810d6560d4aabcb.png" alt="flanneld"></p>
<p>For example, if the container in node1 wants to communicate with the container in node2, it will go through the following.</p>
<ul>
<li>Sender: <code>ping 172.20.1.2</code> is initiated in node1, the <code>ICMP</code> message passes through the <code>cni0</code> bridge and is handed over to the <code>flannel.1</code> device for processing. The <code>flannel.1</code> device is a VTEP device for VXLAN and is responsible for VXLAN packet unpacketization. Therefore, on the sending side, <code>flannel.1</code> encapsulates the original L2 packets into VXLAN UDP packets and sends them from <code>eth0</code>.</li>
<li>Receiver side: node2 receives the UDP message, finds out it is a VXLAN type message, and hands it to <code>flannel.1</code> for unpacking. Based on the destination ip in the original packet, the original packet is sent to the corresponding container via the <code>cni0</code> bridge.</li>
</ul>
<h3 id="host-gw">host-gw</h3>
<p>The host-gw mode communication is very simple, it is through the ip route direct connection way to communicate, flanneld is responsible for setting the route for each node, the next hop address of the corresponding node Pod subnet will point to the corresponding node&rsquo;s ip.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/13/ab47389cf1404c2483e1799ffef50619.png" alt="host-gw"></p>
<p>For example, if the node1 container wants to access the node2 container, it will match the following routing rule on the node1 node.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@easzlab ~<span class="o">]</span><span class="c1"># ip r</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">172.20.1.0/24 via 192.168.13.140 dev ens33
</span></span></code></pre></td></tr></table>
</div>
</div><p>This routing rule will send the ip packet whose destination ip address belongs to the <code>172.20.1.0/24</code> segment through the local ens33 device (i.e., dev ens33); and, its next-hop address (next-hop) is <code>192.168.13.140</code>.</p>
<p>Once the next-hop address is configured, then when the ip packet is encapsulated into a frame from the network layer into the link layer, the ens33 device will use the MAC address corresponding to the next-hop address as the destination MAC address of the frame. Obviously, this MAC address is the MAC address of node2.</p>
<p>After node2 gets the ip packet from the frame, it finds that the destination ip address of the ip packet is <code>172.20.1.2</code>, and then it matches the routing rule above node2.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ip r</span>
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">172.20.1.0/24 dev cni0 proto kernel scope link src 172.20.1.1
</span></span></code></pre></td></tr></table>
</div>
</div><p>Then it goes to the cni0 bridge and then to the corresponding container.</p>
<p>From the above, we can see that the core of the host-gw mode working properly is that the ip packet, when encapsulated into a frame and sent out, will use the next hop in the routing table to set the destination MAC address. This way, it goes through the Layer 2 network to the destination host. Therefore, Flannel host-gw mode must require Layer 2 connectivity between the cluster hosts.</p>
<h2 id="summary">Summary</h2>
<p>This article first used kubeasz to quickly build our experimental environment, so that you can quickly simulate one on your own machine. Then we talked about some of the communication mechanisms of Flannel, including subnetting, the three backends (udp, vxlan, host-gw), etc., and studied their implementation principles.</p>
<p>Comparing the three networks, udp mainly uses tun devices to simulate a virtual network for communication; vxlan mode mainly uses vxlan to implement a three-layer overlay network, using flannel1, a vtep device, to seal and unseal packets, and then route and forward them to achieve communication; and host-gw network is more direct, directly changing the routing information of the Layer 2 network to achieve packet forwarding. The host-gw network is more direct, directly changing the routing information of the Layer 2 network to achieve packet forwarding, thus eliminating the intermediate layer and achieving higher communication efficiency.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/cloud-native/">cloud-native</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/python-match-case/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Match-Case in Python 3.10</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/linux-inode/">
            <span class="next-text nav-default">Inode in the Linux file system</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
