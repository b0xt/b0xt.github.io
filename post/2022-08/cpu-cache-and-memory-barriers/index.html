<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>CPU Cache Coherence and Memory Barrier - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article describes the CPU&#39;s cache system and how to use memory barriers for cache synchronization." /><meta name="keywords" content="Cpu Cache, Memory Barriers" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/cpu-cache-and-memory-barriers/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="CPU Cache Coherence and Memory Barrier" />
<meta property="og:description" content="This article describes the CPU&#39;s cache system and how to use memory barriers for cache synchronization." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/cpu-cache-and-memory-barriers/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-16T14:27:25+08:00" />
<meta property="article:modified_time" content="2022-08-16T14:27:25+08:00" />

<meta itemprop="name" content="CPU Cache Coherence and Memory Barrier">
<meta itemprop="description" content="This article describes the CPU&#39;s cache system and how to use memory barriers for cache synchronization."><meta itemprop="datePublished" content="2022-08-16T14:27:25+08:00" />
<meta itemprop="dateModified" content="2022-08-16T14:27:25+08:00" />
<meta itemprop="wordCount" content="4320">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CPU Cache Coherence and Memory Barrier"/>
<meta name="twitter:description" content="This article describes the CPU&#39;s cache system and how to use memory barriers for cache synchronization."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">CPU Cache Coherence and Memory Barrier</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-16 14:27:25 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4320 words </span>
          <span class="more-meta"> 21 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#cache-access-design">Cache Access Design</a>
          <ul>
            <li><a href="#fully-associative">Fully Associative</a></li>
            <li><a href="#direct-mapped">Direct Mapped</a></li>
            <li><a href="#n-way-set-associative">N-Way Set Associative</a></li>
            <li><a href="#summary">Summary</a></li>
          </ul>
        </li>
        <li><a href="#cache-coherence">Cache Coherence</a>
          <ul>
            <li><a href="#snoopy-protocol">Snoopy protocol</a></li>
            <li><a href="#mesi-class-protocol">MESI Class Protocol</a></li>
          </ul>
        </li>
        <li><a href="#memory-model">Memory Model</a>
          <ul>
            <li><a href="#instruction-rearrangement">Instruction Rearrangement</a></li>
            <li><a href="#memory-barrier">Memory Barrier</a></li>
          </ul>
        </li>
        <li><a href="#summary-1">Summary</a></li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>On modern CPUs (most of them), all memory accesses need to go through layers of cache, and understanding the CPU cache update coherency issues can be of great help in designing and debugging our programs. This article will introduce the CPU cache system and how to use memory barriers for cache synchronization.</p>
<p>The memory hierarchy of early computer systems had only three levels: CPU registers, DRAM main memory, and disk storage. Due to the large performance gap between the CPU and main memory, the CPU had to wait a long time to read and write data, so an SRAM cache memory, called L1 cache, had to be inserted between the CPU registers and the main memory. As the performance gap between the CPU and main memory gradually increased, L2 and L3 caches were added gradually, and the access speed between CPU and Cache and Memory was roughly as follows.</p>
<ul>
<li>It takes 1 clock cycle to access CPU registers.</li>
<li>It takes about 4 clock cycles to access the L1 Cache.</li>
<li>Access to L2 Cache takes about 15 clock cycles.</li>
<li>Accessing the L3 Cache takes about 50 clock cycles.</li>
<li>Access to Memory takes approximately 200 clock cycles.</li>
</ul>
<p>The performance gap between CPU and main memory is called the <em><a href="http://en.wikipedia.org/wiki/Von_Neumann_bottleneck">von Neumann bottleneck</a></em> . When we access memory, we encounter many fragmented wait cycles. For example, due to the transfer characteristics of the level protocol, a certain amount of signal stabilization time is required before a row is selected, a column is selected, and reliable data is fetched. On top of that, since main memory uses capacitors to store information, it needs to periodically refresh what it stores in order to prevent information loss due to natural discharge, which can also introduce additional wait times. Some sequential memory accesses may be more efficient but also have some latency, while those random memory accesses consume more time.</p>
<p>It can be seen that the CPU is very slow to read and write data directly to the main memory and spends most of its time waiting for data transfer, so the CPU cache structure has been introduced.</p>
<h2 id="overview">Overview</h2>
<p>Most of today&rsquo;s CPUs have three levels of cache. Take the 8265U I use as an example, its cache structure is as follows.</p>
<ul>
<li>Each CPU core has 64KB of L1 cache, of which 32KB is instruction cache and the other 32KB is data cache. L2 cache and L3 cache do not distinguish between instruction and data.</li>
<li>Each CPU core has its own 256KB L2 cache, while the 6MB L3 cache is shared by all CPU cores.</li>
<li>L1, L2, and L3 are faster and more costly the closer they are to the CPU, and slower the farther they are from the CPU.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/16/4638e3de30a2458eb99d4171b9d25673.png" alt="CPU Cache"></p>
<p>The gradual increase in the number of cache levels also introduces two more important issues: one is the cache access hit problem, and the other is the cache update consistency problem. Before explaining these two issues, it is important to understand how the CPU reads and writes caches.</p>
<p>The CPU Cache and memory exchange data in cache blocks <code>Cache Line</code>, and the size of the Cache Line in today&rsquo;s mainstream CPUs is 64Bytes, which is the smallest unit of data the CPU can get from memory. For example, if L1 has a 32KB data cache, it has 32KB /64B = 512 Cache Lines.</p>
<p>When the CPU sees an instruction to read memory, it passes the memory address to the first-level data cache. The first-level data cache checks to see if it has a cache block corresponding to this memory address. If it does, it is a cache hit, otherwise it loads the entire Cache Line from the second level cache.The CPU assumes that if we currently need data at a certain address, it is likely that we will immediately access its neighboring address, i.e., memory accesses tend to be localized, and once the cache block is loaded into the cache, the read instruction can proceed normally.</p>
<h2 id="cache-access-design">Cache Access Design</h2>
<p>The data placement policy of the Cache determines where blocks of data in memory will be copied to the CPU Cache. Since the size of the Cache is much smaller than the memory, an address association algorithm is needed that can allow data in memory to be mapped to the Cache.</p>
<h3 id="fully-associative">Fully Associative</h3>
<p>Fully Associative means that data from any memory address can be cached in any of the Cache Lines. If a memory address is given, knowing whether it exists in the cache requires <strong>parallel comparison</strong> of the memory addresses in all Cache Lines. Therefore, the hardware design of Fully Associative is complex, requires an address comparator for each Cache Line, and is very expensive, so Fully Associative is not suitable for CPU caching.</p>
<h3 id="direct-mapped">Direct Mapped</h3>
<p>In order to reduce the linear growth of the direct search complexity, Direct Mapped was developed: it means that given a memory address, a unique Cache Line can be determined. since the data storage address under Direct Mapped is fixed and unique, it is prone to collisions, which eventually reduces the hit rate of the Cache and affects the performance.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/16/2357bd34e1bb4e138ec1d3a48c58c405.png" alt="Direct Mapped"></p>
<p>Hash Table is the most common indexing method: the hash of the memory address is used as the Index of the array, and the value of the cached object is used as the Value of the array, and each time it is accessed, the address is hashed once and the corresponding location is found in the cache. Hashing is common in high-level programming languages, but it takes about 10,000 CPU cycles to compute a hash value, and for CPU Cache, the design goal is to get the data in a few dozen CPU cycles. If the access efficiency is tens of thousands of CPU cycles, it is better to fetch the data directly from memory.</p>
<p>To reduce the time required for access, we use a low time complexity algorithm such as <strong>modulo operation</strong>. If our L1 Cache has 512 Cache Lines, then the formula <code>(address mod 512)* 64</code> will directly find the Cache location where it is located. However, this approach requires that the OS allocations and accesses to memory are nearly even in terms of addresses, otherwise the conflict situation would be very serious.</p>
<p>Contrary to our wishes, the operating system tends to use memory sequentially and centrally in order to reduce memory fragmentation and achieve convenience. This results in lower-numbered Cache Lines being allocated and used frequently, while higher-numbered Cache Lines are almost always idle because they are rarely accessed by processes. The waste caused by this situation further strains the already valuable CPU cache.</p>
<p>The flexibility of the die mapping is also not good enough. If you need to copy both block 0 and block 512 of main memory to Cache, even if other Cache Lines are free, they can only be copied to Cache Line number 0, which means they cannot be written to CPU Cache at the same time, and Cache Lines need to be erased and loaded continuously according to CPU execution process, which affects efficiency.</p>
<h3 id="n-way-set-associative">N-Way Set Associative</h3>
<p>Set Associative is a trade-off between the above two options. The principle is that a cache is divided into a Set of N Cache Lines, and the cache is divided into equal groups, with the value of N usually being 4, 8, or 16, etc.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/16/9e1b9f0b3f9445ee905657bd1d2305ae.png" alt="CPU Z"></p>
<p>The above figure is a screenshot of the CPU-Z test I used, which shows that the different levels of cache use different N-Way set associations. To better understand the N-Way Set Associative, here is an example. Most Intel processors have a 32KB level 1 data cache, and a set of 8-Way (8 Cache Lines) association, each Cache Line is 64 Bytes, which means.</p>
<ul>
<li>32KB can be divided into 32KB / 64 = 512 Cache Lines.</li>
<li>Because there are 8-Way, there are 512 / 8 = 64 Sets.</li>
<li>So each set has 8 x 64 = 512 Bytes of cache, and each Way has 4KB of cache.</li>
</ul>
<p>Today&rsquo;s operating systems divide physical memory into 4KB pages to be read, each with exactly 64 Cache Lines. When we read a memory page, these 64 Cache Lines are put into 64 Sets in sequence: the first Cache Line (Byte 0~63) is put into Set0, the second Cache Line (Byte 64~127) is put into Set1, and so on.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/16/15deaacd36ee4552a50f0321d8460577.png" alt="8-Way Set Associative"></p>
<p>To facilitate indexing memory addresses, the Level 1 data cache uses a 36bits binary value to represent the address.</p>
<ul>
<li><strong>Tag</strong>: the first 24 bits of each Cache Line address is a Tag, indicating the physical memory page to which it belongs.</li>
<li><strong>Index</strong>: the next 6bits are the Cache Line indexes in this Way, 2^6 = 64 just to index 64 Cache Lines.</li>
<li><strong>Offset</strong>: the last 6bits are used to indicate the offset in the Cache Line within the segment, 2^6 = 64Bytes.</li>
<li><strong>Valid</strong>: an extra binary bit to mark whether the Cache Line is valid or not.</li>
</ul>
<p>Because each Set has 8 Cache Lines, it can hold multiple memory pages at once, which reduces the probability of cache collisions. The <code>Index</code> in the middle 6bits is used to locate the specific Set, then compare the Tag of the address with the Tag of the 8 Cache Lines in the Set in parallel, and if they are the same, the cache is hit (the Cache Line valid bit should be set to 1), and then get the specific data according to the <code>Offset</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/16/93aa162d6dd74e1aabc0d6b71bf8f345.png" alt="l1 cache address"></p>
<blockquote>
<p>The memory address above is related to the specific addressing design of the CPU and is not the same concept as the virtual memory address of the operating system. The 36bits of memory address in the text can be used to represent 64GB of memory address, which means that the CPU supports up to 64GB of physical memory. The 64GB of physical memory can be divided into exactly 2^24 4KB memory pages, so 24 bits are used to store the Tag, which marks the memory page. In order to save space, the CPU is designed with a Cache that uses the exact number of bits to map RAM, mainly related to how much physical memory it plans to support, not 32bits/64bits as we often say.</p>
</blockquote>
<h3 id="summary">Summary</h3>
<p>In summary, the CPU cache can be represented as a tuple (S, N, B, m), i.e., each memory address has m bits, forming M = 2m addresses, and the Cache is organized as an array of S = 2s Cache Sets, each Cache Set containing N Cache Lines, each Cache Line containing B = 2b bytes of data blocks, Each Cache Line contains B = 2b bytes of data blocks, m-bit addresses, and one valid bit.</p>
<p>There are also many types of CPU Cache elimination policies, such as LRU, LFU and Random, and usually the CPU Cache elimination policy is LRU, which is not discussed in this paper.</p>
<h2 id="cache-coherence">Cache Coherence</h2>
<p>In the previous section, we introduced the CPU cache read process. Nowadays, quad-core CPUs are common, and CPUs also need to ensure consistency between multiple physical core caches, which is somewhat similar to the consensus problem in distributed systems. However, CPU hardware does not need to consider network disconnections and delays, so the key to synchronization between multi-core CPU caches is how to manage the state of the data. Typically write operations are performed in the following two ways.</p>
<ul>
<li><strong>Write Through mode</strong>: the write operation is written to both Cache and memory.</li>
<li><strong>Write Back</strong>: The write operation is written to the Cache and then flushed to memory asynchronously.</li>
</ul>
<p>Because writing directly to memory is too slow, to improve write performance, mainstream CPUs use the Write Back strategy. Write-back mode has an additional advantage: it filters out repeated writes to the same address and ends up synchronizing to main memory only once. Also, if the cache segment works in Write Back mode, the system can erase a large swath of memory at a time instead of writing it in small chunks, which is more efficient.</p>
<h3 id="snoopy-protocol">Snoopy protocol</h3>
<p>If a data <code>x</code> is updated on the cache of CPU core 0, the value of the data <code>x</code> on the cache of the other CPU cores should be updated as well. This problem is usually solved using the Snoopy Cache-Coherence Protocols: Snoopy protocols are more like a bus-type technology for data notification, whereby the CPU cache recognizes the state of data on other caches. If there is data sharing, the status of the shared data can be notified to other CPU Caches through a broadcast mechanism.</p>
<p>This protocol requires each CPU to be able to <strong>snoop</strong> the notification of data events and react accordingly. As shown in the figure below, there is a Snoopy Bus bus connecting the physical memory and the CPU Cache.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/16/a7ae1c47f44d477492ebb218e00126f9.png" alt="Snoopy protocol"></p>
<p>&ldquo;The basic idea behind &lsquo;snooping&rsquo; is that all memory transfers occur on a shared bus that is visible to all processor cores: the caches themselves are independent, but memory is a shared resource, only one cache can read or write memory in the same instruction cycle, and all memory accesses are subject to arbitration. <strong>Caches don&rsquo;t just deal with the bus during memory transfers, but are constantly snooping around the bus to see what data is being exchanged and keep track of what other caches are doing</strong> . So when a cache goes to read or write memory on behalf of the core it belongs to, the other cores are notified as a way to keep their caches in sync. As soon as a processor writes memory, the other processors immediately know that the corresponding Cache Line in their own cache has been invalidated.</p>
<blockquote>
<p>The reader may wonder why the L1 and L2 caches are not shared. This would avoid the cache synchronization problem. This is because the processor&rsquo;s time when sharing the L1 cache is spent waiting in line to use the level 1 cache, at least once for each read and write instruction, which is very inefficient. Using multiple sets of caches and utilizing the cache coherency protocol makes them behave as if there is only one set of caches to meet the CPU&rsquo;s speed requirements.</p>
</blockquote>
<p>In addition to the Snoopy protocol, there is a Directory protocol, typically implemented by designing a centralized controller that contains global state information about the contents of various local caches. When a single CPU Cache makes a read or write request, this centralized controller checks and issues the necessary commands to synchronize and transfer data between the main memory and the CPU Cache or between the CPU Cache itself. Because of the centralized processing of data, this protocol has a higher latency, but it has better scalability in systems with many processors.</p>
<h3 id="mesi-class-protocol">MESI Class Protocol</h3>
<p>The MESI protocol is a write-failure cache coherency protocol and is the most commonly used protocol to support Write Back mode caching. In the MESI protocol, any one Cache Line has four different states.</p>
<ul>
<li><strong>Exclusive</strong>: the Cache Line is only in the current cache and is clean (cached data is the same as the main memory data), when other caches read it, the status changes to Shared, and when the data is modified, it changes to Modified, and only the Cache Line in the Exclusive state can be modified.</li>
<li><strong>Shared</strong>: Cache Line also exists in other caches and is clean and can be discarded at any time.</li>
<li><strong>Modified</strong>: The Cache Line is Dirty and has a different value than the main memory. If other CPU cores want to read this data from the main memory, the Cache Line must be written back to the main memory and the status becomes Shared.</li>
<li><strong>Invalid</strong>: Cache Line is invalid and needs to be synchronized from main memory.</li>
</ul>
<p>In the MESI protocol, only one CPU core is responsible for writing data. In the exclusive state, after this CPU core writes data to the Cache, it will broadcast a failure request to all other CPU cores to mark the corresponding Cache Line as invalid; while in the shared state, the same data exists in multiple CPU Caches, so it is necessary to broadcast a failure request to other cores to mark the Cache in other CPU cores as invalid before updating the data.</p>
<p>The MESI protocol marks other shared CPU cache data as invalid after the data is updated, and when the other CPUs read the data again, a Cache Miss occurs and the data needs to be updated from memory. Updating data from memory means a 20x speed reduction. If we could update directly from the CPU cache next door, this could increase the speed a lot, so there are extended versions of <a href="https://en.wikipedia.org/wiki/MOESI_protocol">MOESI protocol</a> and <a href="https://en.wikipedia.org/wiki/MESIF_protocol">MESIF protocol</a>.</p>
<p>The MOESI protocol, currently used by AMD&rsquo;s CPUs, adds an additional Owner state to mark the source of the update data, and the Owner state is similar to the Exclusive state as a means of ensuring consistency between caches, but it allows the contents of dirty segments to be shared directly without first writing them back to memory.</p>
<p>The Forward state, added by Intel&rsquo;s MESIF protocol, allows a clean Cache Line to be forwarded to another cache without the other cache having to re-read it from memory to get a shared copy. Both protocols make some optimizations to share data between caches to minimize latency.</p>
<h2 id="memory-model">Memory Model</h2>
<p>We have understood the bus model and synchronization protocol of the CPU cache, and it is possible to obtain full sequential coherence if the CPU Cache can ideally satisfy the following conditions.</p>
<ol>
<li>the cache can respond quickly in the current instruction cycle as soon as it receives a bus event.</li>
<li>the processor delivers the memory operation instructions to the cache in the program order and waits until the previous one is executed before sending the next one.</li>
</ol>
<p>In practice, however, modern processors are always unable to meet the above conditions for various reasons.</p>
<ul>
<li><strong>Cache will not respond to bus events in time</strong>: if a message is sent on the bus to invalidate a cache segment, but if the cache is processing something else at the time (such as transferring data with the CPU), the message may not be processed in the current instruction cycle and will enter the so-called &lsquo;Invalidation Queue&rsquo;, where the message waits in the queue until the cache is free for processing.
<strong>Processors generally do not send memory operation instructions to the cache in strict program order</strong>: processors with Out-of-Order execution definitely do, but processors with in-order execution sometimes cannot fully guarantee the order of memory operations, for example, if the desired memory is not in the cache, the CPU does not stop working in order to load the cache, but instead performs instruction reordering.
<strong>The write operation is particularly special because it is divided into a two-stage operation</strong>: before writing we first have to get exclusive access to the cache segment, and if we do not currently have exclusive access, we first have to negotiate with other processors, which also takes some time. By the same token, it is a waste of resources to leave the processor idle and doing nothing in this scenario. In fact, the write operation first initiates a request for exclusivity and then enters the Store Buffer queue, where the write operation waits until the cache is ready to process it.</li>
</ul>
<p>These mean that, by default, read operations are likely to read obsolete data, such as corresponding failure requests that are still outstanding in the failure queue, and write operations are likely to actually complete later than their place in the code, and everything becomes ambiguous once chaotic execution is involved.</p>
<p>CPUs of different architectures provide different memory models, and machines of the ARM architecture have a relatively weak memory model: such CPUs have considerable freedom in reordering read and write instructions, and this reordering has the potential to change the semantics of programs in a multicore environment. This can be limited by Memory Barrier technology programs: <strong>Instruction reordering operations are not allowed to cross set boundaries</strong>. In contrast, x86 has a stronger memory model.</p>
<h3 id="instruction-rearrangement">Instruction Rearrangement</h3>
<p>Each CPU runs a program, and the execution of the program generates memory access operations. In this abstract CPU, memory operations are loosely ordered, and memory access operations are executed in their own convenient order without changing the speculation of the program execution results. For example, suppose there exists the value <code>{ A == 1 ; b == 2}</code> and consider the result of executing the following instruction.</p>
<table>
<thead>
<tr>
<th>CPU 1</th>
<th>CPU 2</th>
</tr>
</thead>
<tbody>
<tr>
<td>A=3;</td>
<td>x=B;</td>
</tr>
<tr>
<td>B=4;</td>
<td>y=A;</td>
</tr>
</tbody>
</table>
<p>The four instructions above will have 24 combinations of memory access operations, each of which may occur and will ultimately produce four execution results.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">    STORE A=3,	STORE B=4,	y=LOAD A-&gt;3,	x=LOAD B-&gt;4
</span></span><span class="line"><span class="cl">    STORE A=3,	STORE B=4,	x=LOAD B-&gt;4,	y=LOAD A-&gt;3
</span></span><span class="line"><span class="cl">    STORE A=3,	y=LOAD A-&gt;3,	STORE B=4,	x=LOAD B-&gt;4
</span></span><span class="line"><span class="cl">    STORE A=3,	y=LOAD A-&gt;3,	x=LOAD B-&gt;2,	STORE B=4
</span></span><span class="line"><span class="cl">    STORE A=3,	x=LOAD B-&gt;2,	STORE B=4,	y=LOAD A-&gt;3
</span></span><span class="line"><span class="cl">    STORE A=3,	x=LOAD B-&gt;2,	y=LOAD A-&gt;3,	STORE B=4
</span></span><span class="line"><span class="cl">    STORE B=4,	STORE A=3,	y=LOAD A-&gt;3,	x=LOAD B-&gt;4
</span></span><span class="line"><span class="cl">    STORE B=4, ...
</span></span><span class="line"><span class="cl">    ...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">result:
</span></span><span class="line"><span class="cl">    x == 2, y == 1
</span></span><span class="line"><span class="cl">    x == 2, y == 3
</span></span><span class="line"><span class="cl">    x == 4, y == 1
</span></span><span class="line"><span class="cl">    x == 4, y == 3
</span></span></code></pre></td></tr></table>
</div>
</div><p>Even more brutally, a write operation that has been committed by one CPU may not be sensed by another CPU and thus fetch the old value. Take for example the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">    CPU 1		CPU 2
</span></span><span class="line"><span class="cl">    ===============	===============
</span></span><span class="line"><span class="cl">    { A == 1, B == 2, C == 3, P == &amp;A, Q == &amp;C }
</span></span><span class="line"><span class="cl">    B = 4;		Q = P;
</span></span><span class="line"><span class="cl">    P = &amp;B;		D = *Q;
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">result:
</span></span><span class="line"><span class="cl">    (Q == &amp;A) and (D == 1)
</span></span><span class="line"><span class="cl">    (Q == &amp;B) and (D == 2)
</span></span><span class="line"><span class="cl">    (Q == &amp;B) and (D == 4)
</span></span></code></pre></td></tr></table>
</div>
</div><p>In addition, the CPU may also merge memory access operations, for example, the two address instructions <code>X = *A; Y = *(A + 4);</code> may be merged into either of the following execution sequences.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">    X = LOAD *A; Y = LOAD *(A + 4);
</span></span><span class="line"><span class="cl">    Y = LOAD *(A + 4); X = LOAD *A;
</span></span><span class="line"><span class="cl">    {X, Y} = LOAD {*A, *(A + 4) };
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="memory-barrier">Memory Barrier</h3>
<p>While the CPU can perform instruction reordering, it provides us with minimal guarantees.</p>
<ol>
<li>that memory access operations with dependencies are sequential.</li>
<li>overriding load-store operations in the same CPU core are sequential.</li>
</ol>
<p>If we want a higher level of instruction execution order that we can control in the program, we need to use memory barriers, and there are generally four common types.</p>
<ul>
<li><strong>write barriers</strong>: write barriers ensure that any STORE operation that appears before a write barrier is executed before any STORE operation that appears after that write barrier, and write barriers are generally used in conjunction with read barriers or data-dependent barriers.</li>
<li><strong>Read Barrier</strong>: A read barrier ensures that any LOAD operation that appears before a read barrier is executed before any LOAD operation that appears after that read barrier; a read barrier is typically used in conjunction with a write barrier.</li>
<li><strong>Data Dependency Barrier</strong>: a data dependency barrier is a weak read barrier that is used between two read operations and where the second read operation depends on the first read operation (for example, where the first read operation obtains the address used by the second read operation), the read barrier is used to ensure that the target of the second read operation has been obtained by the first read operation, and the data dependency barrier can only be used where a data dependency does exist</li>
<li><strong>General Memory Barrier</strong>: the general memory barrier guarantees that all memory accesses that appear before the barrier (LOAD and STORE) are executed before memory accesses that appear after the barrier, like a combination of read and write barriers.</li>
</ul>
<p>For example, in the following example, we use a write barrier and a data-dependent barrier to secure the values of <code>B</code> and <code>Q</code> so that only predictable results occur in the program.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">    CPU 1		      CPU 2
</span></span><span class="line"><span class="cl">    ===============	      ===============
</span></span><span class="line"><span class="cl">    { A == 1, B == 2, C == 3, P == &amp;A, Q == &amp;C }
</span></span><span class="line"><span class="cl">    B = 4;
</span></span><span class="line"><span class="cl">    &lt;write barrier&gt;
</span></span><span class="line"><span class="cl">    WRITE_ONCE(P, &amp;B);
</span></span><span class="line"><span class="cl">			      Q = READ_ONCE(P);
</span></span><span class="line"><span class="cl">			      &lt;data dependency barrier&gt;
</span></span><span class="line"><span class="cl">			      D = *Q;
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are many more scenarios for memory barriers, so it is impossible to describe their usage in detail in this article, but you can read the Linux documentation <em><a href="https://github.com/torvalds/linux/blob/master/Documentation/memory-barriers.txt">LINUX KERNEL MEMORY BARRIERS</a></em>, most of the time we rarely use them directly, but knowing about them can help us understand the design of the program better.</p>
<h2 id="summary-1">Summary</h2>
<p>In general, CPU Cache is transparent to software engineers, and all operations and policies are done inside the CPU. However, knowing and understanding the design idea and working principle of CPU Cache is beneficial for us to make better use of CPU Cache and write more CPU Cache-friendly programs. The author has also thought about some relevant application scenarios.</p>
<ul>
<li>Keeping the granularity of data comparison updates in CAS algorithms within the cache can further improve execution efficiency.</li>
<li>The direct-write/write-back idea of Cache can be carried over to the database-buffer system in business scenarios to help us weigh the execution options.</li>
<li>In suitable scenarios, &rsquo;locking&rsquo; the data at the CPU level reduces the performance loss of this process.</li>
</ul>
<p>The cache coherency protocol in CPU Cache is similar to consensus in a simplified distributed system, and it is also an interesting process to look at this from a microscopic perspective. This also shows that some of the principles in computer science are similar, and although the knowledge is vast, it is important to learn to grasp the key points, and then you will be able to use them all.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://wingsxdu.com/posts/note/cpu-cache-and-memory-barriers/">https://wingsxdu.com/posts/note/cpu-cache-and-memory-barriers/</a></li>
<li><a href="https://fgiesen.wordpress.com/2014/07/07/cache-coherency/">Cache coherency primer</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/Documentation/memory-barriers.txt">LINUX KERNEL MEMORY BARRIERS</a></li>
<li><a href="https://manybutfinite.com/post/intel-cpu-caches/">Cache: a place for concealment and safekeeping</a></li>
<li><a href="https://coolshell.cn/articles/20793.html">CPU cache knowledge relevant to programmers</a></li>
<li><a href="https://book.douban.com/subject/26912767/">In-depth Understanding of Computer Systems, Section 6.4: Cache Memory</a></li>
<li><a href="https://stackoverflow.com/questions/49983405/what-is-the-benefit-of-the-moesi-cache-coherency-protocol-over-mesi">What is the benefit of the MOESI cache coherency protocol over MESI?</a></li>
<li><a href="https://en.wikipedia.org/wiki/MESI_protocol">MESI protocol</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/argo-practice/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">GitOps Tool Argo CD Hands-On Tutorial</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/lsm-tree-leveldb/">
            <span class="next-text nav-default">Principle and Implementation of LSM-Tree and LevelDB </span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
