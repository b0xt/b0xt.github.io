<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>MySQL and InnoDB Storage Engine Summary - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Learn about mysql&#39;s innodb engine, including file storage, indexes, caching, locks, and transactions." /><meta name="keywords" content="mysql, Innodb" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/mysql-innodb/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="MySQL and InnoDB Storage Engine Summary" />
<meta property="og:description" content="Learn about mysql&#39;s innodb engine, including file storage, indexes, caching, locks, and transactions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/mysql-innodb/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-20T10:55:26+08:00" />
<meta property="article:modified_time" content="2022-08-20T10:55:26+08:00" />

<meta itemprop="name" content="MySQL and InnoDB Storage Engine Summary">
<meta itemprop="description" content="Learn about mysql&#39;s innodb engine, including file storage, indexes, caching, locks, and transactions."><meta itemprop="datePublished" content="2022-08-20T10:55:26+08:00" />
<meta itemprop="dateModified" content="2022-08-20T10:55:26+08:00" />
<meta itemprop="wordCount" content="7188">
<meta itemprop="keywords" content="mysql," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MySQL and InnoDB Storage Engine Summary"/>
<meta name="twitter:description" content="Learn about mysql&#39;s innodb engine, including file storage, indexes, caching, locks, and transactions."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">MySQL and InnoDB Storage Engine Summary</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-20 10:55:26 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 7188 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#mysql-architecture">MySQL Architecture</a></li>
        <li><a href="#file-storage">File storage</a>
          <ul>
            <li><a href="#tablespace">Tablespace</a></li>
            <li><a href="#data-page-structure">Data Page Structure</a></li>
            <li><a href="#row-record-format">Row Record Format</a></li>
            <li><a href="#row-overflow">Row Overflow</a></li>
          </ul>
        </li>
        <li><a href="#indexing">Indexing</a>
          <ul>
            <li><a href="#btree-index">B+Tree Index</a></li>
            <li><a href="#full-text-search">Full-text search</a></li>
            <li><a href="#adaptive-hash-indexes">Adaptive Hash Indexes</a></li>
          </ul>
        </li>
        <li><a href="#memory-buffers">Memory Buffers</a>
          <ul>
            <li><a href="#page-cache">Page Cache</a></li>
            <li><a href="#change-buffer">Change Buffer</a></li>
            <li><a href="#double-write-buffer">Double Write Buffer</a></li>
          </ul>
        </li>
        <li><a href="#locks">Locks</a>
          <ul>
            <li><a href="#types-of-locks">Types of Locks</a></li>
            <li><a href="#algorithms-for-row-locks">Algorithms for row locks</a></li>
            <li><a href="#consistent-non-locking-reads">Consistent non-locking reads</a></li>
          </ul>
        </li>
        <li><a href="#transactions">Transactions</a>
          <ul>
            <li><a href="#redo-log-and-persistence">Redo Log and Persistence</a></li>
            <li><a href="#undo-log-and-consistency">Undo Log and Consistency</a></li>
            <li><a href="#locks-and-isolation">Locks and Isolation</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>MySQL is a widely used relational database, and understanding the internal mechanism and architecture of MySQL can help us better solve the problems we encounter in the process of using it. Therefore, I have read some books and materials related to MySQL InnoDB storage engine, and summarize them in this article.</p>
<h2 id="mysql-architecture">MySQL Architecture</h2>
<p>Two terms that are easily confused in the database world are <strong>database</strong> and <strong>instance</strong>. As common database terms, these two terms are defined in the book <em>MySQL Technical Insider: InnoDB Storage Engine</em> as follows.</p>
<ul>
<li><strong>database</strong>: a collection of physical operating system files or other forms of file types; in a MySQL database, database files can be csv, ibd type storage files.</li>
<li><strong>Instance</strong>: MySQL database consists of background threads as well as a shared memory area.</li>
</ul>
<p>Conceptually, a database is a collection of files, a collection of data organized according to some data model and stored in secondary storage; a database instance is a program, a layer of data management software located between the user and the operating system, and the user&rsquo;s data on the database is carried out under the database instance. In MySQL, instances and databases usually correspond to each other, but in a cluster situation, there may be a database that can be used by multiple instances.</p>
<p>MySQL is designed as a single-process, multi-threaded architecture database and relies on the threaded implementations of various operating systems, but MySQL basically ensures consistency in physical architecture across platforms. MySQL&rsquo;s architecture is shown in the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/8c8f2c9858074523a60a3f90e483cf01.png" alt="MySQL&amp;rsquo;s architecture"></p>
<p>The top tier connection pool provides the services required by network clients: connection processing, authentication, security checks, etc. MySQL creates a separate thread for each client connection, and queries belonging to that connection are completed in the specified thread. The second tier contains most of MySQL&rsquo;s core functionality, including parsing, analysis, optimization, caching, and built-in function handling of SQL, in addition to any functionality provided across storage engines, such as stored procedures, triggers, and views.</p>
<p>The third layer is the <strong>Plug-in Storage Engine</strong>, which is the most important part of MySQL. The storage engine is responsible for storing and extracting data from MySQL, and the server communicates with the storage engine through an API and writes data to disk in a format unique to each storage engine. The MySQL storage engine is table-based, and within a database instance, we can choose different storage engines for different tables depending on the characteristics of the specific application.</p>
<p>InnoDB is currently the most general storage engine with a good balance between high reliability and high performance, featuring support for ACID transaction model, foreign key support, row lock design, and since MySQL version 5.5.8, InnoDB has been the default storage engine and is the main target of this article.</p>
<h2 id="file-storage">File storage</h2>
<h3 id="tablespace">Tablespace</h3>
<p>In the InnoDB storage engine, each table has a Primary Key. From the <strong>logical storage structure</strong> of the InnoDB storage engine, all data is logically stored in a space, called Tablespace, according to the primary key order. From the outside, a table is composed of consecutive fixed-size Pages, but in fact, the tablespace file is organized into a more complex logical structure inside, which can be divided into Segment, Extent and Page from top to bottom.</p>
<p>The file logical storage structure of InnoDB storage engine is roughly shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/4872c72b459b43c29c134c72f100eb3f.png" alt="logical storage structure of InnoDB storage engine"></p>
<blockquote>
<p>The above figure is modified from <em><a href="https://read.douban.com/ebook/15233230/">MySQL Technical Insider: InnoDB Storage Engine</a></em> Figure 4-1 InnoDB Logical Storage Structure</p>
</blockquote>
<p>Segment is mapped to an index in the database; within the InnoDB engine, a data segment is a leaf node of the B+ Tree and an index segment is a non-leaf node of the B+ Tree; a critical step in index creation is the assignment of Segment.</p>
<p>The next level of Segment is Extent, which represents a set of consecutive Pages with a default size of 1MB. Extent is used to improve the efficiency of Page allocation and better data continuity, and Segment is also allocated in Extent when it is expanded.</p>
<p>Page (called block in some materials) is the basic unit of tablespace data storage, InnoDB slices the table file by Page, depending on the type, Page content also differs, the most common is the data page storing row records.</p>
<p>By default, the InnoDB storage engine Page size is 16KB, which means there are 64 consecutive Pages in an Extent, and the Page size can be changed by specifying the <code>innodb_page_size</code> option when creating a MySQL instance. Note that the Page size may affect the size of Extent.</p>
<table>
<thead>
<tr>
<th>page size</th>
<th>page nums</th>
<th>extent size</th>
</tr>
</thead>
<tbody>
<tr>
<td>4KB</td>
<td>256</td>
<td>1MB</td>
</tr>
<tr>
<td>8KB</td>
<td>128</td>
<td>1MB</td>
</tr>
<tr>
<td>16KB</td>
<td>64</td>
<td>1MB</td>
</tr>
<tr>
<td>32KB</td>
<td>64</td>
<td>2MB</td>
</tr>
<tr>
<td>64KB</td>
<td>64</td>
<td>4MB</td>
</tr>
</tbody>
</table>
<p>As you can see from the table above, an Extent has a minimum of 1 MB and a minimum of 64 pages.</p>
<h3 id="data-page-structure">Data Page Structure</h3>
<p>Page is the smallest disk unit for InnoDB storage engine to manage data, common page types are: Data (Index) Page, Undo Page, Inode Page, System Page, BloB Page, etc., where Data Page (B+Tree Node) holds the actual data of row records in the table, Data Page includes seven parts, File Header, Page Header, Max Min Record, User Record, Free space, data directory, and the end of the file. In short, the data page is divided into two parts, one part stores the data row records, which are connected by pointers according to the size of the rows, and the other part stores the data page directory, which is used to speed up the search.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/cb2f047790814a41a4db3ec361228f57.png" alt="B-Tree node page"></p>
<p>The file header and tail are mainly used to store tablespace-related information, including page numbers, page types, checksum values, etc. The file header also holds meta information related to the data page. The data directory maintains a sparse directory of the page, storing the on-page offset of a record every 4 to 8 rows. Because of the data page directory, finding and locating is relatively simple, first using a dichotomous lookup to locate the location of the two surrounding rows of data, and then using a linear lookup to locate the final location of the record.</p>
<p>The Infimum/Supremum Record are two dummy row records that are used to delimit the boundaries of the record. The <code>Infimum Record</code> is a value smaller than any primary key value in the page, and the <code>Supremum Record</code> is a value larger than any possible larger value. These two values are created when the page is created and will not be deleted under any circumstances.</p>
<p>The row record is the part of the page that is actually used to store the row record, which is a linked list data structure. To ensure the efficiency of insertion and deletion, <strong>the entire page does not sort all records in primary key order</strong> , and when the user needs to insert a record, he first looks in the space of the deleted record, and if no suitable space is found, it is allocated from <code>Free Space</code>. So row records may not be physically stored in primary key order; the order among them is controlled by the pointer <code>next_record</code> to the next record.</p>
<h3 id="row-record-format">Row Record Format</h3>
<p>The InnoDB storage engine, like most databases, stores records as rows, each 16KB page can hold 2 to 200 row records.InnoDB&rsquo;s early file format is <code>Antelope</code>, two row record formats can be defined, <code>Compact</code> and <code>Redundant</code>, InnoDB 1.0.x version introduced a new file format <code>Barracuda</code>. The <code>Barracuda</code> file format has two new row record formats: <code>Compressed</code> and <code>Dynamic</code>.</p>
<p>The <code>Compact</code> row record format was introduced in MySQL 5.0 and is headed by a non-NULL variable-length column length list and is placed in reverse order with the following lengths.</p>
<ul>
<li>1 byte if the length of the column is less than or equal to 255 bytes.</li>
<li>If the length of the column is greater than 255 bytes, it is represented by 2 bytes.</li>
</ul>
<p>The maximum length of a variable-length field cannot exceed 2 bytes, because the maximum length of VARCHAR type in MySQL database is limited to 65535.</p>
<p>The second part after the variable-length field is the NULL flag bit, which indicates whether a column in the row is a NULL value, or a 1 if it is, and the NULL flag bit is also indefinite in length. Next is the record header information, which is fixed at 5 bytes.</p>
<p><code>Redundant</code> is the row record format of InnoDB before MySQL 5.0. The head of the <code>Redundant</code> row record format is a list of length offsets for each column, which is also stored in reverse order. Overall, the <code>Compact</code> format reduces storage space by about 20%, but at the cost of increased CPU usage for some operations.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/4e84fecf98b14138b1f394c6e447286d.png" alt="Compact and Redundant Row format"></p>
<p><code>Dynamic</code> and <code>Compressed</code> are variants of the <code>Compact</code> row record format. <code>Compressed</code> compresses the row data stored in it with the <code>zlib</code> algorithm, so it can store data of large lengths such as BLOB, TEXT, VARCHAR very efficiently.</p>
<blockquote>
<p>For more details on InnoDB row formats, please refer to the documentation: <em><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html">InnoDB Row Formats</a></em></p>
</blockquote>
<h3 id="row-overflow">Row Overflow</h3>
<p>When InnoDB stores extremely long TEXT or BLOB type of large objects, MySQL does not store everything directly in the data page. Because the InnoDB storage engine uses B+Tree to organize indexes, there should be at least two row records in each page, so if the page can only hold the next row, then the InnoDB storage engine will automatically store the row data in the overflow page.</p>
<p>If we use <code>Compact</code> or <code>Redundant</code> format, then the first 768 bytes of row data will be stored in the data page, and the later data will be pointed to the Uncompressed BLOB Page via a pointer.</p>
<p>But if we use the new row record format <code>Compressed</code> or <code>Dynamic</code> only 20 bytes of pointer will be stored in the row record and the actual data will be stored in the overflow page.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/8e97316e6334493b817f0a97d34ddb57.png" alt="Off Page"></p>
<h2 id="indexing">Indexing</h2>
<p>Indexing is an important aspect of application design and development. If there are too many indexes, the performance of the application may suffer. And too few indexes can have an impact on query performance. Finding the right balance is critical to application performance. the InnoDB storage engine supports the following common indexes.</p>
<ul>
<li><strong>B+Tree indexes</strong></li>
<li><strong>Full-text indexes</strong></li>
<li><strong>Hash indexes</strong></li>
</ul>
<h3 id="btree-index">B+Tree Index</h3>
<p>B+Tree is currently the most common and effective data structure for searching relational database systems. Its construction is similar to that of a binary tree, allowing data to be found quickly based on key-value pairs.</p>
<p>One of the characteristics of B+Tree indexes in databases is high fanout. In databases, the height of B+Tree is usually 2 to 4 levels, which means that only 2 to 4 random IOs are needed at most to find the row records of a key value.</p>
<p>In the InnoDB storage engine, the B+Tree index does not find a specific row for a given key; all the B+Tree index can find is the page where the row is found, and then the database reads the page into memory and then does a lookup in memory to get the data to be found.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/2d1501247fa84627b002b52374298ef6.png" alt="B+Tree in Innodb"></p>
<p>B+Tree indexes in databases can be divided into aggregated and auxiliary indexes, but whether they are aggregated or auxiliary, they are all internally B+Tree, i.e., highly balanced, with the leaf nodes holding all the data. The difference between an aggregated index and an auxiliary index is whether the leaf nodes store complete information about the rows.</p>
<h4 id="aggregate-indexes">Aggregate Indexes</h4>
<p>An aggregated index is a B+Tree constructed according to the primary key of each table, while the leaf nodes store the row record data of the entire table. This feature of the aggregated index determines that the data in the index organization table is also part of the index, and like the B+Tree data structure, each data page is linked by a Doubly linked list. We can use the following SQL statement to create a test table, specify the <code>id</code> field as the primary key, and create an aggregated index.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">KEY</span><span class="w"> </span><span class="n">idx_name</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">KEY</span><span class="w"> </span><span class="n">idx_a_b</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Since the actual data pages can only be sorted by one B+Tree, each table can only have one aggregated index, and <strong>all row record data in the table is stored in the order of the aggregated index</strong> . In most cases, query optimizers tend to use aggregated indexes to quickly discover that a range of data pages need to be scanned because aggregated indexes can find data directly on the leaf nodes of a B+Tree index. In addition, aggregated indexes enable particularly fast access to queries against range values because of the logical order in which the data is defined.</p>
<h4 id="auxiliary-indexes">Auxiliary indexes</h4>
<p>The leaf node in the auxiliary index does not contain the data of the row record, but records the aggregated index (i.e. primary key) corresponding to the row data. When finding data by auxiliary index, InnoDB storage engine will traverse the auxiliary index to get the primary key of the row data, and finally use the primary key to get the corresponding row record in the aggregated index.</p>
<p>The existence of secondary index does not affect the organization of data in the aggregated index, so there can be more than one secondary index on each table. In the test table above, index <code>idx_name</code> and <code>idx_a_b</code> are both secondary indexes.</p>
<h4 id="federated-indexes">Federated Indexes</h4>
<p>A  federated Index is a special kind of auxiliary index. The cases discussed earlier all index only one column on a table. In the above test table, index <code>idx_a_b</code> is a joint index, which is also a B+ Tree in nature, but the difference is that the number of keys in the joint index is greater than or equal to 2.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/33e9540e778e425ba334a743f7ab60c0.png" alt="Federated Indexes"></p>
<p>As shown above, the keys of the federated indexes are stored in sorted order, and all data can be read out in logical order through the leaf nodes. Using additional columns in the index, you can narrow down the search, so the order of the columns should be carefully considered when creating a composite index.</p>
<p>A federated index follows the leftmost match principle, which means that the fields in the index are used from left to right. A query can use only a part of the index, but only the leftmost part. For example, if the index is key abc_index (a,b,c), then the index <code>abc_index</code> can be used by executing the following SQL statements.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">c</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>In the third statement, although the order of a and b is reversed, the query optimizer will determine in what order this SQL statement is most efficient, so the query ends up in the same way as the second statement.</p>
<h3 id="full-text-search">Full-text search</h3>
<p>Full-text search is a technique to find out information about any content in an entire book or article stored in a database. It can obtain information about chapters, sections, paragraphs, sentences, words, etc. in the full text as needed, and can also perform various statistics and analysis. For example, in the following SQL statement, we can look up the articles whose blog content contains the word <code>MySQL</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">blog</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">content</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%MySQL%&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>According to the characteristics of B+Tree index, even if the above SQL statement adds a B+Tree index to the <code>content</code> field, it still needs to scan the index to get the result, and it wastes a lot of space to create the index, and in general B+Tree index is not good for this kind of work.</p>
<p>Full-text search is usually implemented using inverted indexes. A backward index stores a mapping between a word and its own location in one or more documents in an auxiliary table; in layman&rsquo;s terms, a <strong>backward index is used to record which documents contain a word</strong>. This is usually achieved using associative arrays, which have two representations.</p>
<ul>
<li><strong>Inverted File Index</strong>: this takes the form {word, ID of the document where the word is located}.</li>
<li><strong>Full Inverted Index</strong>: this takes the form {word, (the ID of the document in which the word is located, and its location in the specific document)}.</li>
</ul>
<p>For example, there is a table like the following.</p>
<table>
<thead>
<tr>
<th>DocumentId</th>
<th>Text</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Hello, I am a college student</td>
</tr>
<tr>
<td>2</td>
<td>I am 21 years old</td>
</tr>
<tr>
<td>3</td>
<td>Three years ago I came to the college</td>
</tr>
</tbody>
</table>
<p>An example of the corresponding inverted index for this table is as follows.</p>
<table>
<thead>
<tr>
<th>Number</th>
<th>Text</th>
<th>inverted file index</th>
<th>full inverted index</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>college</td>
<td>1,3</td>
<td>(1:6),(3:8)</td>
</tr>
<tr>
<td>2</td>
<td>student</td>
<td>1</td>
<td>(1:7)</td>
</tr>
<tr>
<td>3</td>
<td>years</td>
<td>2,3</td>
<td>(2:4),(3:2)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
<p>As you can see from the table above, the full inverted index also stores information about the location of the word, e.g., the word <code>student</code> is indexed as (1:7), i.e., the 7th word in document 1 is student. full inverted index takes up more space than full inverted index, but it can better locate the data and expand some of the In contrast, full inverted index takes up more space, but locates data better and expands some other search features.</p>
<p>InnoDB has supported full-text search since version 1.2.x, and uses the full inverted index format. In the InnoDB storage engine, the (DocumentId, Position) is treated as an <em>ilist</em>. Since InnoDB storage engine stores Position information in the <em>ilist</em> field, proximity search is possible.</p>
<p>In order to improve the parallel performance of full-text search, InnoDB storage engine stores the word of the inverted index into 6 auxiliary tables, each table is partitioned according to the Latin encoding of the word and stored on disk. In addition to this, a full-text search index cache (FTS Index Cache) is introduced. FTS Index Cache is a red-black tree structure, which is sorted according to (word, ilist) to speed up query operations.</p>
<h3 id="adaptive-hash-indexes">Adaptive Hash Indexes</h3>
<p>Adaptive hash indexes are part of the InnoDB buffer pool, where the InnoDB storage engine monitors the lookups of secondary indexes on a table, and if a secondary index is found to be frequently accessed, a speedup can be achieved by creating a hash index. Adaptive hash indexes are mapped to a hash table by hash functions, so they are very fast for dictionary type lookups, while for other lookup types, such as range lookups, you cannot use hash indexes.</p>
<p>InnoDB storage engine uses hash algorithm to lookup dictionaries, its conflict mechanism uses linked list to solve, and the hash function uses the remainder method. Since the adaptive hash index is controlled by the InnoDB storage engine itself, the DBA itself cannot interfere with it, but you can disable or enable this feature by using the parameter <code>innodb_adaptive_hash_index</code>, which is enabled by default.</p>
<p><em>Index design is a very complex part of the database, and this section only gives a brief overview of the internal mechanism of InnoDB indexes.</em></p>
<h2 id="memory-buffers">Memory Buffers</h2>
<p>The InnoDB storage engine is based on disk storage and manages the records in it on a page-by-page basis. Due to the divide between CPU speed and disk speed, disk-based database systems often use in-memory buffering techniques to improve overall database performance.</p>
<h3 id="page-cache">Page Cache</h3>
<p>InnoDB will cache the read pages in memory and take the Least Recently Used (LRU) algorithm to manage the buffer pool as a list to increase the cache hit rate.</p>
<p>InnoDB makes some improvements to the LRU algorithm by implementing a <strong>Midpoint Insertion Policy</strong> that defaults the first 5/8 to <code>New Sublist</code>, which stores frequently used hot pages, and the next 3/8 to <code>Old Sublist</code>. The newly read page is added to the head of <code>old Sublist</code> by default, and if the data of <code>old Sublist</code> is accessed during the run, the page is moved to the head of <code>New Sublist</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/289eb946cfe24778b484c2f3dbfdda18.png" alt="LRU Buffer pool"></p>
<p>Whenever InnoDB caches a new data page, it will look for a free cache area from the <code>Free List</code> first, and if it doesn&rsquo;t exist, then it needs to eliminate certain tail nodes from the <code>LRU List</code>. Whether the data page is in <code>New Sublist</code> or <code>Old Sublist</code>, if it is not accessed, then it will eventually be moved to the tail of the <code>LRU List</code> as a casualty.</p>
<h3 id="change-buffer">Change Buffer</h3>
<p>Change Buffer is used to record the modification of data, because InnoDB&rsquo;s secondary indexes are different from the sequential insertion of aggregated indexes, if every modification of secondary indexes is written directly to disk, there will be a lot of frequent random IO.</p>
<p>InnoDB introduced Change Buffer from version 1.0.x. The main purpose is to cache the operations on <strong>non-unique secondary index</strong> pages, if the secondary index page is already in the buffer, then modify it directly; if not, then save the modification to Change Buffer first. when the corresponding secondary index page is read into the buffer, then merge the data from Change Buffer into the real one. When the corresponding auxiliary index page is read into the buffer, the data in the Change Buffer is merged into the real auxiliary index page to reduce the random IO of the auxiliary index and achieve the effect of operation merging.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/9e594b9bb2c0421bbaf0247c1969486e.png" alt="Change Buffer"></p>
<p>Before MySQL 5.5 Change Buffer was actually called Insert Buffer, which initially only supported caching for INSERT operations, and was renamed Change Buffer as the supported operation types increased, and now the InnoDB storage engine can cache INSERT, DELETE, and UPDATE, corresponding to. Insert Buffer, Delete Buffer, Purge buffer.</p>
<h3 id="double-write-buffer">Double Write Buffer</h3>
<p>When a database goes down, it is possible that the storage engine is writing a page to a table that is only partially written, such as a 16KB page, and only the first 4KB is written before it goes down. Although data recovery can be done through logs, it is pointless to re-write the page if it is already corrupted. Therefore, InnoDB introduces Double Write Buffer to solve the half-write problem of data pages.</p>
<p>The default size of Double Write Buffer is 2M, which is 128 data pages. It is divided into two parts, one is reserved for <code>batch write</code>, which provides bulk flush of dirty pages, and the other is <code>single page write</code>, which is reserved for single page flush operations initiated by user threads.</p>
<p>When refreshing the dirty pages of the buffer pool, the dirty pages are not written directly to disk, but will be copied to the Double Write Buffer in memory first by the <code>memcpy()</code> function, and if the Double Write Buffer is full, then the <code>fsync()</code> system call will be called to write all the data of the Double Write Buffer to disk at once, as this process is sequential and the overhead is almost negligible. After ensuring that the writes are successful, the individual data pages are then written back to their own tablespace using asynchronous IO.</p>
<h2 id="locks">Locks</h2>
<p>Locks are a key feature that distinguishes database systems from file systems, and the locking mechanism is used to manage concurrent access to shared resources. the InnoDB storage engine uses locks not only at the row level on table data, but also in multiple other places within the database, allowing concurrent access to many different resources. The implementation of locks can vary from database vendor to database vendor, and this section focuses on locks for the InnoDB engine in MySQL.</p>
<h3 id="types-of-locks">Types of Locks</h3>
<p>InnoDB implements two types of row-level locks.</p>
<ul>
<li><strong>shared locks (also called S locks)</strong>: allow transactions to read a row of data. S locks can be added manually using the SQL statement <code>select * from tableName where ... lock in share mode;</code>.</li>
<li><strong>Exclusive lock (also known as X lock)</strong>: allows a transaction to delete or update a row of data. You can use the SQL statement <code>select * from tableName where ... for update;</code> to manually add an X lock.</li>
</ul>
<p>S lock and S lock are compatible, X lock and other locks are not compatible, for example, transaction T1 obtained a row r1 S lock, transaction T2 can immediately obtain row r1 S lock, at this time T1 and T2 jointly obtain row r1 S lock, this situation is called lock compatibility, but another transaction T3 at this time, if you want to obtain row r1 X lock, you must wait for T1 to release the lock held by row r, this situation is called lock compatibility. This situation is called a lock conflict.</p>
<p>We can use the concept of read/write locks to understand InnoDB&rsquo;s row-level locks, where shared locks represent read operations and exclusive locks represent write operations, so we can do <strong>parallel reads</strong> of row data, but only <strong>serial writes</strong> to ensure that resource competition does not occur within MySQL.</p>
<p>Both shared locks and exclusive locks can only lock on a certain data row. To support locking operations at different granularity, InnoDB storage engine supports an additional locking method called intent locks, which are automatically added by InnoDB and are both table-level locks.</p>
<ul>
<li><strong>Intentional Shared Locks (IS)</strong>: a transaction that wants to obtain a shared lock on certain rows of a table must obtain an IS lock on that table.</li>
<li><strong>Intentional Exclusive Lock (IX)</strong>: a transaction that wants to obtain an exclusive lock on a table for a few rows must obtain an IX lock on that table.</li>
</ul>
<p>Since the InnoDB storage engine supports row-level locks, intent locks do not actually block any requests other than a full table sweep; their primary purpose is to indicate <strong>whether a transaction is locking a row of data in a table</strong>. The table-level intent locks are compatible with row-level locks in the following table.</p>
<table>
<thead>
<tr>
<th>Lock Type</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Conflict</td>
</tr>
<tr>
<td>IX</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Conflict</td>
<td>Compatible</td>
</tr>
<tr>
<td>S</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Compatible</td>
</tr>
<tr>
<td>IS</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Compatible</td>
<td>Compatible</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Without intent locks, when there is already a transaction using row locks to modify a row in the table, if another transaction wants to modify the whole table, it needs to scan all the rows to see if they are locked, which is very inefficient in this case; however, after the introduction of intent locks, when there is a transaction using row locks to modify a row in the table, it will first add an intent exclusion lock to the table ( IX) and then add an exclusive lock (X) to the row record. At this point, if a transaction tries to modify the whole table, it does not need to determine whether each row of data in the table is locked or not, but only needs to wait for the intentional mutex lock to be released.</p>
<p>&ndash; The above is from <em><a href="https://draveness.me/mysql-innodb/">&lsquo;A Brief Introduction&rsquo; to MySQL and InnoDB</a></em></p>
</blockquote>
<h3 id="algorithms-for-row-locks">Algorithms for row locks</h3>
<p>Because the InnoDB storage engine supports row-level locks, this subsection looks at the algorithms for implementing row locks. The InnoDB storage engine uses three algorithms for row locks to meet the requirements of the relevant transaction isolation level.</p>
<ul>
<li>
<p><strong>Record Lock</strong>: this lock is a lock on <strong>indexed records</strong>, if no index is defined in the table, InnoDB will create a hidden aggregated index for the table by default and use the index to lock the records; if we use an aggregated index or auxiliary index field as a filter condition in the <code>WHERE</code> statement in SQL, then InnoDB will If we use an aggregated index or a secondary index field as a filter condition in the <code>WHERE</code> statement in SQL, then InnoDB can find the row through the B+ Tree created by the index and add a lock, but if we use an unindexed field as a filter condition, InnoDB will lock the whole table because it doesn&rsquo;t know where the row to be modified is stored, and it can&rsquo;t tell which row will be modified in advance.</p>
</li>
<li>
<p><strong>Gap Lock</strong>: This lock locks a range, but not the record itself; when a range query SQL statement like <code>SELECT * FROM table WHERE age BETWEEN 20 AND 30 FOR UPDATE;</code> is used, it prevents other transactions from inserting a record with <code>age = 15</code> into the table. Because the entire range is locked by the gap lock. Although there are shared locks and exclusive locks in gap locks, they do not conflict with each other, that is, different transactions can hold both shared locks and exclusive locks for the same range, which are used to <strong>multiple transactions adding new rows to the same range</strong> to avoid phantom read problems.</p>
</li>
<li>
<p><strong>Next-key Lock</strong> : This lock is a combination of Record Locks and Gap Locks, which locks a range and locks the record itself. For example, if an index has three values 1, 3, 5, then the index locks the range <code>(-∞,1], (1,3], (3,5], (5,+ ∞)</code>.</p>
<blockquote>
<p>Although it is called Next-Key Lock, what it locks is not the current value and the range after it, but actually the current value and the range before it.</p>
</blockquote>
<p>When we update a row, such as <code>SELECT * FROM table WHERE index = 3 FOR UPDATE;</code> , InnoDB not only adds Next-Key Lock to the range <code>(1, 3]</code>, but also adds Gap Lock to the range <code>(3, 5]</code> after this row, so the rows in the range <code>(1, 5]</code> will be locked. InnoDB uses Next-key Lock and Gap Lock to solve the phantom read problem. Note that InnnoDB automatically degrades Next-key Lock to Record Lock if the index has a unique attribute.</p>
</li>
</ul>
<h3 id="consistent-non-locking-reads">Consistent non-locking reads</h3>
<p>Consistent reads in <strong>InnoDB</strong> refer to querying a snapshot of the database at a point in time using MVCC (Multiple Version Concurrency Control) technology. This query can see changes made by transactions committed before that point in time and will not be affected by subsequent changes or uncommitted transactions. For example, if the row being read is performing a DELETE or UPDATE operation, the read operation will not wait for the row lock to be released; instead, the InnoDB storage engine will read a snapshot of the row&rsquo;s data.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/f2ae3d1159e44f95b2663dcf30112266.png" alt="Consistent non-locking reads"></p>
<p>Because there is no need to wait for X locks to be released on the rows accessed, <strong>consistent non-locking reads greatly improve concurrent read performance of the database</strong>. As you can see from the above diagram, snapshot data is actually the previous historical version of the current row data, and there may be multiple versions of each row record, which is implemented by <code>Undo Log Segments</code>. The way of reading will be different under different transaction isolation levels.</p>
<ul>
<li>When the transaction isolation level is <strong>REPEATABLE READ</strong>, consistent reads in the same transaction are read from the snapshot created by the first query under that transaction.</li>
<li>When the transaction isolation level is <strong>READ COMMITTED</strong>, the consistency reads under the same transaction all create and read the latest snapshot of this query itself.</li>
</ul>
<h4 id="deadlock">Deadlock</h4>
<p>Deadlock is a phenomenon caused by two or more transactions competing for lock resources during execution and waiting for each other, without external force, they will not be able to continue execution.InnoDB engine adopts the Wait-For-Graph method to automatically detect deadlock, and will automatically roll back a transaction if deadlock is found.</p>
<p>The Wait-For-Graph keeps <em>lock information chain</em> and <em>transaction wait chain</em> in the database, and the above chain can construct a graph, if there is a loop in this graph, it means there is a deadlock and transactions are waiting for each other to release resources.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/20/a94a0bf2ad6843dc96874f3ee0e5856d.png" alt="wait for graph"></p>
<p>The wait graph is a more proactive deadlock detection mechanism that determines whether a loop exists when each transaction requests a lock and a wait occurs. In the above figure, transaction 1 needs transaction 2 to release resources to continue execution, while transaction 2 needs transaction 3 to release resources&hellip; eventually forming a deadlock loop, which will automatically roll back a transaction to unlock the deadlock competition, usually the InnoDB storage engine chooses to roll back the transaction with the least amount of Undo.</p>
<h2 id="transactions">Transactions</h2>
<p>A database transaction is a logical unit in the execution of a database management system, consisting of a finite sequence of database operations. Transactions have four important characteristics: Atomicity (Atomicity), Consistency (Consistency), Isolation (Isolation), Durability (Durability), people used to call ACID characteristics.</p>
<p>Transaction isolation is achieved by the locking mechanism described above, Redo Log is used to ensure that transactions are atomic and persistent, and Undo Log is used to ensure that transactions are consistent.</p>
<p>Both Redo and Undo can be thought of as recovery operations, with Redo recovering the page operations modified by the commit transaction and Undo rolling back the row log to a specific version, so there are some differences in what is logged between the two.</p>
<h3 id="redo-log-and-persistence">Redo Log and Persistence</h3>
<p>Persistence means that once a transaction is committed, the result is permanent. Even in the event of a downtime failure, the database can recover the data, which means that after the transaction completes, all updates to the database from the transaction will be saved to the database and cannot be rolled back.</p>
<p>The InnoDB storage engine uses a redo log to achieve transaction persistence, which consists of two parts: a redo log buffer in memory; and a redo log file persistent on disk. The Redo Log File <strong>records the physical changes to the data pages</strong>, for example, if a transaction with transaction number T1 modifies data X, and the original value of X is 5 and the modified value is 15, then the Redo Log record is <code>&lt;T1,X,15&gt;</code> and the Undo Log record is <code>&lt;T1,X,5&gt;</code>.</p>
<p>InnoDB achieves transaction persistence through <em>Force Log at Commit</em> mechanism, that is, when the transaction COMMIT, all Redo Log and Undo Log of the transaction must be written to the redo log file for persistence first, and the transaction COMMIT operation is completed before it is considered successful. The Redo Log is essentially sequential, so there is no need to read the Redo Log file while the database is running, but in the event of server downtime, MySQL uses the Redo Log to recover the unsynchronized content. To ensure that every log is written to the redo log file, the InnoDB storage engine needs to call the <code>fsync()</code> system call once after each redo log cache is written to the redo log file to write the data to disk immediately.</p>
<p>To better understand the relationship between redo logging and data buffering, we can describe the process with the following example.</p>
<ol>
<li>the client opens a new data modification transaction T1, which reads data X from the disk into the memory buffer.</li>
<li>modifying the data X from the original value of 5 to 15, while the data is still in the memory buffer, waiting to be flushed to disk.</li>
<li>record the data modification record <code>&lt;T1,X,15&gt;</code> in the Redo Log and immediately call <code>fsync()</code> to write the data to disk.</li>
<li>The transaction can be committed successfully only after the third step is completed, and the data in the memory buffer is flushed to disk.</li>
</ol>
<p>Note that the Redo Log is generated right after the transaction starts, and the Redo Log disk drop is not written as the transaction is committed, but starts to be written to the Redo Log file during the execution of the transaction. Once the dirty pages of the corresponding transaction are written to disk, the Redo Log&rsquo;s mission is complete and the space it occupies can be reused.</p>
<p>In the InnoDB storage engine, the redo log cache and redo log files are stored in blocks of 512 bytes each. If the number of redo logs generated in a page is larger than 512 bytes, then it needs to be split into multiple redo log blocks for storage. In addition, since the size of the redo log block is the same as the disk sector size, which is 512 bytes, the atomicity of the redo log writes can be guaranteed.</p>
<h3 id="undo-log-and-consistency">Undo Log and Consistency</h3>
<p>Consistency means that a transaction changes the database from one state to another consistent state. The integrity constraints of the database are not broken before the transaction starts and after it ends. A transaction is a unit of consistency, and if an action in a transaction fails, the system can automatically undo the transaction - returning to the initialized state.</p>
<p>Undo is stored in a special segment Undo Segment inside the database, located in the shared tablespace. undo is logical logging and does not physically restore the database to the way it was before the statement or transaction was executed, but only logically restores the database to its original state. All changes are logically undone, but the data structures and pages themselves may be very different after the rollback. This is because in a multi-user concurrent system, there may be tens, hundreds, or even thousands of concurrent transactions, with one transaction modifying a few rows on the current page while other transactions are modifying several other rows on the same page. Therefore, it is not possible to roll back a page to the way it was at the beginning of the transaction, because this would affect the work being done by other transactions.</p>
<p>In addition to the rollback operation, the implementation of MVCC mentioned in the Consistent Non-Locking Reads subsection is also accomplished through Undo. When a user reads a row that is already occupied by another transaction, the current transaction can read the previous row version information through the Undo log, thus achieving a non-locking read.</p>
<blockquote>
<p>Undo Log also generates Redo Log at runtime, because Undo Log also needs persistence protection.</p>
</blockquote>
<h3 id="locks-and-isolation">Locks and Isolation</h3>
<p>Isolation requires that the objects of each read and write transaction be separated from the objects of other transactions, i.e., the transaction is not visible to other transactions until it commits. It can also be understood that when multiple transactions are accessed concurrently, the transactions are isolated from each other and one transaction should not affect the operation of other transactions.</p>
<p>MySQL guarantees the isolation of transactions through the locking mechanism.</p>
<p>The four isolation levels defined by SQL standard are adopted by ANSI (American National Standards Institute) and ISO/IEC (International Standard), and each level will have different degrees of impact on the processing ability of transactions. Before we describe each of the four isolation levels from highest to lowest level of concurrency and demonstrate them in code, we create a demo table test and prepare two clients client1 and client2.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">create</span><span class="w"> </span><span class="k">database</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">use</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="read-uncommitted---dirty-reads">READ UNCOMMITTED - Dirty Reads</h4>
<p>A transaction at this isolation level reads data from other uncommitted transactions, also known as <strong>dirty reads</strong>, as shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Execute in client1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SET</span><span class="w"> </span><span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">transaction_isolation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;READ-UNCOMMITTED&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">use</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">begin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">update</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- At this point you see a record with ID 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Execute in client2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">use</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">begin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- At this point you see a record with ID 2
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The last step of client2 reads the uncommitted transaction in client1 (no commit action), i.e., a <strong>dirty read</strong>, which is the best concurrency for the database at this isolation level.</p>
<h4 id="read-committed---non-repeatable-reads">READ COMMITTED - non-repeatable reads</h4>
<p>If a transaction can read another committed transaction, multiple reads will result in different results, a phenomenon called <strong>Non-repeatable reads</strong>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Execute in client1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SET</span><span class="w"> </span><span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">transaction_isolation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;READ-COMMITTED&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">begin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">update</span><span class="w"> </span><span class="n">test</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- At this point you see a record with ID 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Execute in client2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">begin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- At this point you see a record with ID 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Execute in client1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">commit</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Execute in client2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- At this point you see a record with ID 2
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>After client2 opens a transaction, the first time it reads the test table (when client1&rsquo;s transaction has not yet committed) the id is <code>1</code>, and the second time it reads the test table (when client1&rsquo;s transaction has already committed) the id has changed to <code>2</code>, indicating that the committed transaction has already been read at this isolation level.</p>
<h4 id="repeatable-read---phantom-read">REPEATABLE READ - phantom read</h4>
<p>In the same transaction, the result of SELECT is the state at the point in time when the transaction started, so the same SELECT operation will read the same result, but there will be <strong>phantom read</strong> phenomenon.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Execute in client1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SET</span><span class="w"> </span><span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">transaction_isolation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;REPEATABLE-READ&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">begin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- 无记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Execute in client2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">begin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- 无记录
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Commit the transaction in client1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">commit</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Execute the query in client2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- At this point the query is still no record
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">-- In this case, a primary key conflict error is reported
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The above code proves that no other transaction has been read under this isolation level, but if you then insert a data in client2, a primary key conflict error will occur, as if the previous query was an illusion.</p>
<p><code>REPEATABLE-READ</code> is the default isolation level supported by the InnoDB storage engine. From the above description, we can see that <code>REPEATABLE READ</code> and <code>READ UNCOMMITED</code> are actually contradictory, if the former is guaranteed, you can&rsquo;t see the committed transaction, if the latter is guaranteed, it will lead to different results for the two queries. InnoDB chooses to use the <code>next-key lock</code> mechanism mentioned above in the <code>REPEATABLE READ</code> isolation level to avoid the problem of phantom reads.</p>
<h4 id="serializable---serialization">SERIALIZABLE - Serialization</h4>
<p>At this isolation level transactions are executed serially and sequentially, thus avoiding the dirty read, non-repeatable repeat and phantom read problems described above.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- Execute in client1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SET</span><span class="w"> </span><span class="o">@@</span><span class="k">session</span><span class="p">.</span><span class="n">transaction_isolation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;SERIALIZABLE&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">begin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Execute in client2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">begin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">test</span><span class="p">;</span><span class="w"> </span><span class="c1">-- It will block at this point.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- Commit the transaction in client1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">commit</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Once the transaction commits, client2 will immediately return the record with id 1, otherwise it will keep blocking until the request times out. the InnoDB engine of MySQL database will implicitly add a read shared lock to the read operation to achieve serialization level transaction isolation, but since every SELECT statement will be locked, the database concurrency of this isolation level is also the weakest.</p>
<p>The above four isolation levels are getting more and more isolated, but the corresponding concurrency performance is getting lower and lower. MySQL chooses the <code>REPEATABLE READ</code> isolation level and uses the <code>next-key lock</code> mechanism to avoid the phantom read problem, which is also a compromise solution.</p>
<h2 id="summary">Summary</h2>
<p>The main features of MySQL are summarized in this article, but the knowledge about MySQL is very complicated, so readers who want to understand the specific details of the implementation can read the relevant books or official documentation.</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://wingsxdu.com/posts/database/mysql/innodb/">https://wingsxdu.com/posts/database/mysql/innodb/</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-file-space.html">File Space Management</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html">InnoDB Row Formats</a></li>
<li><a href="http://mysql.taobao.org/monthly/2018/04/03/">MySQL - Engine Features - InnoDB Data Pages Explained</a></li>
<li><a href="http://mysql.taobao.org/monthly/2017/05/01/">MySQL - Engine Features - InnoDB Buffer Pool</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">Buffer Pool</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">InnoDB Locking</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html">Locks in MySQL</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html">MySQL Transaction Isolation Levels and Locks</a></li>
<li><a href="https://draveness.me/mysql-innodb/">MySQL and InnoDB: A Brief Introduction</a></li>
<li><a href="https://read.douban.com/ebook/15233230/">Inside MySQL Technology: InnoDB Storage Engine</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/mysql/">mysql</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/react-use-effect/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Why shouldn&#39;t you use useEffect in React to get data from the API directly?</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/mysql-index/">
            <span class="next-text nav-default">Index design principles for relational databases</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
