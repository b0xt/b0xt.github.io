<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Principles of Raft, a distributed consistency protocol - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In this paper, we introduce the mechanism of Raft algorithm from four aspects: Leader Election, Log Replication, Safety, and Membership Changes." /><meta name="keywords" content="Raft" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/raft/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Principles of Raft, a distributed consistency protocol" />
<meta property="og:description" content="In this paper, we introduce the mechanism of Raft algorithm from four aspects: Leader Election, Log Replication, Safety, and Membership Changes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/raft/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-22T13:38:15+08:00" />
<meta property="article:modified_time" content="2022-08-22T13:38:15+08:00" />

<meta itemprop="name" content="Principles of Raft, a distributed consistency protocol">
<meta itemprop="description" content="In this paper, we introduce the mechanism of Raft algorithm from four aspects: Leader Election, Log Replication, Safety, and Membership Changes."><meta itemprop="datePublished" content="2022-08-22T13:38:15+08:00" />
<meta itemprop="dateModified" content="2022-08-22T13:38:15+08:00" />
<meta itemprop="wordCount" content="4896">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Principles of Raft, a distributed consistency protocol"/>
<meta name="twitter:description" content="In this paper, we introduce the mechanism of Raft algorithm from four aspects: Leader Election, Log Replication, Safety, and Membership Changes."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Principles of Raft, a distributed consistency protocol</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-22 13:38:15 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4896 words </span>
          <span class="more-meta"> 23 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#overview">Overview</a>
          <ul>
            <li><a href="#data-consistency">Data consistency</a></li>
            <li><a href="#state-machine-replication">State Machine Replication</a></li>
          </ul>
        </li>
        <li><a href="#leader-election">Leader Election</a>
          <ul>
            <li><a href="#node-communication">Node communication</a></li>
            <li><a href="#election-process">Election process</a></li>
            <li><a href="#random-election-timeout">Random election timeout</a></li>
          </ul>
        </li>
        <li><a href="#log-replication">Log Replication</a>
          <ul>
            <li><a href="#log-matching">Log Matching</a></li>
            <li><a href="#log-consistency-checking">Log consistency checking</a></li>
          </ul>
        </li>
        <li><a href="#safety">Safety</a>
          <ul>
            <li><a href="#election-restrictions">Election restrictions</a></li>
          </ul>
        </li>
        <li><a href="#membership-changes">Membership Changes</a>
          <ul>
            <li><a href="#common-consistency">Common Consistency</a></li>
            <li><a href="#boundary-issues">Boundary issues</a></li>
          </ul>
        </li>
        <li><a href="#network-partitioning">Network Partitioning</a>
          <ul>
            <li><a href="#leader-in-a-few-node-partition">Leader in a few-node partition</a></li>
            <li><a href="#leader-in-a-majority-node-partition">Leader in a majority-node partition</a></li>
          </ul>
        </li>
        <li><a href="#log-compression">Log Compression</a></li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Raft is a consistency protocol based on a message-passing communication model for managing log replication, which allows a group of machines to work as a whole and provide services even if some of them have errors. The Paxos protocol was the first proven consistency algorithm before Raft was proposed, but the principles of Paxos were difficult to understand and engineer. Raft is an implementation of Paxos that aims to provide a better understood algorithm and has been shown to provide the same fault tolerance and performance as Paxos.</p>
<h2 id="overview">Overview</h2>
<p>Raft is a distributed consensus algorithm that can be used as an alternative to Paxos, and it is easier to understand and implement than Paxos. In order to achieve the goal of easy understanding, Raft uses problem decomposition to divide the complex problem of &lsquo;replicated cluster node consistency&rsquo; into four sub-problems that can be independently explained and handled: Leader Election, Log Replication, Safety, and Membership Changes.</p>
<p>In this paper, we introduce the mechanism of Raft&rsquo;s algorithm from these four aspects.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/584bd80879b7413281c2a2452e3ff05d.png" alt="Raft"></p>
<h3 id="data-consistency">Data consistency</h3>
<p>There are two models for node communication in distributed systems: Shared Memory and Messages Passing. Distributed systems based on the message-passing communication model are inevitably subject to the following errors: processes run slowly, get killed, or restart, and messages may be delayed, lost, or duplicated as a result. The Paxos algorithm solves this problem without considering the <a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98">Byzantine General problem</a>, how to agree on a value in a distributed system where the above exceptions may occur, ensuring that the consensus is not broken regardless of any of the above exceptions, i.e., ensuring data consistency.</p>
<p>Three common consistency models in distributed systems.</p>
<ul>
<li>Strong consistency: when an update operation is executed successfully on a particular replica, all subsequent read operations should be able to obtain the latest data.</li>
<li>Weak consistency: when updating a certain data, it takes a delay for users to read the latest data.</li>
<li>Final Consistency: It is a special kind of weak consistency, when a certain data is updated, after a time slice, all subsequent operations are able to get the new data, and within this time slice, the data may be inconsistent.</li>
</ul>
<p>Raft is a strong consistency algorithm in the distributed domain. When one of the nodes receives a set of instructions from a client, it must communicate with the other nodes to ensure that all nodes receive the same instructions in the same order, and eventually all nodes will produce consistent results, just like a machine.</p>
<h3 id="state-machine-replication">State Machine Replication</h3>
<p>In a distributed environment, if we want to make a service fault-tolerant, the most common way is to have multiple copies of a service running on different nodes at the same time. State Machine Replication is used to ensure that the state of multiple replicas is synchronized at runtime, i.e., that the client gets the same result regardless of which node it sends the request to.</p>
<p>Each server node stores a log containing a series of commands, and its state machine executes the commands in the log sequentially, with the same commands in each log and in the same order, so that each state machine processes the same sequence of commands, which results in the same state and output sequence.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/7bc96574537f4c32b14ff7201c9a8268.png" alt="State Machine Replication"></p>
<p>Raft&rsquo;s job is to ensure that the replication logs are consistent, with the <code>Consensus</code> module on the server receiving commands from the client and adding them to the logs. The server then communicates with the <code>Consensus</code> modules on the other servers to ensure that the same log sequence is available on each server, even if a small number of servers fail to communicate. The state machine on each server executes the commands sequentially and returns the output to the client, thus creating a highly available replicated state machine.</p>
<p>The Raft algorithm, like the Paxos algorithm, has the following properties of distributed consensus algorithms.</p>
<ul>
<li>security (no incorrect results are returned) under all non-Byzantine conditions (including network latency, partitioning and packet loss, duplication, disorder).</li>
<li>The consistency algorithm is available as long as more than half (n/2+1) of the servers are operational and can communicate with each other and with clients. Thus, a typical cluster of five servers can tolerate the failure of any two servers. they can later recover their state and rejoin the cluster if a server suddenly goes down.</li>
<li>that they do not rely on timing to ensure consistent logging, since faulty clocks and extreme message delays can cause availability problems in the worst case.</li>
<li>In general, commands can be completed as long as most servers in the cluster have responded to a single round of remote procedure calls, and a few slow servers will not affect overall system performance.</li>
</ul>
<h2 id="leader-election">Leader Election</h2>
<p>Raft is an algorithm used to manage the log replication process described above. Raft elects a Leader through a &ldquo;leader election mechanism&rdquo; that manages log replication for consistency. A Raft cluster contains several server nodes, each with a unique ID, and at any given moment, each server node is in one of the following three states.</p>
<ul>
<li><strong>Leader</strong>: The Leader handles all client requests, in the usual case there is only one Leader in the system and all other nodes are Follower.</li>
<li><strong>Follower</strong>: the Follower does not send any requests, but simply responds to requests from the Leader or Candidate, and if a client contacts the Follower, then the Follower redirects the request to the Leader.</li>
<li><strong>Candidate</strong>: If the Follower does not receive a message from the Leader, then it becomes Candidate and initiates an election, and the candidate with the majority of votes in the cluster (more than n/2+1) becomes the new Leader.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/49bd8b8e779a47848bef0e5527666f2e.png" alt="Raft Node Status"></p>
<p>Raft splits time into arbitrary lengths of <strong>Term</strong> (Term), which are marked by consecutive integers. Each Term begins with an election, and if a Candidate wins the election, it serves as the leader for that term. In some cases, an election may be split, with each Candidate receiving less than <code>n/2+1</code> votes. The term then ends without a Leader, and a new term and a new election begin again.</p>
<p>Raft guarantees that there will be at most one Leader for a given term.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/939da66b9b2e4ca5923b422d000895ef.png" alt="Raft Leader Election"></p>
<h3 id="node-communication">Node communication</h3>
<p>Nodes in a cluster communicate using Remote Procedure Calls (RPCs). There are three types of RPCs in Raft: <strong>AppendEntries RPC</strong> initiated by the Leader; <strong>RequestVote RPC</strong> initiated by the Candidate during an election; and <strong>InstallSnapshot RPC</strong> initiated by the Leader to send snapshots to the Follower who is behind in the logs. The first two RPCs are described first in this subsection.</p>
<p>AppendEntries RPC is used for log replication and heartbeat messages. The Leader sends client commands to all nodes in parallel via the AppendEntries RPC, which contains the following main fields.</p>
<table>
<thead>
<tr>
<th>parameters</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>term</td>
<td>Leader&rsquo;s term number</td>
</tr>
<tr>
<td>leaderId</td>
<td>Leader Id to allow followers to redirect requests</td>
</tr>
<tr>
<td>prevLogIndex</td>
<td>Index value of the previous log entry</td>
</tr>
<tr>
<td>prevLogTerm</td>
<td>Previous log entry term number</td>
</tr>
<tr>
<td>entries[]</td>
<td>Log entries ready for storage (empty when indicating heartbeat messages; more than one can be sent at a time to improve communication efficiency)</td>
</tr>
<tr>
<td>leaderCommit</td>
<td>The index value of the log that the Leader has committed</td>
</tr>
</tbody>
</table>
<p>RequestVote RPC is used for Candidate to initiate elections to other nodes, with the following main elements.</p>
<table>
<thead>
<tr>
<th>parameters</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>term</td>
<td>Candidate&rsquo;s term number</td>
</tr>
<tr>
<td>candidateId</td>
<td>Candidate Id for ballot request</td>
</tr>
<tr>
<td>lastLogIndex</td>
<td>Candidate Index value of the last log entry</td>
</tr>
<tr>
<td>lastLogTerm</td>
<td>Candidate The term number of the last log entry</td>
</tr>
</tbody>
</table>
<h3 id="election-process">Election process</h3>
<p>When a Raft cluster is started, all nodes are in Follower status, and a node remains in Follower status when it receives a valid RPC from a leader or candidate. the Leader periodically sends heartbeat messages (AppendEntries RPCs without log content) to all followers to maintain its authority. If a Follower does not receive any messages for a period of time, it assumes that there is no leader available in the system and initiates an election to select a new leader.</p>
<blockquote>
<p>Note that a node maintains the Follower state as long as it receives a valid RPC from another node. If the term of the RPC sender is small, then the receiving node ignores the message.</p>
</blockquote>
<p>To start an election process, a Follower first adds 1 to its current term number and converts to Candidate, then it sends a RequestVote RPC to the other nodes in the cluster to vote for itself in parallel.</p>
<ol>
<li>
<p>The first is that it wins the election itself: When a Candidate receives votes for the same term number from most of the nodes in the cluster, it wins the election and becomes the leader. Each node casts at most one ballot for a term number on a first-come, first-served basis, and once the Candidate wins the election, it immediately becomes the Leader, and then it sends heartbeat messages to the other nodes to establish its authority and prevent the creation of a new Leader.</p>
</li>
<li>
<p>The second case is when another node becomes Leader: While waiting for a vote, Candidate may receive an AppendEntries RPC from another server node declaring that it is the leader, and if this node&rsquo;s <code>term</code> field is not less than Candidate&rsquo;s current term number, then Candidate will recognize the Leader&rsquo;s legitimacy and returns to the Follower state. If the term number in this RPC is smaller than its own, then Candidate rejects the RPC and remains in Candidate status.</p>
</li>
<li>
<p>The third scenario is that if more than one Follower becomes a Candidate at the same time, the votes may be split so that no Candidate can win the majority of the nodes. When this happens, the Candidate will experience an election timeout and then add the current term number to start a new round of elections.</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/f9d4e5b7378f4c05a4cdc09bd30d14a7.png" alt="candidate"></p>
<p>The first two cases are better understood, but in the third case, without an additional mechanism, each Candidate will enter the election timeout state and open the next round of election, and the votes may be repeatedly divided indefinitely. To avoid clusters getting stuck in a dead-end election loop, Raft uses <strong>Random Election Timeout</strong> to solve this problem.</p>
<h3 id="random-election-timeout">Random election timeout</h3>
<p>The Raft algorithm uses a random election timeout mechanism to ensure that vote splitting rarely occurs. The election timeout is chosen randomly from a fixed interval (e.g., 150-300 ms), so that the election timeouts are spread out and in most cases only one Candidate will time out.</p>
<p>The same mechanism is used in the case of ballot splitting. Each candidate resets a random election timeout at the beginning of an election, and waits for the results of the vote during the timeout, thus reducing the possibility of additional vote splitting in a new election.</p>
<p>Leadership elections are the most critical aspect of Raft in terms of time requirements. In order for Raft to elect and maintain a stable leader, the system needs to meet the following timing requirements.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">BroadcastTime &lt;&lt; electionTimeout &lt;&lt; Mean Time Between Failures (MTBF)
</span></span></code></pre></td></tr></table>
</div>
</div><p>The broadcast time is the average time it takes to send an RPC from one server node to the other nodes in the cluster in parallel and receive a response. The mean time between failures is the average time between failures for a server.</p>
<p>Raft requires the broadcast time to be an order of magnitude smaller than the election timeout, so a broadcast time of about 10ms is required to meet the election timeout requirement. The mean time between failures requirement is easy to achieve for a stable server that does not go down every few minutes.</p>
<h2 id="log-replication">Log Replication</h2>
<p>When the Leader is elected, it starts serving the client. Each request from a client contains an instruction that is executed by the state machine. The Leader appends this instruction to the log as a new log entry and then launches an AppendEntries RPC to other nodes in parallel. When this log entry is safely replicated, the Leader applies the log entry to its state machine (which executes the instruction) and then returns the result of the execution to the client. If the Follower crashes or runs slowly or loses packets on the network, the Leader keeps retrying to send AppendEntries RPCs (even if the Leader has replied to the client) until all Follower eventually stores all log entries.</p>
<p>Each log entry stores a <strong>State Machine Instruction</strong> and the Leader&rsquo;s <strong>Term Number</strong> when it receives that instruction. The term number is used to detect inconsistencies between multiple copies of the log, and each log entry has an <strong>integer index value</strong> to indicate its position in the log.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/53a4487befe841d3a4ae5414b0ee1aee.png" alt="log entry"></p>
<p>The Leader decides when it is safe to apply a log entry to a state machine: such log entries are called <strong>Committed.</strong> The Raft algorithm ensures that all committed log entries are persistent and will eventually be executed by all available state machines. Once the Leader that created the log entry copies it to more than half of the servers, the log entry is committed. At the same time, all log entries prior to that log entry in the Leader&rsquo;s log are committed, including those created by other Leaders.</p>
<h3 id="log-matching">Log Matching</h3>
<p>Raft has a logging mechanism to maintain a high level of consistency in logs across servers. This not only simplifies and makes the system behavior more predictable, but is also an important part of security.</p>
<p>Raft maintains the following Log Matching features.</p>
<ul>
<li>If two entries in different logs have the same index and term number, then they store the same command.</li>
<li>If two entries in different logs have the same index and term number, then all their previous log entries are also the same.</li>
</ul>
<p>The Leader creates at most one log entry at a log index within a specific term number, while the location of the log entry in the log never changes either, a point that guarantees the first characteristic. The second feature is guaranteed by the AppendEntries RPC performing a simple consistency check: when sending the AppendEntries RPC, the Leader includes the index location <code>prevLogIndex</code> and the term number <code>prevLogTerm</code> of the previous log entry. If the Follower cannot find an entry in its logs that contains the same index location and term number, then he rejects the new log entry.</p>
<p>Thus, whenever the AppendEntries RPC returns a success, the Leader knows that the Follower&rsquo;s log must be the same as its own. However, a Leader crash will leave the log in an inconsistent state.</p>
<h3 id="log-consistency-checking">Log consistency checking</h3>
<p>In the Raft algorithm, the Leader handles inconsistencies by forcing the Follower to replicate its own logs - this means that conflicting log entries in the Follower are overwritten by the Leader&rsquo;s logs.</p>
<p>To keep the Follower&rsquo;s logs and the Leader in a consistent state, the Leader must find the last log entry that they agree on, then delete all logs from the Follower after that log entry and send its own logs to the Follower. These operations are done during the consistency check of the AppendEntries RPC.</p>
<p>The Leader maintains a <code>nextIndex</code> field for each Follower, indicating the index value of the next log entry to be sent to that Follower. When a Leader first gains power, he initializes all <code>nextIndex</code> values to the <code>index</code> of his last log plus 1.</p>
<p>If a Follower&rsquo;s logs do not match the Leader&rsquo;s, then the consistency check fails on the next RPC of the additional logs. After being rejected by the Follower, the Leader decreases the <code>nextIndex</code> value and retries. Eventually <code>nextIndex</code> will be at a point where both parties agree. Then a log overwrite operation is performed to make the Follower&rsquo;s log consistent with the Leader&rsquo;s.</p>
<p>With the log consistency check mechanism, the Leader does not need any special operation to restore consistency when it gains power. the Follower log automatically converges when the consistency check of AppendEntries RPC fails.</p>
<h2 id="safety">Safety</h2>
<p>Since the Raft algorithm ensures data consistency by forcing the Follower logs to be overwritten, and the Leader has the <strong>Append-Only</strong> feature of never overwriting or deleting its own logs. If a node with a small number of log entries is elected as Leader, it can cause a large amount of data loss. To avoid this, Raft adds some restrictions to the leader election to ensure that any Leader has all committed log entries for a given term number.</p>
<h3 id="election-restrictions">Election restrictions</h3>
<p>The transfer of log entries in Raft is one-way, only from the Leader to the Follower, and the Leader never overwrites entries that already exist in its own local log. Raft therefore uses voting to prevent a Candidate from winning an election unless that Candidate contains all the log entries that have been submitted.</p>
<p>The Candidate must contact most of the nodes in the cluster in order to win the election, which means that every log entry that has been submitted must exist on at least one node in the cluster. If Candidate&rsquo;s logs are as new as most of the nodes, then he must have all the committed log entries.</p>
<p>The RequestVote RPC implements the restriction that the RPC contains the Candidate&rsquo;s log information, and Follower rejects voting requests from Candidates whose logs are not new themselves.</p>
<blockquote>
<p>Raft defines whose log is newer by comparing the <code>lastLogIndex</code> and <code>term</code> of the last log entry in the two logs. If the last entries of the two logs have different <code>term</code>, then the log with the larger <code>term</code> is more recent. If the last entry <code>term</code> of both logs is the same, then the log with the larger <code>lastLogIndex</code> is newer.</p>
</blockquote>
<h2 id="membership-changes">Membership Changes</h2>
<p>While the project is running, we may change the configuration of the cluster, such as adding nodes or machines to the configuration. Although this can be done by taking the entire cluster offline, updating all configurations, and then restarting the entire cluster, the cluster will be unavailable for the duration of the change. In addition, if there are manual steps, there is a risk of operational errors. To avoid these problems, Raft incorporates configuration change automation into the algorithm.</p>
<p>In order to make the configuration change mechanism secure, there cannot be any point in time during the conversion process that makes it possible to elect multiple Leaders in the same term. However, any solution where the server directly switches from the old configuration to the new configuration is not safe, because it is impossible to make all nodes switch from the old configuration to the new configuration at the same moment when the members change, then directly switching from the old configuration to the new configuration there may be a node that satisfies the &lsquo;more than half&rsquo; principle for both the old and new configurations.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/e5965dc1b01d48e297cae8ab4328b7a9.png" alt="tow leaders"></p>
<blockquote>
<p>It is not safe to go directly from one configuration to another because the individual machines will switch at different times. In the above diagram, the cluster goes from 3 machines to 5 machines. Unfortunately, there exists a point in time where Server1 can become Leader by its own votes and those of Server2 (satisfying the principle of receiving the majority of votes in the old configuration), and Server3 can become Leader by its own votes and those of Server4 and Server5 (satisfying the majority of votes in the new configuration, i.e., the cluster with 5 nodes). votes principle). At this point, the entire cluster may have two Leaders in the same term, which is contrary to the protocol.</p>
</blockquote>
<h3 id="common-consistency">Common Consistency</h3>
<p>For security purposes, Raft configuration changes are made using a two-phase approach. During the configuration change process <strong>old and new configurations are not aware of each other, and configuration turnover cannot be done overnight</strong>. So before configuration turnover, the cluster is guided into a transition phase so that neither the machines using the new configuration nor the old configuration process logs independently. In Raft, the cluster first switches to a transitional configuration, called a common consistent state, and once the common consistency is committed, then the system switches to the new configuration.</p>
<p>The first phase is called <code>joint consensus</code>, when <code>joint consensus</code> is committed and switched to the new configuration, in the first phase.</p>
<ul>
<li>log entries are replicated to all servers in the cluster in both the old and new configurations.</li>
<li>servers in both the old and new configurations can become Leaders.</li>
<li>reaching consensus (for election and commit) requires majority support on both configurations separately.</li>
</ul>
<p>The specific switching process is as follows.</p>
<ol>
<li>when the Leader receives a configuration change request, it creates a log <code>C-old-new</code> containing the old and new configurations and replicates it to the other nodes.</li>
<li>the Follower makes a decision with the latest configuration present in the log, even if it is not committed, and the Leader makes a decision with this configuration only after <code>C-old-new</code> is copied to most nodes, which is in the process of co-decision.</li>
<li>the new configuration is later committed to all nodes and once the new configuration is committed, the old configuration is discarded.</li>
</ol>
<p>Once a server adds a new configuration log entry to its log, he uses that configuration to make all future decisions (the server always uses the latest configuration, whether it has been committed or not). Co-consistency allows independent servers to perform the configuration transition process at different times without compromising security. In addition, common consistency allows clusters to still respond to client requests during configuration transitions.</p>
<h3 id="boundary-issues">Boundary issues</h3>
<p>There are three more boundary issues to resolve regarding the reconfiguration. The first issue is that the new servers do not store any log entries when they are initialized. When these servers are added to the cluster in this state, it takes a while for updates to catch up. To avoid this availability interval, Raft uses an additional phase before configuration updates in which new servers join the cluster as non-voting (leaders replicate logs to them, but do not consider them a majority). Once the new server catches up with the other machines in the cluster, reconfiguration can be handled as described above.</p>
<p>The second problem is that the Leader of the cluster may not be part of the new configuration. In this case, the Leader will fall back to the Follower state after committing the new configuration log. This means that there is a period of time when the Leader manages the cluster but not himself; he replicates the logs but does not count himself as one of the nodes. The Leader transition occurs when the new configuration is committed, because this is the earliest point at which the new configuration can work independently, before which the leader may only be selected from the old configuration.</p>
<p>The third issue is that removing servers that are not in the new configuration may disrupt the cluster. These servers will no longer receive heartbeats, so when the election times out, they will perform a new election process. They will send a RequestVote RPC with a new term number, which will cause the current Leader to fall back into the Follower state. A new Leader is eventually elected, but the removed server will time out again, and the process will then repeat itself, resulting in a significant reduction in overall availability.</p>
<p>To avoid this problem, the server ignores the RequestVote RPC when it confirms the existence of the current Leader. when the server receives a RequestVote RPC within the current minimum election timeout, it does not update the current term number or cast a ballot. Each server waits at least one minimum election timeout before starting an election. This helps to avoid disruption by removed servers: <strong>If the leader can send a heartbeat message to the cluster in time, then it will not be deposed by a larger term number.</strong></p>
<h2 id="network-partitioning">Network Partitioning</h2>
<p>In a cluster, network partitioning occurs when the network of some nodes fails and the connection to another part of the cluster is broken, forming a relatively independent subnet. the Raft algorithm has different countermeasures for network partitioning in different cases.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/f41a2855345041ed8ce726a52340299d.png" alt="Network Partitioning"></p>
<h3 id="leader-in-a-few-node-partition">Leader in a few-node partition</h3>
<p>In the above figure, assume that Leader node S1 is partitioned in the minority node partition on the left. As time passes, the election timer of the first node in the isolated network partition of the cluster from the Leader node will time out. Assuming that this node is S5, S5 switches to Candidate state and initiates the next round of election. Due to network partitioning, only nodes S4 and S5 in the cluster can receive election requests from node S5, and assuming that node S5 eventually wins the election, there will be two Leaders in the cluster at this time.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/fcc08f9065b74ee882fb1a144114aa15.png" alt="Network partitioning generates multiple Leaders"></p>
<p>When this happens, the Raft algorithm needs to guarantee the consistency of the data requested by the client, and to solve this problem, the cluster needs to do the following.</p>
<ul>
<li>Have the Leader handle the read requests.</li>
<li>Ensure that the current Leader is still a valid Leader.</li>
</ul>
<p>When a client first connects to the cluster, it randomly picks a server node to communicate with, and if the node it first picks is a Follower node, it will redirect the request to the Leader node, which will handle the read and write requests. The Leader initiates a broadcast to ensure that most nodes in the cluster are contacted to ensure its authority before processing the client request.</p>
<p>In the above figure, since S1 node cannot communicate with most of the nodes in the cluster, it cannot process the client requests properly and all the requests are processed by S5. Eventually, the data state of S1 partition stays at the moment of partition occurrence, while all data processing after partition occurrence is stored in S5 partition.</p>
<p>When the network partition failure is repaired, the heartbeat messages sent by node S1 will be received by nodes S3, S4, and S5. However, the Term values carried in these heartbeat messages are smaller than the current Term values of S3, S4, and S5 nodes, so they are ignored by S3, S4, and S5 nodes; meanwhile, the heartbeat messages sent by node S5 are received by nodes S1 and S2. Since the Term value of these heartbeat messages is greater than the Term value of current S1 and S2 nodes, nodes S1 and S2 will switch to Follower state, and finally node S5 becomes the Leader of the whole cluster.</p>
<h3 id="leader-in-a-majority-node-partition">Leader in a majority-node partition</h3>
<p>If a Leader node is partitioned into a partition with more nodes when the network is partitioned, the election timer of a node in the partition with fewer nodes will time out, switch to Candidate and initiate a new round of election. However, since the number of nodes in the partition is less than half, it is not possible to elect a new Leader, which results in the nodes in the partition continuously initiating elections and increasing the Term number.</p>
<p>Raft protocol deals with this situation, when a node wants to initiate an election, it needs to enter the state of PreVote first, and the node will try to connect to other nodes in the cluster first, and if it can successfully connect to more than half of the nodes, it can switch to Candidate status and actually initiate a new round of election.</p>
<h2 id="log-compression">Log Compression</h2>
<p>When there are more and more logs in the system, they can take up a lot of space.</p>
<p>The Raft algorithm uses a snapshot mechanism to compress the huge logs. At a certain point in time, all the state of the entire system is steadily written to persistable storage, and then all logs after that point in time are cleared.</p>
<p>Usually servers create snapshots independently, but the Leader occasionally sends snapshots to some lagging nodes, such as a slow Follower or a new server joining the cluster, and sends snapshots over the network to bring the Follower up to date.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/22/8c735b27e52c447099ba3230d4fa8246.png" alt="Snapshot RPC"></p>
<p>The Leader uses InstallSnapshot RPC chunks to send snapshots to Follower that is too far behind. If the snapshot contains duplicate log entries, then Follower removes the entries that exist in the log and adopts the data in the snapshot.</p>
<p>Follower can create snapshots without the Leader&rsquo;s knowledge, and although the snapshot approach deviates from Raft&rsquo;s strong leader principle, we believe the deviation is worthwhile. Leaders exist to resolve conflicts when consistency is reached, but by the time a snapshot is created, consistency has been reached and there is no conflict, so it is possible to do without a Leader. The data is still passed from the Leader to the Follower, but the Follower can reorganize their data.</p>
<h2 id="summary">Summary</h2>
<p>The implementation of the Raft algorithm is clear, logically follows human intuition, and is described in detail, taking into account some boundary issues that not only improve Raft&rsquo;s comprehensibility but also convince of its correctness.</p>
<p>The Raft algorithm decomposes the consensus problem into several relatively independent word problems, and the overall process is that the nodes elect the Leader, who is responsible for log replication and commit. In order to keep the system error-free in any abnormal situation, Raft imposes a number of constraints on leader election and log replication.</p>
<ul>
<li>Using random election timeouts to avoid vote splitting.</li>
<li>Using consistency checks to handle log inconsistencies.</li>
<li>Keeping new Leader data up-to-date with election restriction policies.</li>
<li>Using minimum election timeout to ensure the authority of the Leader.</li>
</ul>
<p>This design idea of decomposing complex problems is a good description of how Raft solves consistency problems in distributed systems, and suggests certain solutions to help developers better apply them to their projects.</p>
<blockquote>
<p>The main content and some images are from the paper <a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">In Search of an Understandable Consensus Algorithm</a> and <a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md">Finding an Understandable Consensus Algorithm (extended version)</a></p>
</blockquote>
<h2 id="reference">Reference</h2>
<ul>
<li><code>https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86</code></li>
<li><code>https://zh.wikipedia.org/zh-cn/Paxos%E7%AE%97%E6%B3%95</code></li>
<li><code>https://zh.wikipedia.org/wiki/Raft</code></li>
<li><code>https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98</code></li>
<li><code>https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6</code></li>
<li><code>https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14</code></li>
<li><code>https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md</code></li>
<li><code>https://raft.github.io/</code></li>
<li><code>https://www.jianshu.com/p/2a2ba021f721</code></li>
<li><code>http://ifeve.com/%E8%A7%A3%E8%AF%BBraft%EF%BC%88%E5%9B%9B-%E6%88%90%E5%91%98%E5%8F%98%E6%9B%B4%EF%BC%89/</code></li>
<li><code>https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/</code></li>
<li><code>https://wingsxdu.com/posts/algorithms/raft/</code></li>
</ul>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/cryptographic-hashing-function/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Implementation principle of cryptographic hash algorithm</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/go-1-19/">
            <span class="next-text nav-default">A few notable changes in Go 1.19</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
