<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Principles and Implementation of etcd, a Distributed Key-Value Store - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Learn the principles and implementation of etcd, a distributed key-value store." /><meta name="keywords" content="Etcd" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-08/etcd/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Principles and Implementation of etcd, a Distributed Key-Value Store" />
<meta property="og:description" content="Learn the principles and implementation of etcd, a distributed key-value store." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-08/etcd/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-08-18T10:48:27+08:00" />
<meta property="article:modified_time" content="2022-08-18T10:48:27+08:00" />

<meta itemprop="name" content="Principles and Implementation of etcd, a Distributed Key-Value Store">
<meta itemprop="description" content="Learn the principles and implementation of etcd, a distributed key-value store."><meta itemprop="datePublished" content="2022-08-18T10:48:27+08:00" />
<meta itemprop="dateModified" content="2022-08-18T10:48:27+08:00" />
<meta itemprop="wordCount" content="11198">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Principles and Implementation of etcd, a Distributed Key-Value Store"/>
<meta name="twitter:description" content="Learn the principles and implementation of etcd, a distributed key-value store."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Principles and Implementation of etcd, a Distributed Key-Value Store</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-08-18 10:48:27 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 11198 words </span>
          <span class="more-meta"> 53 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#distributed-consensus">Distributed Consensus</a>
          <ul>
            <li><a href="#state-machine-replication">State Machine Replication</a></li>
            <li><a href="#leader-election">Leader Election</a></li>
            <li><a href="#data-channel">Data channel</a></li>
          </ul>
        </li>
        <li><a href="#raft-module">Raft module</a>
          <ul>
            <li><a href="#entry">Entry</a></li>
            <li><a href="#raftlog">RaftLog</a></li>
            <li><a href="#node">Node</a></li>
            <li><a href="#writing-request-flow">Writing request flow</a></li>
          </ul>
        </li>
        <li><a href="#data-persistence">Data Persistence</a>
          <ul>
            <li><a href="#pre-written-logs">Pre-written logs</a></li>
            <li><a href="#snapshots">Snapshots</a></li>
          </ul>
        </li>
        <li><a href="#state-machine-storage">State Machine Storage</a>
          <ul>
            <li><a href="#concurrency-control">Concurrency Control</a></li>
            <li><a href="#index">Index</a></li>
            <li><a href="#backend">Backend</a></li>
          </ul>
        </li>
        <li><a href="#linear-consistency-read">Linear Consistency Read</a>
          <ul>
            <li><a href="#data-consistency">Data Consistency</a></li>
            <li><a href="#readindex">ReadIndex</a></li>
            <li><a href="#read-only-request-handling">Read-only request handling</a></li>
            <li><a href="#raft-consensus">Raft Consensus</a></li>
            <li><a href="#application-layer-processing">Application layer processing</a></li>
            <li><a href="#summary-of-this-section">Summary of this section</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
        <li><a href="#reference">Reference</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>etcd is an open source project initiated by CoreOS to build a highly available distributed key-value storage system. etcd can be used to store critical data and implement distributed orchestration and configuration services, playing a key role in modern cluster operations.</p>
<p>etcd is a distributed key-value storage service based on the Raft consensus algorithm. The project structure is modular, with the Raft module for distributed consensus, the WAL module for data persistence, and the MVCC module for state machine storage. These modules communicate and assign tasks through the etcdServer module. This article will focus on these three modules to analyze how etcd is implemented, how to achieve data consistency among multiple nodes of etcd, how to achieve high performance concurrent read and write transactions, and finally, how etcd solves the important problem of linear consistency reads. This article will give us a better understanding of the key features of etcd.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/e15d9703ea374d11b349ae3f8c2f7f25.png" alt="etcd"></p>
<h2 id="distributed-consensus">Distributed Consensus</h2>
<p>The consensus problem is one of the most important and fundamental problems in distributed computing, commonly understood as the goal of getting multiple nodes to agree on something, so before analyzing the specific implementation of etcd introduce some important concepts in Raft&rsquo;s consensus algorithm. It is highly recommended to read the Raft paper <em><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">In Search of an Understandable Consensus Algorithm</a></em> first, which is very helpful for understanding the principles of etcd implementation is very helpful.</p>
<h3 id="state-machine-replication">State Machine Replication</h3>
<p>In a distributed environment, if we want to make a service fault-tolerant, the most common way is to have multiple copies of a service running on multiple nodes at the same time. To ensure that the state of multiple replicas is synchronized at runtime, i.e., that the client gets the same result no matter which node it sends the request to, State Machine Replication is often used.</p>
<p>State machine replication is implemented using log replication. etcd instantiates logs as Entry logs, and each node stores a series of Entry logs, which are identical and in the same order for each node. The state machine executes the commands in the Entry in order, so each state machine processes the same sequence of commands, which results in the same data state and output sequence.</p>
<p>Raft&rsquo;s job is to ensure that the replication logs are consistent. The <code>Consensus</code> module on the server node receives write requests from clients and adds them to the WAL (Write Ahead Log). This server then communicates with the <code>Consensus</code> modules on the other servers to ensure that the same sequence of logs is available on each server. The state machine on each server executes the commands sequentially and returns the execution results to the client, thus creating a highly available replicated state machine.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/4542f774d726481f93f8d9263aa78342.png" alt="replicated state machine"></p>
<blockquote>
<p>The above figure is modified from the paper: <a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">In Search of an Understandable Consensus Algorithm</a> Figure 1</p>
</blockquote>
<p>The replication state machine is an abstract module, and the state machine data is maintained by a separate back-end storage module. Each write request from the client is first persisted to a WAL file, and then the state machine data is modified based on the contents of the write request. A read request for data requires querying the data from the state machine instead of directly fetching the latest log entry maintained by the current node. To prevent data overload, etcd periodically generates snapshots to compress the data. Normally, as long as more than a quorum (n/2+1) of nodes in the cluster respond to a single round of remote procedure calls, the client&rsquo;s request is considered to have been executed, and a few slow servers do not affect the overall system performance.</p>
<h3 id="leader-election">Leader Election</h3>
<p>Raft is an algorithm used to manage the log replication process. Raft elects a Leader through a &ldquo;leader election mechanism&rdquo;, which manages log replication for consistency. A Raft cluster consists of several server nodes, each with a unique identification ID.</p>
<p>The Raft algorithm paper specifies three node identities: Leader, Follower, and Candidate, and the etcd implementation adds PreCandidate and Learner.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/cb60f223d8d9497d9b5de1bbed485428.png" alt="Node identity switching"></p>
<blockquote>
<p>The above figure is modified from the paper <a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">In Search of an Understandable Consensus Algorithm</a> Figure 4</p>
</blockquote>
<p>The cluster starts with all nodes in the Follower state, and then one node is successfully elected as Leader, and the majority of the time the nodes in the cluster will be in one of these two states. When a Follower node&rsquo;s election timer times out, it enters the <code>preVote</code> state (switches to PreCandidate status) and before it is ready to initiate an election, it needs to try to connect to other nodes in the cluster and ask them if they want to participate in the election. If the other nodes in the cluster can receive the Leader&rsquo;s heartbeat message properly, then it will refuse to participate in the election. If more than a quorum of nodes respond and indicate their participation in the new election, the node switches from PreCandidate status to Candidate and initiates a new round of election.</p>
<blockquote>
<p>The preVote mechanism prevents outlier nodes from frequently refreshing their tenure values, preventing the node from rejoining the cluster with a larger tenure value to depose the Leader.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/raft.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">Step</span><span class="p">(</span><span class="nx">m</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgHup</span><span class="p">:</span>        <span class="c1">// The election timer timeout creates the MsgHup message, where the pre-voting and official voting are combined
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">StateLeader</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">preVote</span> <span class="p">{</span> <span class="c1">// Pre-voting
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">r</span><span class="p">.</span><span class="nf">campaign</span><span class="p">(</span><span class="nx">campaignPreElection</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>       <span class="c1">// Official Election
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">r</span><span class="p">.</span><span class="nf">campaign</span><span class="p">(</span><span class="nx">campaignElection</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x ignoring MsgHup because already leader&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Learner is a new role introduced in etcd 3.4. When a new node joins the cluster without any log entries stored in its state machine, it takes a long time to synchronize the logs, which may cause the cluster to be unable to process new requests. To avoid this availability interval, new nodes join the cluster as non-voting Learner and no election is initiated after the election timer times out (the Leader does not consider them to be in the majority of the cluster.) The Leader sends snapshots to the Learner so that the Learner can quickly catch up with the logs. When the Learner agrees with the Leader log, it switches to its normal identity.</p>
<p>In particular, when a node becomes a Leader, it immediately commits an empty log, sets all logs it carries to commit status, and all log entries before that log entry are also committed, including those created by other Leaders but not yet committed, and then synchronizes to other nodes in the cluster. This ensures the consistency of the cluster data and prevents data loss during the Leader node switchover.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/raft.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">becomeLeader</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Omit the initialize raft structure step
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">emptyEnt</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nf">appendEntry</span><span class="p">(</span><span class="nx">emptyEnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panic</span><span class="p">(</span><span class="s">&#34;empty entry was dropped&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">r</span><span class="p">.</span><span class="nf">reduceUncommittedSize</span><span class="p">([]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">{</span><span class="nx">emptyEnt</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x became leader at term %d&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="data-channel">Data channel</h3>
<p>The Raft module well does not provide an implementation of the network layer, but rather encapsulates the messages to be sent into Ready instances that are returned to the upper-level module, which then decides how to send them to other nodes in the cluster.</p>
<p>In etcd&rsquo;s communication module, etcd defines 19 different types of messages (Messages) depending on the purpose. The size of the data carried by these messages may vary, for example, a heartbeat message sent by a Leader to a Follower node may only be a few tens of bytes, while a PRC snapshot transmission can be larger, even over 1GB.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/d863a9bb424447cb93968b52e5081659.png" alt="etcd Data channel"></p>
<p>To enable the network layer to efficiently handle messages with different data volumes, etcd takes a categorical approach by abstracting two types of messaging channels, Stream and Pipeline. Both channels use gRPC to transfer data. stream channel is used to handle messages with less data volume that are sent more frequently, such as heartbeat messages, append log messages, etc. Only one HTTP long connection is maintained between nodes, and data is written to the connection alternately. pipeline channel is used to handle messages with more data volume, such as snapshot messages. This type of message needs to be handled separately from heartbeat messages, otherwise it will block the transmission of heartbeat packets, which will affect the stability of the cluster. pipeline channel only transmits data through short connections and closes when it runs out.</p>
<blockquote>
<p>Pipeline type channels can also be used to transfer small data volumes when Stream type connections are not available. In addition, Pipeline type channels can be used to send multiple messages in parallel.</p>
</blockquote>
<p>The communication module is not the focus of this article, the concepts related to the data channel are described here in general. Perhaps the implementation of gRPC will be explained in detail in a later article.</p>
<h2 id="raft-module">Raft module</h2>
<p>After understanding the concepts related to distributed consensus, let&rsquo;s see how the consensus module is implemented. etcd&rsquo;s consensus module is implemented in the <code>raft</code> structure, which is a very complex structure that implements key features such as logical clock functions, message handling functions, election timers, and so on. Since these are written according to the Raft algorithm, we will not go into the details of the implementation here, but you can read the code in <a href="https://github.com/etcd-io/etcd/blob/master/raft/raft.go">etcd/raft/raft.go</a> if you are interested. In the following, the term &lsquo;Raft module&rsquo; is used to refer to the <code>raft</code> structure and its implementation, and the concepts are introduced in a fragmented form where needed.</p>
<p>etcd&rsquo;s Raft module only implements the basic behavior of the Raft protocol and does not implement network transfers, persistent storage, state machines, etc. etcd separates these modules and the Raft module provides a set of interface implementations for these application layer modules. Let&rsquo;s understand the concepts involved.</p>
<h3 id="entry">Entry</h3>
<p>All data (key-value pairs) maintained by the Raft module are instantiated as Entry log representations, and each Entry log maintains its own private data.There are two main types of Entry logs, one for storing normal key-value pair data (EntryNormal) and another for storing configuration information after a cluster configuration change ( EntryConfChange), when the cluster state changes, also by sending Entry logs to other nodes to transmit the new configuration information.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/wal/walpb/raft.pd.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Entry</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Term</span>             <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Index</span>            <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Type</span>             <span class="nx">EntryType</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Data</span>             <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="nx">EntryNormal</span>       <span class="nx">EntryType</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nx">EntryConfChange</span>   <span class="nx">EntryType</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nx">EntryConfChangeV2</span> <span class="nx">EntryType</span> <span class="p">=</span> <span class="mi">2</span> <span class="c1">// for etcd V2 version
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>All write requests in the Raft algorithm are handled by the Leader node, and the data sent by the client needs to be encapsulated into an Entry log before the Leader can append the log. The <code>Data</code> field is the key-value pair sent by the client, the <code>Term</code> field is the term of the current cluster, and the <code>Index</code> field is the index of the Entry log, which is equivalent to a globally unique ID.</p>
<p>These Entry logs are appended to RaftLog after the data is encapsulated.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/raft.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">appendEntry</span><span class="p">(</span><span class="nx">es</span> <span class="o">...</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="p">(</span><span class="nx">accepted</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">li</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span>  <span class="c1">// Get the index value of the last log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">es</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">es</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Term</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Term</span>
</span></span><span class="line"><span class="cl">        <span class="nx">es</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Index</span> <span class="p">=</span> <span class="nx">li</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">li</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">es</span><span class="o">...</span><span class="p">)</span> <span class="c1">// Append Entry logs to raftLog
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="raftlog">RaftLog</h3>
<p>The Raft module uses the RaftLog structure to manage Entry logs on nodes. RaftLog maintains two data storage structures <code>unstable</code> and <code>MemoryStorage</code> (in some source code comments, <code>MemoryStorage</code> is described as <code>Stable Storage</code>), both of which Entry logs are maintained in memory.</p>
<p>When the client sends a write request to the etcd cluster, the Raft module saves the Entry logs encapsulated in the request to the unstable, which is unstable because the Entry logs maintained in the unstable are not yet persistent in memory, so if the server goes down, this data will be lost. This data is unstable.
The Raft module then notifies etcdServer to persist the Entry logs to a WAL file and then &lsquo;moves&rsquo; the Entry logs from the unstable to MemoryStorage.</p>
<blockquote>
<p>Although the word &ldquo;move&rdquo; is used above, the actual process is that etcdServer first appends the Entry logs to MemoryStorage, and then notifies the Raft module to clear the corresponding logs from the unstable.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/log_unstable.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">unstable</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">snapshot</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Snapshot</span> <span class="c1">// Snapshot data not written to Storage
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">entries</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span>    <span class="c1">// Entry logs that are not written to Storage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">offset</span> <span class="kt">uint64</span>         <span class="c1">// Index value of the first Entry log in entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// etcd/raft/storage.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">MemoryStorage</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">hardState</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">HardState</span>
</span></span><span class="line"><span class="cl">    <span class="nx">snapshot</span>  <span class="nx">pb</span><span class="p">.</span><span class="nx">Snapshot</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ents[i] has raft log position i+snapshot.Metadata.Index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ents</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span>       <span class="c1">// Note that ents[0] is a dummy data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// etcd/raft/log.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">raftLog</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">storage</span> <span class="nx">Storage</span>
</span></span><span class="line"><span class="cl">    <span class="nx">unstable</span> <span class="nx">unstable</span>
</span></span><span class="line"><span class="cl">    <span class="nx">committed</span> <span class="kt">uint64</span>      <span class="c1">// Maximum index value of committed Entry logs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">applied</span> <span class="kt">uint64</span>        <span class="c1">// Maximum index value of applied Entry logs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">logger</span> <span class="nx">Logger</span>
</span></span><span class="line"><span class="cl">    <span class="nx">maxNextEntsSize</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Both unstable and MemoryStorage have an uncomplicated structure. The <code>MemoryStorage.snapshot</code> field maintains the index and term values of the last log contained in the most recent snapshot, so ents[i] represents the entry log with index value <code>i+snapshot.Metadata.Index</code>. Entry log (ents[0] is a dummy data and i is calculated from 1). The <code>unstable.offset</code> field stores the index value of the first log in entries, by which the log with the specified index can be obtained.</p>
<p>etcd applied logs are written to the state machine asynchronously, so RaftLog maintains not only the maximum index value of the committed Entry logs, but also the maximum index value of the applied (written to the state machine) Entry logs, and applied &lt;= committed, two parameters that play an important role in the linear consistency of etcd. The author will analyze this issue in the following.</p>
<p>From these aspects, we can see that the logical structure of RaftLog is viewed as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/d88c5799704e4be3a1090b64fa8a9e0e.png" alt="logical structure of RaftLog"></p>
<p>Unstable and MemoryStorage provide many of the same APIs for RaftLog, such as getting the index of the first or last log in the Entry array, getting the term of the log corresponding to a given index, etc. When RaftLog needs this metadata, it will first look it up in unstable, and if it doesn&rsquo;t find it, then look it up in MemoryStorage.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">unstable</span><span class="p">)</span> <span class="nf">truncateAndAppend</span><span class="p">(</span><span class="nx">ents</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">after</span> <span class="o">:=</span> <span class="nx">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Index</span> <span class="c1">// Get the index value of the first Entry record to be appended
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">after</span> <span class="o">==</span> <span class="nx">u</span><span class="p">.</span><span class="nx">offset</span><span class="o">+</span><span class="nb">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// If the record to be appended is contiguous with the record in entries, then you can append directly to entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">ents</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">after</span> <span class="o">&lt;=</span> <span class="nx">u</span><span class="p">.</span><span class="nx">offset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Replace the current entries field with the entry record to be appended, and update the offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">u</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;replace the unstable entries from index %d&#34;</span><span class="p">,</span> <span class="nx">after</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">u</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nx">after</span>
</span></span><span class="line"><span class="cl">        <span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nx">ents</span>
</span></span><span class="line"><span class="cl">    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// After is between offset and last, keep the records between offset and after, and discard the records after.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">u</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;truncate the unstable entries before index %d&#34;</span><span class="p">,</span> <span class="nx">after</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">{},</span> <span class="nx">u</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">after</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">ents</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If a conflict arises when appending data to the unstable and MemoryStorage, the original conflicting data will be overwritten and the latest data received by the node will take precedence. If the conflicting data when appending to the unstable is so large that it exceeds the boundary between the unstable and the MemoryStorage, RaftLog does not modify the log in the MemoryStorage, but truncates the data and keeps only the second half.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/84f0dd208c7f420c80cc0d47c2462646.png" alt="RaftLog Data Conflict"></p>
<blockquote>
<p>Data conflict scenarios only happen with Follower nodes, and Leaders have the <strong>Append-Only</strong> feature of never overwriting or deleting their own logs.</p>
</blockquote>
<h3 id="node">Node</h3>
<p>etcd represents a node in a cluster with the structure <code>Node</code>, which is a layer of wrappers for the Raft module and provides a relatively simple API interface to the external world. The main role is to bridge the messaging between the application layer and the Raft module, passing messages from the application layer to the Raft consensus module, and feeding the results of the consensus module processing back to the application layer. The goroutine gets caught in a huge <code>for-select-channel</code> event loop, constantly fetching data from the channels for processing. The <code>node.run</code> method has three main purposes.</p>
<ul>
<li>One is to check if the Raft module has any data that needs to be processed by the higher-level module, and if so it will encapsulate this data into a <code>Ready</code> structure and send it to the higher-level module via the readyc channel.</li>
<li>The second is to detect if the Leader node of the cluster has changed, and if so, to pause the processing of client requests (MsgProp type messages).</li>
<li>Third, it listens or sends data to various types of channels, such as client requests, inter-node communication, etc., and waits for other modules to process the data.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/node.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Omitting initialization variables
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">advancec</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">readyc</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">rn</span><span class="p">.</span><span class="nf">HasReady</span><span class="p">()</span> <span class="p">{</span>        <span class="c1">// Check if there is data that needs to be processed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">rd</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">rn</span><span class="p">.</span><span class="nf">readyWithoutAccept</span><span class="p">()</span> <span class="c1">// Create Ready data structures for higher-level processing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">readyc</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">readyc</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">lead</span> <span class="o">!=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lead</span> <span class="p">{</span>                <span class="c1">// Detects if the current Leader node has changed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nf">hasLeader</span><span class="p">()</span> <span class="p">{</span>             <span class="c1">// If the current node cannot identify the Leader in the cluster
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">propc</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">propc</span>            <span class="c1">// Clear propc, this loop does not process MsgProp messages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">propc</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="nx">lead</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lead</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">pm</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">propc</span><span class="p">:</span>                <span class="c1">// Processing client requests
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">m</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">n</span><span class="p">.</span><span class="nx">recvc</span><span class="p">:</span>               <span class="c1">// Handles communication between nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">readyc</span> <span class="o">&lt;-</span> <span class="nx">rd</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">n</span><span class="p">.</span><span class="nx">rn</span><span class="p">.</span><span class="nf">acceptReady</span><span class="p">(</span><span class="nx">rd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">advancec</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">advancec</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Omit listening to other types of channels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Since Node is not responsible for data persistence and other functions, the Raft module will pack the data that needs to be processed by the upper-level module into the <code>Ready</code> structure and send <code>Ready</code> to the upper-level module for processing through the readyc channel, and the upper-level module will call the <code>node.Advance()</code> method after processing the data to notify the Raft module that the data has been processed and is ready to send new data for processing.</p>
<p>The <code>Ready</code> structure passes a variety of data that needs to be processed by the upper layer, the specific data types of which are shown in the following snippet.</p>
<p>The <code>raftNode.start</code> method of etcdServer starts a separate goroutine to accept these data and sort them: it writes the Entries, Snapshot of the <code>Ready</code> structure to the persistence file and appends them to MemoryStorage; it applies the CommittedEntries to the state machine; and Messages are broadcast to other nodes in the cluster.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/node.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Ready</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="nx">SoftState</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pb</span><span class="p">.</span><span class="nx">HardState</span>                <span class="c1">// Node Status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ReadStates</span> <span class="p">[]</span><span class="nx">ReadState</span>      <span class="c1">// Read-only requests waiting to be processed by the current node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Entries</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span>          <span class="c1">// unstable Logs to be persisted to WAL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Snapshot</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Snapshot</span>        <span class="c1">// Snapshot data to be persisted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">CommittedEntries</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span> <span class="c1">// Entry logs submitted, pending applications
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Messages</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span>       <span class="c1">// The current node waits for messages to be sent to other nodes in the cluster
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">MustSync</span> <span class="kt">bool</span>               <span class="c1">// Mark whether HardState and Entries are written to disk synchronously or asynchronously
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>From here, we can see that the process of applying logs and sending messages by etcd is asynchronous, so the fact that a log has been committed does not mean that it has been applied to the state machine, and the fact that the Leader has applied this log does not mean that all Follower has applied this log, each node will decide the timing of applying the log independently, and there may be some delay in between.</p>
<blockquote>
<p>Although the etcd application logging process is asynchronous, this batch strategy enables multiple logs to be written in bulk at once, which can improve the I/O performance of the node.</p>
</blockquote>
<h3 id="writing-request-flow">Writing request flow</h3>
<p>After introducing a few important concepts of the Raft module, here is a brief summary of the general flow of etcd writing to an Entry log, so that we can better understand how etcd works.</p>
<ol>
<li>when a client sends a write request to the etcd cluster, the Entry log encapsulated in the request is handed over to the Raft module for processing, which first saves the Entry log to the unstable.</li>
<li>when the time is right (after the etcdServer has processed the last Ready instance), the Raft module encapsulates the Entry log in a Ready instance and returns it to the upper-level module for persistence.</li>
<li>when the upper module receives the Entry log to be persisted, it first writes it to the WAL file, then broadcasts this data to the other nodes in the cluster, and finally sends a signal to the Raft module for the next step.</li>
<li>the Raft module &lsquo;moves&rsquo; the Entry log from unstable to MemoryStorage.</li>
<li>when the Entry log is copied to more than half of the nodes in the cluster, the Entry log will be confirmed as committed by the Leader node, and the Leader will reply to the client with a successful write request, and return the Entry log to the upper module in a Ready instance.</li>
<li>The upper layer module applies the entry logs carried in the Ready instance to the state machine.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/27a8d3537da34cb696d441dcb9634e23.png" alt="Writing request flow"></p>
<p>With the above steps etcd completes a write operation. However, just because a Leader node applies data to the state machine does not mean that other nodes in the cluster will also apply data to the state machine, so if you read data from etcd at this point you may get old data. etcd has additional mechanisms to address this issue. This part will be described below.</p>
<h2 id="data-persistence">Data Persistence</h2>
<p>etcd is persistent as soon as data is updated by default, and uses WAL (Write Ahead Log) for data persistence storage. WAL records the entire process of data changes, and all data in etcd is written to WAL before it is committed. etcd also periodically takes snapshot backups of data, which store all data in etcd at a given time. The WAL file can be deleted if the data is already stored in the snapshot.</p>
<h3 id="pre-written-logs">Pre-written logs</h3>
<p>The Raft module encapsulates the Entry logs sent by the client into a Ready instance and sends it to the upper-level module for persistence. etcdServer receives the Entry logs to be persisted and records them to a WAL file for persistence to disk.</p>
<p>In the WAL log file, each log record is structured as a structure <code>Record</code>, and the structure is serialized into the log file in the format of Protocol Buffers, where the meaning of each field is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/wal/walpb/record.pd.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Record</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Type</span> <span class="kt">int64</span>  <span class="c1">// The Record instance type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Crc</span> <span class="kt">uint32</span>  <span class="c1">// Checksum of this Record instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">Data</span> <span class="p">[]</span><span class="kt">byte</span> <span class="c1">// Log Data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// etcd/wal/wal.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>          <span class="c1">// Record Instance Type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">metadataType</span> <span class="kt">int64</span> <span class="p">=</span> <span class="kc">iota</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1">// The Data field of this type of Record holds the metadata
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">entryType</span>    <span class="c1">// The Data field of this type of Record holds the Entry log
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">stateType</span>    <span class="c1">// The Data field of this type of Record holds information about the current state of the cluster (draftpb.HardState)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">crcType</span>      <span class="c1">// This type of Record is mainly used for data validation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">snapshotType</span> <span class="c1">// This type Record holds information about the snapshot data (walpb.Snapshot)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As you can see from the Record&rsquo;s instance type, etcd&rsquo;s WAL files not only store Entry logs, but also cluster status information, snapshot metadata information, and other important data. Each WAL file stores a metadata of type <code>metadataType</code> in the header, which is defined in the Metadata structure of the <code>etcdserver/etcdserverpb/etcdserverpb.pb.go</code> file and holds the <code>NodeID</code> and <code>ClusterID</code> of the current node. ClusterID`, which identifies the state of the cluster at the time the file was created.</p>
<h4 id="file-management">File Management</h4>
<p>WAL&rsquo;s externally exposed interface for creating new files is the <code>Create()</code> function, which initializes a temporary file and pre-allocates 64MB of storage, creating the new file by writing metadata of type <code>metadataType</code> and an empty <code>snapshotType</code> record in the header. After the initialization operation is completed, the file is renamed and the system call function <code>fsync()</code> is called to flush the above file operations to disk immediately. Since the whole process is executed synchronously, it is seen as an atomic operation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/wal/wal.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Create</span><span class="p">(</span><span class="nx">lg</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span><span class="p">,</span> <span class="nx">dirpath</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">metadata</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">WAL</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nf">Exist</span><span class="p">(</span><span class="nx">dirpath</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">ErrExist</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create temporary files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">tmpdirpath</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Clean</span><span class="p">(</span><span class="nx">dirpath</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;.tmp&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">fileutil</span><span class="p">.</span><span class="nf">Exist</span><span class="p">(</span><span class="nx">tmpdirpath</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">RemoveAll</span><span class="p">(</span><span class="nx">tmpdirpath</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fileutil</span><span class="p">.</span><span class="nf">CreateDirAll</span><span class="p">(</span><span class="nx">tmpdirpath</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">tmpdirpath</span><span class="p">,</span> <span class="nf">walName</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fileutil</span><span class="p">.</span><span class="nf">LockFile</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nx">O_WRONLY</span><span class="p">|</span><span class="nx">os</span><span class="p">.</span><span class="nx">O_CREATE</span><span class="p">,</span> <span class="nx">fileutil</span><span class="p">.</span><span class="nx">PrivateFileMode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Locate the end of the file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">Seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">SeekEnd</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Pre-allocated file space, size 64MB
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">fileutil</span><span class="p">.</span><span class="nf">Preallocate</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="nx">SegmentSizeBytes</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">w</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">WAL</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">lg</span><span class="p">:</span>       <span class="nx">lg</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">dir</span><span class="p">:</span>      <span class="nx">dirpath</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">metadata</span><span class="p">:</span> <span class="nx">metadata</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Create an encoder for WAL files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">w</span><span class="p">.</span><span class="nx">encoder</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">newFileEncoder</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">File</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Adding FD to the locks array
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">w</span><span class="p">.</span><span class="nx">locks</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nx">locks</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">saveCrc</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Record the Record of type metadataType in the header of the WAL file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">encoder</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">walpb</span><span class="p">.</span><span class="nx">Record</span><span class="p">{</span><span class="nx">Type</span><span class="p">:</span> <span class="nx">metadataType</span><span class="p">,</span> <span class="nx">Data</span><span class="p">:</span> <span class="nx">metadata</span><span class="p">});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Then write an empty snapshotType Record
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">SaveSnapshot</span><span class="p">(</span><span class="nx">walpb</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">{});</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">renameWAL</span><span class="p">(</span><span class="nx">tmpdirpath</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span> <span class="c1">// Rename the file after initialization is complete
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">perr</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">perr</span> <span class="p">=</span> <span class="nx">fileutil</span><span class="p">.</span><span class="nf">Fsync</span><span class="p">(</span><span class="nx">pdir</span><span class="p">);</span> <span class="nx">perr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span> <span class="c1">// Synchronize the above file operations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">perr</span> <span class="p">=</span> <span class="nx">pdir</span><span class="p">.</span><span class="nf">Close</span><span class="p">();</span> <span class="nx">perr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span> <span class="c1">// Close Directory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">w</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>etcd&rsquo;s pre-write log uses the structure <code>WAL</code> to maintain information about the WAL instance, where the <code>locks</code> field records the handles of all WAL files currently held by the WAL instance. etcd puts a mutex lock on the WAL file, so the WAL file is either read-only (node reboot data recovery) or write-only, which is done to ensure that the data is This is done to ensure data security.</p>
<p>When the WAL file size exceeds 64MB, it needs to be cut and switched, the logic of which is implemented in the <code>WAL.cut()</code> method. The <code>WAL.fp.run()</code> method is responsible for pre-creating temporary files and pre-allocating space, it runs in a separate goroutine to create temporary files ending with <code>.tmp</code> in advance, when it is necessary to switch WAL files, the <code>WAL.cut()</code> method directly gets the temporary files from the background goroutine, rename them and use them.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/wal/file_pipeline.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">fp</span> <span class="o">*</span><span class="nx">filePipeline</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">fp</span><span class="p">.</span><span class="nx">errc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">fp</span><span class="p">.</span><span class="nf">alloc</span><span class="p">()</span> <span class="c1">// Create temporary files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// If creating a temporary file fails, pass the exception to the errc channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">fp</span><span class="p">.</span><span class="nx">errc</span> <span class="o">&lt;-</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span> <span class="c1">// Pass the temporary file handle created above to filec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">fp</span><span class="p">.</span><span class="nx">filec</span> <span class="o">&lt;-</span> <span class="nx">f</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">fp</span><span class="p">.</span><span class="nx">donec</span><span class="p">:</span> <span class="c1">//When the filePipeline.Close() method is called, the channel is closed and the last created temporary file is deleted.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">os</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">            <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="appending-records">Appending Records</h4>
<p>WAL implements methods to append records for different types of Records. Save() method implements bulk writing of Entry logs, which recursively encapsulates the Entry logs to be written as Record instances of type <code>entryType</code>, then serializes them and appends them to the log segment file, and then appends a Record of type <code>stateType</code> to the log file after the bulk writing of the Entry logs. and serialize it to the log file. The <code>stateType</code> record records the current node&rsquo;s term, voting result and index of the submitted log, and is used as the cluster&rsquo;s state information record. The implementation of the <code>WAL.Save()</code> method is as follows (the locking step is omitted).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/wal/wal.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WAL</span><span class="p">)</span> <span class="nf">Save</span><span class="p">(</span><span class="nx">st</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">HardState</span><span class="p">,</span> <span class="nx">ents</span> <span class="p">[]</span><span class="nx">raftpb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ents</span> <span class="p">{</span> <span class="c1">// Batch Write Entry Logs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">saveEntry</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ents</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">saveState</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// Write an entry and then write a stateType Record
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">curOff</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nf">tail</span><span class="p">().</span><span class="nf">Seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">io</span><span class="p">.</span><span class="nx">SeekCurrent</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">curOff</span> <span class="p">&lt;</span> <span class="nx">SegmentSizeBytes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">mustSync</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nf">sync</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">w</span><span class="p">.</span><span class="nf">cut</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WAL</span><span class="p">)</span> <span class="nf">saveEntry</span><span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">raftpb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WAL</span><span class="p">)</span> <span class="nf">saveState</span><span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">raftpb</span><span class="p">.</span><span class="nx">HardState</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WAL</span><span class="p">)</span> <span class="nf">SaveSnapshot</span><span class="p">(</span><span class="nx">e</span> <span class="nx">walpb</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">WAL</span><span class="p">)</span> <span class="nf">saveCrc</span><span class="p">(</span><span class="nx">prevCrc</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As you can see from the above code snippet, etcd may store multiple Entry logs at a time. The <code>sync()</code> system call is called at the end to flush these Record records to disk synchronously.</p>
<p>The Record needs to be serialized before it can be written to the persistence file, which is done with the <code>encoder.encode()</code> method. The <code>encode()</code> method aligns the data by 8 bytes and records the number of bytes occupied by the Record in a uint64 field: the first bit of the field is used to mark whether it contains padding (1 if it does), the next seven bits are used to indicate the size of the padding, and the high 56 bits are used to indicate the actual size of the Record.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/wal/encoder.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">encoder</span><span class="p">)</span> <span class="nf">encode</span><span class="p">(</span><span class="nx">rec</span> <span class="o">*</span><span class="nx">walpb</span><span class="p">.</span><span class="nx">Record</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">e</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">e</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">e</span><span class="p">.</span><span class="nx">crc</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">rec</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">rec</span><span class="p">.</span><span class="nx">Crc</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">crc</span><span class="p">.</span><span class="nf">Sum32</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span>
</span></span><span class="line"><span class="cl">        <span class="nx">err</span>  <span class="kt">error</span>
</span></span><span class="line"><span class="cl">        <span class="nx">n</span>    <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">rec</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// If the pre-allocated buf is exceeded, use dynamic allocation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">data</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rec</span><span class="p">.</span><span class="nf">Marshal</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                     <span class="c1">// Using the pre-allocated buf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rec</span><span class="p">.</span><span class="nf">MarshalTo</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">buf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">data</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">lenField</span><span class="p">,</span> <span class="nx">padBytes</span> <span class="o">:=</span> <span class="nf">encodeFrameSize</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span> <span class="c1">// Calculate data fill length
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Write the length of the Record after encoding
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">writeUint64</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">bw</span><span class="p">,</span> <span class="nx">lenField</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">uint64buf</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">padBytes</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>           <span class="c1">// Write to fill data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">padBytes</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">bw</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">walWriteBytes</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>encode()</code> method writes data to a Writer with a buffer, and every time an OS page (4KB) size buffer is filled, a Flush operation is automatically triggered to flush the data to disk. The above code snippet allows us to infer the format of the WAL file.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/faae8069d2234f95887cd53b5557a830.png" alt="Format of WAL files"></p>
<h3 id="snapshots">Snapshots</h3>
<p>WAL is an Append Only log file that keeps adding new logs at the end of the file. This can avoid the performance loss caused by a large number of random I/Os, but as the program runs, the node needs to handle a large number of requests from clients and other nodes in the cluster, and the corresponding amount of WAL logs will keep increasing, which takes up a lot of disk space. When a node goes down, if it wants to restore its state, it needs to read all the WAL log files from scratch, which is obviously very time-consuming.</p>
<p>To solve this problem, etcd periodically creates snapshots, serializes the entire node state, and then writes it to a stable snapshot file, so that all log records before the snapshot file can be discarded. When restoring the state of a node, the snapshot file is loaded first, and the snapshot data is used to restore the node to the corresponding state, and then the data after the snapshot is read from the WAL file to restore the node to the correct state.</p>
<p>There are two types of etcd snapshots, one is a data snapshot used to store all the data in etcd at a given time, and the other is an RPC snapshot used for slower nodes in the cluster to catch up on data.</p>
<h4 id="data-snapshot">Data Snapshot</h4>
<p>When Raft module applies logs to the state machine, it will trigger the save data snapshot function. This function will first determine the difference between the index of the applied log and the index value of the last log saved in the last snapshot, and will save the snapshot only if the difference exceeds the set <code>SnapshotCount</code>, which defaults to 100,000.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/etcdserver/server.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">const</span> <span class="nx">DefaultSnapshotCount</span> <span class="p">=</span> <span class="mi">100000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">EtcdServer</span><span class="p">)</span> <span class="nf">triggerSnapshot</span><span class="p">(</span><span class="nx">ep</span> <span class="o">*</span><span class="nx">etcdProgress</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">ep</span><span class="p">.</span><span class="nx">appliedi</span><span class="o">-</span><span class="nx">ep</span><span class="p">.</span><span class="nx">snapi</span> <span class="o">&lt;=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Cfg</span><span class="p">.</span><span class="nx">SnapshotCount</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s</span><span class="p">.</span><span class="nf">snapshot</span><span class="p">(</span><span class="nx">ep</span><span class="p">.</span><span class="nx">appliedi</span><span class="p">,</span> <span class="nx">ep</span><span class="p">.</span><span class="nx">confState</span><span class="p">)</span> <span class="c1">// Save Snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ep</span><span class="p">.</span><span class="nx">snapi</span> <span class="p">=</span> <span class="nx">ep</span><span class="p">.</span><span class="nx">appliedi</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>etcdServer creates a background goroutine to store the snapshot data. In etcd V2 version, the in-memory data is serialized to JSON and then persisted to disk, while etcd V3 reads the current version of the state machine data, serializes it to a file, and flushes it to disk synchronously.</p>
<p>After the snapshot is created, a Snapshot Record is written to the pre-written log to save the current state information of the node creating the snapshot. When the node restarts, it reads the contents of the snapshot and reads the subsequent log entries from the WAL file according to the index and term values of the last log, so that the node data can be recovered quickly.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/etcdserver/storage.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">storage</span><span class="p">)</span> <span class="nf">SaveSnap</span><span class="p">(</span><span class="nx">snap</span> <span class="nx">raftpb</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">walsnap</span> <span class="o">:=</span> <span class="nx">walpb</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Index</span><span class="p">:</span> <span class="nx">snap</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nx">Term</span><span class="p">:</span>  <span class="nx">snap</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">err</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Snapshotter</span><span class="p">.</span><span class="nf">SaveSnap</span><span class="p">(</span><span class="nx">snap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// After creating a snapshot, a Snapshot Record is written to the WAL
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nx">st</span><span class="p">.</span><span class="nx">WAL</span><span class="p">.</span><span class="nf">SaveSnapshot</span><span class="p">(</span><span class="nx">walsnap</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="rpc-snapshot">RPC Snapshot</h4>
<p>The Leader maintains a <code>Next</code> value for each Follower, which indicates the index value of the next Entry record to be replicated for that Follower node. In case of network failure or communication delay, there may be nodes in the cluster that are lagging behind in log entries. In order to let the lagging nodes catch up with the cluster as soon as possible, the Leader will pack the logs starting from <code>Next</code> into snapshots and send them to the Follower via <code>MsgSnap</code> messages.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/699cff8835b641e190023032cd19a397.png" alt="RPC Snapshot"></p>
<p>etcd defaults to 5,000 logs behind the Follower catch-up, because the communication delay between cluster nodes is usually in the millisecond range, and etcd V3 has a limit of 10,000 logs per second, so 5,000 logs are enough for the Follower to catch up with the Leader.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/raft.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">maybeSendAppend</span><span class="p">(</span><span class="nx">to</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">sendIfEmpty</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">pr</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nx">Progress</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">m</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">m</span><span class="p">.</span><span class="nx">To</span> <span class="p">=</span> <span class="nx">to</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">term</span><span class="p">,</span> <span class="nx">errt</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">term</span><span class="p">(</span><span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ents</span><span class="p">,</span> <span class="nx">erre</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">entries</span><span class="p">(</span><span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxMsgSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">sendIfEmpty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">errt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">erre</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// send snapshot if we failed to get term or entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">m</span><span class="p">.</span><span class="nx">Type</span> <span class="p">=</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgSnap</span>
</span></span><span class="line"><span class="cl">        <span class="nx">snapshot</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">snapshot</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">m</span><span class="p">.</span><span class="nx">Snapshot</span> <span class="p">=</span> <span class="nx">snapshot</span>
</span></span><span class="line"><span class="cl">        <span class="nx">sindex</span><span class="p">,</span> <span class="nx">sterm</span> <span class="o">:=</span> <span class="nx">snapshot</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">snapshot</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Term</span>
</span></span><span class="line"><span class="cl">        <span class="nx">pr</span><span class="p">.</span><span class="nf">BecomeSnapshot</span><span class="p">(</span><span class="nx">sindex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="err">……</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span> <span class="c1">// send MsgSnap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When Follower receives the <code>MsgSnap</code> message, it will give the received data to the <code>Snapshotter.SaveDBFrom</code> method to save it to the snapshot file.Once Follower receives the snapshot, it can apply the data in the snapshot to the state machine.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/etcdserver/snap/db.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">Snapshotter</span><span class="p">)</span> <span class="nf">SaveDBFrom</span><span class="p">(</span><span class="nx">r</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Reader</span><span class="p">,</span> <span class="nx">id</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="kt">int64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">start</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">TempFile</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">dir</span><span class="p">,</span> <span class="s">&#34;tmp&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">n</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>        <span class="c1">// Writing snapshot data to a temporary file
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fsyncStart</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nx">err</span> <span class="p">=</span> <span class="nx">fileutil</span><span class="p">.</span><span class="nf">Fsync</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>   <span class="c1">// Flush changes from temporary files to disk
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">snapDBFsyncSec</span><span class="p">.</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">fsyncStart</span><span class="p">).</span><span class="nf">Seconds</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>                     <span class="c1">// Close temporary files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">dbFilePath</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>        <span class="c1">// Check if the specified &#34;.snap.db&#34; file exists, and delete it if it exists
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="nx">fileutil</span><span class="p">.</span><span class="nf">Exist</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">os</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">err</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Rename</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nf">Name</span><span class="p">(),</span> <span class="nx">fn</span><span class="p">)</span> <span class="c1">// Rename temporary files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nx">snapDBSaveSec</span><span class="p">.</span><span class="nf">Observe</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">start</span><span class="p">).</span><span class="nf">Seconds</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">n</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Snapshot files are named according to the term value and index value of the last Entry log covered by the snapshot. The file name format of data snapshot is &ldquo;term-index.snap&rdquo;, and the file name format of RPC snapshot is &ldquo;index.snap.db&rdquo;, we can distinguish snapshot files according to the file name format.</p>
<p>This is what etcd does with snapshot files. We can also use snapshots to back up and restore data, or copy snapshot files from a certain point in time to a new node joining the cluster, which saves time in synchronizing logs and reduces the pressure on the Leader.</p>
<h2 id="state-machine-storage">State Machine Storage</h2>
<p>etcd&rsquo;s MVCC module implements the state machine storage feature, using the open source embedded key-value storage database BoltDB as its underlying layer, but this project has been archived by the author and is no longer maintained, so the etcd community maintains a <a href="https://github.com/etcd-io/bbolt">bbolt</a> version of itself. This section analyzes how the MVCC module uses multi-version concurrency control to maintain historical version information of the data.</p>
<h3 id="concurrency-control">Concurrency Control</h3>
<p>Concurrency control is a very challenging topic in the database domain. Common approaches to concurrency control include pessimistic locks, optimistic locks, and multi-version concurrency control. But whether it is pessimistic locking or optimistic locking, they are not really lock concepts, but rather &lsquo;design ideas&rsquo; used to describe lock classes.</p>
<h4 id="pessimistic-locking">Pessimistic locking</h4>
<p>Pessimistic concurrency control (also known as pessimistic locking) refers to a pessimistic and negative attitude towards data competition. By default, conflicts are bound to arise when data is accessed by the outside world, so various locks are added to the data throughout the data processing to achieve concurrency control and ensure that only one thread can access the data at the same time. If a lock is applied to a row of data during the execution of a transaction, only after this transaction releases the lock can other transactions perform operations that conflict with the lock. Since the locking mechanism is a preventive version control, read operations will block write operations and write operations will block read operations, and concurrency performance is poor when the lock is more granular and longer, and it is mainly used in concurrent environments where data competition is intense and there are more writes and fewer reads.</p>
<h4 id="optimistic-locking">Optimistic locking</h4>
<p>Optimistic concurrency control (also known as optimistic locking), as opposed to pessimistic locking, assumes that multi-user concurrent transactions are processed without affecting each other, so no locks are placed on the data. Before committing the updated data, each transaction checks to see if any other transaction has modified the data since it was read by that transaction. If another transaction has modified the data, the committing transaction will roll back. Optimistic locks are mostly used in environments where there are few data conflicts and the cost of occasionally rolling back a transaction is much lower than the cost of locking the data when it is read, in which case optimistic locks can achieve higher throughput.</p>
<h4 id="mvcc">MVCC</h4>
<p>Multi-Version Concurrency Control (MVCC) is a lock-free transaction mechanism that can be thought of as an implementation of the idea of optimistic concurrency control that works well with pessimistic locking to increase the concurrency of transactions. will pick the most appropriate (either the latest version or the specified version) from a limited number of versions of data and return it directly. In this way, we do not need to be concerned about data conflicts between read and write operations. Therefore, how to manage and efficiently pick versions of data becomes a major problem for MVCC to solve.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/cfa89a8fea6d4fea8d4c54fa25b1bef0.png" alt="Multi-Version Concurrency Control "></p>
<p>Since etcd is mainly used to store some very important metadata in distributed systems, the read operations of such metadata are much more than the write operations. Under the pessimistic locking mechanism, when a lock is occupied by a write operation, a large number of read operations will be blocked, affecting the concurrency performance, while MVCC can maintain a relatively high and stable read concurrency capability. Whenever a client wants to change or delete a data object, etcd does not modify or delete the existing data object itself in place, but creates a new version of the data object, so that the old version of the data can still be read concurrently while the write operation is in progress.</p>
<h3 id="index">Index</h3>
<p>To achieve multi-version concurrency control, etcd stores each version of the key-value pair in BoltDB. The Key stored by etcd in BoltDB is the revision <code>reversion</code> and the Value is the combination of key-value pairs sent by the client. To better understand this concept, suppose we write two key-value pairs, (key1, value1) and (key2, value2), through the read-write transaction interface, and then we call the read-write transaction interface to update these two key-value pairs, which are (key1, update1) and (key2, update2) after the update, although the two write operations update are two key-value pairs, in fact, four records are written in BoltDB.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">rev={1 0}, key=key1, value=&#34;valuel&#34; 
</span></span><span class="line"><span class="cl">rev={1 1}, key=key2, value=&#34;value2&#34; 
</span></span><span class="line"><span class="cl">rev={2 0}, key=key1, value=&#34;updatel&#34;
</span></span><span class="line"><span class="cl">rev={2 1}, key=key2, value=&#34;update2&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>The first part is the main reversion, which increments by one for each transaction, and the second part is the sub reversion, which increments by one for each operation of the same transaction, both of which are combined to ensure that the key is unique and incremental. In the above example, the main reversion of the first transaction is 1, and the main reversion of the second transaction is 2.</p>
<p>As we can see from the format of the data stored in Backend, if you want to query a key-value pair from BoltDB, you have to look it up by reversion. However, the client only knows the Key value of the specific key-value pair, but not the reversion information of each key-value pair.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/52de56b84d0f41888a10e8627e8e370e.png" alt="B-Tree"></p>
<p>To associate the original key-value pair information provided by the client with the reversion, etcd uses the <a href="https://github.com/google/btree">btree</a> data structure implemented by Google Open Source to maintain the mapping between the Key and the reversion. The value part of BTree stores the original Key and the value part stores a keyIndex instance. A keyIndex instance maintains all the historical revision information of a Key.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/backend/backend.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">keyIndex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span>        <span class="c1">// The original Key value provided by the client
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">modified</span> <span class="nx">revision</span> <span class="c1">// The revision information corresponding to the last modification of this Key value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">generations</span> <span class="p">[]</span><span class="nx">generation</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">revision</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">main</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sub</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The keyIndex uses generation <code>generation</code> to represent the data changes of the same Key during a certain lifetime, and multiple revisions can be stored in each generation. The first time a Key value given by a client is created, the corresponding generation 0 lifecycle <code>generation[0]</code> is also created, and revision information is continuously added to <code>generation[0]</code> as the client keeps modifying the Key.</p>
<p>When a tombstone <code>Tombstone</code> is added to <code>generation[0]</code>, it means that the life cycle of generation 0 is over. keyIndex creates a new instance of generation and adds revision information to <code>generation[1]</code> when the key is subsequently modified. The structure of a keyIndex is shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/02563a0ddd144da28150fff306a09573.png" alt="Keyindex format"></p>
<p>Since etcd stores the history of keyspace versions, the revision information recorded in the keyIndex will keep increasing as the client keeps modifying the key-value pairs, we can call the <code>compact()</code> method to compress the keyIndex to avoid performance degradation and storage space exhaustion.</p>
<p>When compressing the keyIndex, all revision instances with a value less than the specified value in the main part are deleted, and the compressed revision is not accessible. If there is an empty generation instance in the compression process, it will be deleted. And each Key corresponds to at least one generation instance, if all the generation instances in the keyIndex are cleared, then the keyIndex instance will be deleted as well.</p>
<p>Take the data maintained in the above image as an example to show the compression process.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">compact(2)
</span></span><span class="line"><span class="cl">generations:
</span></span><span class="line"><span class="cl">    {6.0, 7.0}
</span></span><span class="line"><span class="cl">    {4.0, 5.0(t)}
</span></span><span class="line"><span class="cl">    {2.0, 3.0(t)}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">compact(4)
</span></span><span class="line"><span class="cl">generations:
</span></span><span class="line"><span class="cl">    {6.0, 7.0}
</span></span><span class="line"><span class="cl">    {4.0, 5.0(t)}
</span></span></code></pre></td></tr></table>
</div>
</div><p>The keyIndex structure provides two methods for querying revisions. The <code>since()</code> method is used to find the revision with the main part greater than the specified value in bulk, and if the query results in multiple revision instances with the same main part, only the largest revision in the sub part is returned; the <code>get()</code> method is used to find the largest revision with the main part less than the specified value.</p>
<p>The <code>get()</code> method will first call <code>findGeneration()</code> to find the generation instance of the specified main revision, the <code>findGeneration()</code> method will start from the last generation instance of the keyIndex, and when it finds the specified generation, it will call the <code>walk()</code> method to find the eligible revision from the <code>generation</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/key_index.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ki</span> <span class="o">*</span><span class="nx">keyIndex</span><span class="p">)</span> <span class="nf">get</span><span class="p">(</span><span class="nx">lg</span> <span class="o">*</span><span class="nx">zap</span><span class="p">.</span><span class="nx">Logger</span><span class="p">,</span> <span class="nx">atRev</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">modified</span><span class="p">,</span> <span class="nx">created</span> <span class="nx">revision</span><span class="p">,</span> <span class="nx">ver</span> <span class="kt">int64</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">g</span> <span class="o">:=</span> <span class="nx">ki</span><span class="p">.</span><span class="nf">findGeneration</span><span class="p">(</span><span class="nx">atRev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">g</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">revision</span><span class="p">{},</span> <span class="nx">revision</span><span class="p">{},</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ErrRevisionNotFound</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nf">walk</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">rev</span> <span class="nx">revision</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">rev</span><span class="p">.</span><span class="nx">main</span> <span class="p">&gt;</span> <span class="nx">atRev</span> <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">n</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">g</span><span class="p">.</span><span class="nx">revs</span><span class="p">[</span><span class="nx">n</span><span class="p">],</span> <span class="nx">g</span><span class="p">.</span><span class="nx">created</span><span class="p">,</span> <span class="nx">g</span><span class="p">.</span><span class="nx">ver</span> <span class="o">-</span> <span class="nb">int64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">g</span><span class="p">.</span><span class="nx">revs</span><span class="p">)</span><span class="o">-</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">revision</span><span class="p">{},</span> <span class="nx">revision</span><span class="p">{},</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">ErrRevisionNotFound</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above is how etcd queries multiple versions of data through indexes: when a client looks for a given key-value pair, it will first find the corresponding keyIndex instance through the B-tree index maintained in memory, then find the corresponding revision information through the keyIndex, and finally find the real key-value pair data from BoltDB through the revision.</p>
<p>After understanding the above concepts, let&rsquo;s finally see how the storage module uses BoltDB to store data.</p>
<h3 id="backend">Backend</h3>
<p>etcd uses Backend, a design that encapsulates the implementation details of the storage engine and provides a consistent interface to the upper layers. the implementation of Backend mainly uses the API provided by BoltDB to add, delete, and check data, so in the following we focus on the implementation of the interface and do not post the code related to the operational details.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/backend/backend.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Backend</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ReadTx</span><span class="p">()</span> <span class="nx">ReadTx</span>           <span class="c1">// read-only transaction, which has been replaced by ConcurrentReadTx().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">BatchTx</span><span class="p">()</span> <span class="nx">BatchTx</span>         <span class="c1">// Read and write transactions (batch transactions)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ConcurrentReadTx</span><span class="p">()</span> <span class="nx">ReadTx</span> <span class="c1">// Non-blocking read-only transaction that replaces ReadTx(), see PR#10523 for details
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Snapshot</span><span class="p">()</span> <span class="nx">Snapshot</span>       <span class="c1">// Create Snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Hash</span><span class="p">(</span><span class="nx">ignores</span> <span class="kd">map</span><span class="p">[</span><span class="nx">IgnoreKey</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span> <span class="p">(</span><span class="kt">uint32</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Size</span><span class="p">()</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SizeInUse</span><span class="p">()</span> <span class="kt">int64</span>
</span></span><span class="line"><span class="cl">    <span class="nf">OpenReadTxN</span><span class="p">()</span> <span class="kt">int64</span>       <span class="c1">// Returns the number of read-only transactions currently in progress
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Defrag</span><span class="p">()</span> <span class="kt">error</span>            <span class="c1">// Defragmentation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">ForceCommit</span><span class="p">()</span>             <span class="c1">// Submitting bulk read and write transactions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Two important concepts of Backend are <code>ReadTx</code> and <code>BatchTx</code>, which implement the interfaces for read-only and read-write transactions, respectively, where <code>BatchTx</code> has <code>ReadTx</code> embedded in it and &lsquo;inherits&rsquo; the methods implemented by read-only transactions.</p>
<blockquote>
<p>The semantics of &lsquo;inheritance&rsquo; can be implemented in the Go language with embedded structs.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/backend/read_tx.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">ReadTx</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Lock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nf">UnsafeRange</span><span class="p">(</span><span class="nx">bucketName</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">endKey</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">limit</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">(</span><span class="nx">keys</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">vals</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">UnsafeForEach</span><span class="p">(</span><span class="nx">bucketName</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">visitor</span> <span class="kd">func</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/backend/batch_tx.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">BatchTx</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ReadTx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">UnsafeCreateBucket</span><span class="p">(</span><span class="nx">name</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">UnsafePut</span><span class="p">(</span><span class="nx">bucketName</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">UnsafeSeqPut</span><span class="p">(</span><span class="nx">bucketName</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">value</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">UnsafeDelete</span><span class="p">(</span><span class="nx">bucketName</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Commit</span><span class="p">()</span>        <span class="c1">// Commit the current read/write transaction and immediately open a new read/write transaction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">CommitAndStop</span><span class="p">()</span> <span class="c1">// Commits the current read/write transaction, but does not open a new read/write transaction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>BatchTx</code> provides two methods for updating data, <code>UnsafeSeqPut()</code> differs from <code>UnsafePut()</code> in that the <code>UnsafeSeqPut()</code> method adds a key-value pair to the specified Bucket with the corresponding Bucket instance set to 90% padding, which improves the utilization of the Bucket when writing sequentially.</p>
<p>To improve the efficiency of BoltDB writes, Backend enables a goroutine to commit all read and write transactions asynchronously (default is 100ms), which reduces the number of random writes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/backend/backend.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">defaultBatchInterval</span> <span class="p">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">backend</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">donec</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">batchInterval</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">t</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">b</span><span class="p">.</span><span class="nx">stopc</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span><span class="p">.</span><span class="nx">batchTx</span><span class="p">.</span><span class="nf">CommitAndStop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">batchTx</span><span class="p">.</span><span class="nf">safePending</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">b</span><span class="p">.</span><span class="nx">batchTx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nx">t</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">batchInterval</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="read-only-transactions">Read-Only Transactions</h4>
<p>Although after using MVCC, read requests are not locked by write requests, which greatly improves the efficiency of read operations. However, since deadlock will occur if you open two read-only and read-write transactions that depend on each other in the same goroutine of BoltDB, <code>readTx</code> introduces a read-write lock <code>sync.RWLock</code> to avoid this situation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/backend/read_tx.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">readTx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">mu</span>  <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">buf</span> <span class="nx">txReadBuffer</span>
</span></span><span class="line"><span class="cl">    <span class="nx">txMu</span>    <span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tx</span>      <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span>
</span></span><span class="line"><span class="cl">    <span class="nx">buckets</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Bucket</span>
</span></span><span class="line"><span class="cl">    <span class="nx">txWg</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>As you can see from the structure, <code>readTx</code> not only references a read-write lock <code>txmu</code> used to protect the read-only transaction <code>tx</code>, but also a read-write lock <code>mu</code> that protects <code>buf</code>, which serves to ensure that no problems occur when reading or writing data in the buffer.</p>
<p>Read-only transactions provide two methods for fetching data to the upper level. <code>UnsafeRange()</code> is used to fetch the Key or a single Key of the specified range. This method will first look up the data from the cache, and if the data in the cache does not meet the requirements, it will be queried from BoltDB via the <code>unsafeRange()</code> function. The <code>UnsafeForEach()</code> method will iterate through the cache of the specified Bucket and all the key-value pairs in the Bucket, and process these iterated key-value pairs with the passed in callback function.</p>
<h4 id="read-write-transactions">Read-Write Transactions</h4>
<p>The implementation of read-write transactions is similar to read-only transactions, but read-write transactions provide both <code>batchTx</code> without caching and <code>batchTxBuffered</code> with caching, the latter with an embedded structure of the former and an additional cache <code>txWriteBuffer</code> to speed up the read operations in read-write transactions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/backend/batch_tx.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">batchTx</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tx</span>      <span class="o">*</span><span class="nx">bolt</span><span class="p">.</span><span class="nx">Tx</span>
</span></span><span class="line"><span class="cl">    <span class="nx">backend</span> <span class="o">*</span><span class="nx">backend</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">pending</span> <span class="kt">int</span> <span class="c1">// The number of modifications performed in the current transaction, which will be reset to 0 when the read/write transaction is committed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">batchTxBuffered</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">batchTx</span>
</span></span><span class="line"><span class="cl">    <span class="nx">buf</span> <span class="nx">txWriteBuffer</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The implementation of <code>batchTx</code> write delete operation is also very simple, it just calls the API provided by BoltDB to modify the data in the Bucket, so we will not repeat this aspect.</p>
<p>As BoltDB executes read/write transactions for a long time, it will cause other read/write transactions to hang and wait, so Backend specifies the maximum number of operations in a read/write transaction, and when the threshold is exceeded, the current read/write transaction will be committed automatically.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/mvcc/backend/batch_tx.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">var</span> <span class="nx">defaultBatchLimit</span> <span class="p">=</span> <span class="mi">10000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">batchTx</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">pending</span> <span class="o">&gt;=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">backend</span><span class="p">.</span><span class="nx">batchLimit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">t</span><span class="p">.</span><span class="nf">commit</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">t</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Although MVCC has solved the problem of data conflicts in concurrent transactions very well, deadlocks and concurrent write conflicts can still occur during operation of BoltDB. etcd combines locking mechanisms to solve this problem: read-write locks are used in read-only transactions and mutually exclusive locks are used in read-write transactions. The good thing is that the probability of lock contention is low and does not block other transactions for a long time.</p>
<h2 id="linear-consistency-read">Linear Consistency Read</h2>
<p>A distributed system that correctly implements the consensus algorithm does not mean that linear consistency is achieved; the consensus algorithm can only guarantee that the state of multiple nodes is consistent for a given object. In the etcd implementation, a successful write operation simply means that the data has been dropped through the pre-written log, but the behavior of the <strong>state machine Apply log is asynchronous</strong>, and multiple nodes cannot guarantee that a log will be applied to the state machine at the same time, meaning that each node cannot be consistent in &lsquo;real time&rsquo;, so reading the state machine at this point is likely to read out-of-date data.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/449aab9873744c8e804ca0d7977e99b8.png" alt="async log"></p>
<p>In addition, the Leader&rsquo;s state machine may not be up-to-date due to possible network partitioning, Leader node switching, and so on. If the Leader does not notice that its status has changed when processing requests, this can lead to a violation of linear consistency throughout the system.</p>
<h3 id="data-consistency">Data Consistency</h3>
<p>Data consistency is a concept that originally existed in database systems. The consistency problem in database systems refers to whether the logic between associated data is complete and correct, and usually database systems will use transactions to ensure the consistency and integrity of data. However, data consistency in distributed systems refers to the problem of how to guarantee the consistency of data when data is stored in multiple copies.</p>
<p>In the distributed field, the security of data is no longer guaranteed by hardware only, in order to achieve system disaster recovery and improve the overall performance, data will be written to multiple copies at the same time, and data synchronization between master copies is performed through replication technology to ensure the security of data. When the database writes records to multiple replicas at the same time, how to ensure the data consistency between multiple replicas is called data consistency.</p>
<p>Consistency models in distributed systems can be roughly divided into three categories.</p>
<ul>
<li><strong>Linear consistency</strong>: when an update operation is executed successfully on a certain replica, all subsequent read operations should be able to obtain the latest data.</li>
<li><strong>Sequential consistency</strong>: when an update operation is executed successfully on a certain replica, the read operations of other processes may not be able to obtain the latest data, but the order of the different values of that data read by each process is consistent.</li>
<li><strong>Final Consistency</strong>: When updating a certain data, it takes a delay for the user to read the latest data.</li>
</ul>
<p>Linear consistency, also known as strong consistency and strict consistency, is the highest consistency model that a program can achieve. Linear consistency requires that any read operation read the most recent write of some data, and that all processes in the system see the order of operations in the same order <strong>as they would under the global clock</strong> . Once a value is changed, then no matter how small the time interval between subsequent read operations and this write operation, and no matter which node performs the read operation, the value read afterwards is the newly changed value; similarly, if a read operation is performed, then no matter how fast the subsequent write operation is, the value read by that read operation is still the original value.</p>
<p>Because the global clock required for linear consistency results in a large performance loss, sequential consistency drops the global clock constraint and is implemented with <strong>distributed logical clocks</strong> instead. All processes in the sequential consistency model see all modifications in the same order. The read operation may not get the previous write updates to the same data from other processes in time, but the order in which each node reads the different values of that data is the same.</p>
<p>Final consistency is also weak consistency, which does not guarantee that the same data on different nodes are the same at the same moment, but the same data on different nodes always change in the direction of convergence as time migrates. There are many kinds of eventual consistency, like causal consistency and monotonic read consistency are its variants.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/08/18/2e27469e7ccc4a238ae1ad0dbc1485ff.png" alt="Data consistency model"></p>
<p>Raft is a strongly consistent consensus algorithm in the distributed domain, whose goal is to achieve linearized semantics. When one of the nodes receives a set of instructions from a client, it must communicate with the other nodes to ensure that all nodes receive the same instructions in the same order, and eventually all nodes will produce consistent results, just like a machine. etcd implements linear consistency using the underlying scheme provided by Raft, and this aspect is described in detail below.</p>
<h3 id="readindex">ReadIndex</h3>
<p>etcd uses the ReadIndex mechanism to solve the above problem: although the state machine applies the logs asynchronously, the logs that have been submitted satisfy linear consistency, so the read requests can also satisfy linear consistency as long as they wait until they are all applied to the state machine before executing queries.</p>
<p>The execution flow of the ReadIndex mechanism is as follows.</p>
<ol>
<li>record the <code>CommittedIndex</code> of the <code>At this time</code> cluster before the read operation is executed, as <code>ReadIndex</code>.</li>
<li>send a heartbeat message to Follower, and if more than a quorum of nodes respond to the heartbeat message, then the authority of the Leader node is guaranteed.</li>
<li>wait for the state machine to be applied to <code>ReadIndex</code> &lsquo;at least&rsquo;, i.e. <code>AppliedIndex</code> &gt;= <code>ReadIndex</code>.</li>
<li>execute the read request and return the result to the Client.</li>
</ol>
<h3 id="read-only-request-handling">Read-only request handling</h3>
<p>Read-only requests for etcd are handled by the <code>EtcdServer.Range()</code> method. Each request needs to determine the consistency level of the client configuration, and if linear consistency is required then the function <code>linearizableReadNotify</code> will be executed and will keep blocking in this function until the linear consistency read condition is met.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/etcdserver/v3_server.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">EtcdServer</span><span class="p">)</span> <span class="nf">Range</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">RangeRequest</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">RangeResponse</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">Serializable</span> <span class="p">{</span> <span class="c1">// Execute linearizableReadNotify() and wait for the notification
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">err</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">linearizableReadNotify</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">trace</span><span class="p">.</span><span class="nf">Step</span><span class="p">(</span><span class="s">&#34;agreement among raft nodes before linearized reading&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">chk</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">ai</span> <span class="o">*</span><span class="nx">auth</span><span class="p">.</span><span class="nx">AuthInfo</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">s</span><span class="p">.</span><span class="nx">authStore</span><span class="p">.</span><span class="nf">IsRangePermitted</span><span class="p">(</span><span class="nx">ai</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Key</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">RangeEnd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// At this point AppliedIndex &gt;= ReadIndex, you can read the data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">get</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">applyV3Base</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">serr</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">doSerialize</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">chk</span><span class="p">,</span> <span class="nx">get</span><span class="p">);</span> <span class="nx">serr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">err</span> <span class="p">=</span> <span class="nx">serr</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">resp</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>linearizableReadNotify</code> function sends an empty structure to the channel <code>readwaitc</code> and notifies the send message function that it is safe to execute the read request after the listener function has finished its task.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/etcdserver/v3_server.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">EtcdServer</span><span class="p">)</span> <span class="nf">linearizableReadNotify</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s</span><span class="p">.</span><span class="nx">readMu</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">nc</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">readNotifier</span>
</span></span><span class="line"><span class="cl">    <span class="nx">s</span><span class="p">.</span><span class="nx">readMu</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">s</span><span class="p">.</span><span class="nx">readwaitc</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}:</span> <span class="c1">// Wait for the read request processing concurrently to be available to process this read request
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">nc</span><span class="p">.</span><span class="nx">c</span><span class="p">:</span> <span class="c1">// Receive a signal that it is safe to execute a read request (when AppliedIndex &gt;= ReadIndex)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="nx">nc</span><span class="p">.</span><span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>readwaitc</code> listening is done in a separate concurrent <code>linearizableReadLoop</code> that loops through the <code>readwaitc</code> signals, calls the Raft module to execute the <code>readIndex()</code> mechanism when a new request arrives, and then waits for the <code>ReadIndex</code> to be applied to the state machine.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/etcdserver/v3_server.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">EtcdServer</span><span class="p">)</span> <span class="nf">linearizableReadLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">readwaitc</span><span class="p">:</span> <span class="c1">// A signal is received from readwaitc when a new read request arrives
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Call the raft module to execute readIndex()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">cctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Cfg</span><span class="p">.</span><span class="nf">ReqTimeout</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">ReadIndex</span><span class="p">(</span><span class="nx">cctx</span><span class="p">,</span> <span class="nx">ctxToSend</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="nf">cancel</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="raft-consensus">Raft Consensus</h3>
<p>The Raft protocol library performs different processing flows for different identities of nodes. Depending on the identity of the node, the <code>raft.step</code> method will point to a different processing function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/node.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">ReadIndex</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">rctx</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgReadIndex</span><span class="p">,</span> <span class="nx">Entries</span><span class="p">:</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">{{</span><span class="nx">Data</span><span class="p">:</span> <span class="nx">rctx</span><span class="p">}}})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If a Follower node receives a read request from a client, the Follower node forwards the read request to the Leader for processing.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/Raft/raft.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">stepFollower</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgReadIndex</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="nx">m</span><span class="p">.</span><span class="nx">To</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lead</span> <span class="c1">// Change the destination address of the message to Leader, and forward the read request to Leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the Leader receives a read request, the Leader first saves the request in the ReadOnly queue and sends a heartbeat message to the other nodes. When the Leader receives a heartbeat message from more than half of the nodes, it indicates that the ReadIndex has passed the cluster consensus and will call the <code>readOnly.advance()</code> method to add the read state to the readStates queue. At the same time, readStates are continuously encapsulated into <code>Ready</code> structures in the <code>node.run()</code> method for processing by the application layer.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/raft/raft.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">stepLeader</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgReadIndex</span><span class="p">:</span>  <span class="c1">// Handling ReadIndex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">switch</span> <span class="nx">r</span><span class="p">.</span><span class="nx">readOnly</span><span class="p">.</span><span class="nx">option</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">ReadOnlySafe</span><span class="p">:</span> <span class="c1">// ReadOnlySafe executes the logic of the ReadIndex algorithm
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">r</span><span class="p">.</span><span class="nx">readOnly</span><span class="p">.</span><span class="nf">addRequest</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="c1">// Adding requests to the queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// The local node automatically acks the request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">r</span><span class="p">.</span><span class="nx">readOnly</span><span class="p">.</span><span class="nf">recvAck</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Data</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">r</span><span class="p">.</span><span class="nf">bcastHeartbeatWithCtx</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Data</span><span class="p">)</span> <span class="c1">// Leader nodes initiate broadcasts to other nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nx">ReadOnlyLeaseBased</span><span class="p">:</span> <span class="c1">// Another mechanism to achieve linear consistency
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgHeartbeatResp</span><span class="p">:</span> <span class="c1">// Heartbeat Message Response
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Clear the map and queue of readOnly and add the read state to the readStates queue at this time
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// The run method wraps readStates into a Ready data structure for the application layer to process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">rss</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">readOnly</span><span class="p">.</span><span class="nf">advance</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">rs</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rss</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">req</span> <span class="o">:=</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">req</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="nx">req</span><span class="p">.</span><span class="nx">From</span> <span class="o">==</span> <span class="nx">None</span> <span class="o">||</span> <span class="nx">req</span><span class="p">.</span><span class="nx">From</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span> <span class="p">{</span> <span class="c1">// from local member
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">r</span><span class="p">.</span><span class="nx">readStates</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">readStates</span><span class="p">,</span> <span class="nx">ReadState</span><span class="p">{</span><span class="nx">Index</span><span class="p">:</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="nx">RequestCtx</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Entries</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Data</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">To</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgReadIndexResp</span><span class="p">,</span> <span class="nx">Index</span><span class="p">:</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="nx">Entries</span><span class="p">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">Entries</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// etcd/raft/node.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">node</span><span class="p">)</span> <span class="nf">run</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">advancec</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">readyc</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">rn</span><span class="p">.</span><span class="nf">HasReady</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">rd</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">rn</span><span class="p">.</span><span class="nf">readyWithoutAccept</span><span class="p">()</span> <span class="c1">// Create a new Ready structure
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">readyc</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">readyc</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nx">readyc</span> <span class="o">&lt;-</span> <span class="nx">rd</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Write the created Ready to the node.readyc channel and wait for the application layer to read it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="nx">n</span><span class="p">.</span><span class="nx">rn</span><span class="p">.</span><span class="nf">acceptReady</span><span class="p">(</span><span class="nx">rd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="nx">advancec</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">advancec</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="application-layer-processing">Application layer processing</h3>
<p>The <code>raftNode.start</code> method of the previous article will get the <code>Ready</code> structure wrapped in the Raft module and send only the last readState at a time to the concurrent <code>linearizableReadLoop</code> via the channel <code>readStateC</code>, because the This is because the last read-only request encapsulated in Ready already satisfies the ReadIndex requirement, and then all the previous ones do. Next, wait for the application to be applied to the state machine asynchronously before executing the read request.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// etcd/etcdserver/raft.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raftNode</span><span class="p">)</span> <span class="nf">start</span><span class="p">(</span><span class="nx">rh</span> <span class="o">*</span><span class="nx">raftReadyHandler</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nx">rd</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">r</span><span class="p">.</span><span class="nf">Ready</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Handle read requests that have completed readIndex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">ReadStates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Send only the last readState at a time to r.readStateC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">case</span> <span class="nx">r</span><span class="p">.</span><span class="nx">readStateC</span> <span class="o">&lt;-</span> <span class="nx">rd</span><span class="p">.</span><span class="nx">ReadStates</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">ReadStates</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// etcd/etcdserver/v3_server.go(Code redacted)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">EtcdServer</span><span class="p">)</span> <span class="nf">linearizableReadLoop</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="nx">timeout</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">            <span class="nx">done</span>    <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">        <span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">!</span><span class="nx">timeout</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">done</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="nx">rs</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nx">readStateC</span><span class="p">:</span> <span class="c1">// readIndex() request completion
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">done</span> <span class="p">=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">RequestCtx</span><span class="p">,</span> <span class="nx">ctxToSend</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// ……
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// readIndex() request completes, wait for AppliedIndex &gt;= ReadIndex
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="nx">ai</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">getAppliedIndex</span><span class="p">();</span> <span class="nx">ai</span> <span class="p">&lt;</span> <span class="nx">rs</span><span class="p">.</span><span class="nx">Index</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">applyWait</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="nx">rs</span><span class="p">.</span><span class="nx">Index</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">stopping</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// unblock all l-reads requested at indices before rs.Index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Sending signals that can read the state machine
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">nr</span><span class="p">.</span><span class="nf">notify</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="summary-of-this-section">Summary of this section</h3>
<p>By analyzing a complete read operation, it can be seen that etcd needs to satisfy the following two conditions in order to reach a linear consistent read.</p>
<ul>
<li><strong>Have the Leader handle read-only requests</strong>: If the Follower receives a read request, it needs to forward the request to the Leader for processing.</li>
<li><strong>Ensure the validity of the Leader</strong>: The Leader needs to send a broadcast to the cluster, and if it can receive a response from most nodes, it means that the identity of the Leader node is valid, and this process is to ensure that the data of the Leader node are all up-to-date.</li>
</ul>
<p>Since the ReadIndex mechanism needs to wait for cluster consensus and state machine application logs, especially the consensus process will bring some network overhead, in order to improve the overall performance of read-only requests, etcd also provides an optimized consistency algorithm called LeaseRead: the Leader will take a smaller lease period than ElectionTimeout. Because no election occurs during the lease period, it ensures that the identity of the Leader does not change, so the consensus step in ReadIndex can be skipped, reducing the latency caused by network overhead.</p>
<p>The correctness of LeaseRead is tied to the time implementation, and it is possible to read expired data due to the error of CPU clocks of different hosts.</p>
<blockquote>
<p>Implementing linear consistency for read requests in etcd must go through the Raft consistency protocol, and this approach must come at some performance and latency cost. If there is no particularly strong requirement for data consistency, the consistency mode can be configured to be Serializable on the client side. read-only requests in Serializable mode can be provided by any etcd member, but etcd may read out-of-date data as a result.</p>
</blockquote>
<h2 id="summary">Summary</h2>
<p>The above is the implementation and rationale for the most important parts of etcd. As you can see, etcd&rsquo;s consensus module handles many of the boundary conditions, adding to the high availability status of the cluster. Although some performance compromises are made in order to achieve strong consistency, etcd also provides additional options that can be freely configured for different demand scenarios. etcd also provides a very good implementation of the Raft algorithm, and analysis of the source code is very helpful for a deeper understanding of Raft.</p>
<p>etcd uses the CSP concurrency model provided by Go in much of its source code. This way of communicating using <code>channel</code> is not intuitive to write, and the context of the code does not reflect the sender or receiver of the message, so extra care should be taken when reading the source code. However, in general the code of the etcd core module does not change much and is suitable for reading and learning.</p>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://wingsxdu.com/post/database/etcd/">https://wingsxdu.com/post/database/etcd/</a></li>
<li><a href="https://book.douban.com/subject/30275551/">The Inside Story of etcd Technology</a></li>
<li><a href="https://coolshell.cn/articles/6790.html">Multi-Version Concurrency Control (MVCC) in Distributed Systems</a></li>
<li><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14">In Search of an Understandable Consensus Algorithm</a></li>
<li><a href="https://www.wingsxdu.com/post/algorithms/raft/#gsc.tab=0">Distributed Consistency Protocol Raft Principle</a></li>
<li><a href="https://pingcap.com/blog-cn/linearizability-and-raft/">Linear Consistency and Raft</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2022-08/zookeeper-zab/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">ZooKeeper and Zab Protocol</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-08/wireshark-tcp-throughput-bottlenecks/">
            <span class="next-text nav-default">Use Wireshark to analyze TCP throughput bottlenecks.</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
