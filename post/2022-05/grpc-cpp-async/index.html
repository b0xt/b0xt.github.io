<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; Asynchronous Programming in gRPC - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore C&#43;&#43; asynchronous programming in gRPC." /><meta name="keywords" content="grpc, c&#43;&#43;, Asynchronous" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-05/grpc-cpp-async/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C&#43;&#43; Asynchronous Programming in gRPC" />
<meta property="og:description" content="Explore C&#43;&#43; asynchronous programming in gRPC." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-05/grpc-cpp-async/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-01T18:04:33+08:00" />
<meta property="article:modified_time" content="2022-05-01T18:04:33+08:00" />

<meta itemprop="name" content="C&#43;&#43; Asynchronous Programming in gRPC">
<meta itemprop="description" content="Explore C&#43;&#43; asynchronous programming in gRPC."><meta itemprop="datePublished" content="2022-05-01T18:04:33+08:00" />
<meta itemprop="dateModified" content="2022-05-01T18:04:33+08:00" />
<meta itemprop="wordCount" content="2223">
<meta itemprop="keywords" content="grpc,c&#43;&#43;," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; Asynchronous Programming in gRPC"/>
<meta name="twitter:description" content="Explore C&#43;&#43; asynchronous programming in gRPC."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; Asynchronous Programming in gRPC</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-05-01 18:04:33 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2223 words </span>
          <span class="more-meta"> 5 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#overview">Overview</a>
          <ul>
            <li><a href="#compile-and-install">Compile and install</a></li>
          </ul>
        </li>
        <li><a href="#asynchronous-client">Asynchronous Client</a>
          <ul>
            <li><a href="#create">Create</a></li>
            <li><a href="#asynchronous-requests">Asynchronous requests</a></li>
            <li><a href="#asynchronous-processing-of-packet-returns">Asynchronous processing of packet returns</a></li>
          </ul>
        </li>
        <li><a href="#asynchronous-server">Asynchronous Server</a>
          <ul>
            <li><a href="#start-registration">Start registration</a></li>
            <li><a href="#start-the-main-process">Start the main process</a></li>
            <li><a href="#create-calldata--logical-processing--completion">Create CallData &amp; Logical Processing &amp; Completion</a></li>
          </ul>
        </li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="overview">Overview</h2>
<p>Since gRPC&rsquo;s asynchronous call code is rather convoluted, this article is mainly used to document gRPC&rsquo;s asynchronous calls.</p>
<p>Note that gRPC uses the CompletionQueue binding for RPC calls in order to implement asynchronous calls, which can feel strange when writing the actual code. The response, because it is asynchronous, calls <code>CompletionQueue::Next</code> to wait for the packet return operation. Leave an impression here first, it will be clearer when talking about the process below.</p>
<h3 id="compile-and-install">Compile and install</h3>
<p>To complete our demo, you can install gRPC directly using the following command if you don&rsquo;t have it installed.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ <span class="nb">export</span> <span class="nv">MY_INSTALL_DIR</span><span class="o">=</span><span class="nv">$HOME</span>/.local
</span></span><span class="line"><span class="cl">$ mkdir -p <span class="nv">$MY_INSTALL_DIR</span>
</span></span><span class="line"><span class="cl">$ <span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">&#34;</span><span class="nv">$MY_INSTALL_DIR</span><span class="s2">/bin:</span><span class="nv">$PATH</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 工具安装</span>
</span></span><span class="line"><span class="cl">$ sudo apt install -y cmake <span class="c1">#安装好cmke的同学省略</span>
</span></span><span class="line"><span class="cl">$ sudo apt install -y build-essential autoconf libtool pkg-config
</span></span><span class="line"><span class="cl"><span class="c1"># 下载项目</span>
</span></span><span class="line"><span class="cl">$ git clone --recurse-submodules -b v1.45.0 --depth <span class="m">1</span> --shallow-submodules https://github.com/grpc/grpc
</span></span><span class="line"><span class="cl"><span class="c1"># 编译安装</span>
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> grpc
</span></span><span class="line"><span class="cl">$ mkdir -p cmake/build
</span></span><span class="line"><span class="cl">$ <span class="nb">pushd</span> cmake/build
</span></span><span class="line"><span class="cl">$ cmake -DgRPC_INSTALL<span class="o">=</span>ON -DgRPC_BUILD_TESTS<span class="o">=</span>OFF -DCMAKE_INSTALL_PREFIX<span class="o">=</span><span class="nv">$INSTALL_DIR</span> ../..
</span></span><span class="line"><span class="cl">$ make -j
</span></span><span class="line"><span class="cl">$ make install
</span></span><span class="line"><span class="cl">$ <span class="nb">popd</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The examples presented below all use the official: <a href="https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/">https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/</a>.</p>
<h2 id="asynchronous-client">Asynchronous Client</h2>
<p>For a synchronous client, calling a remote method blocks the current thread, but asynchronous allows multiple requests to be sent at the same time without blocking.</p>
<p>So when we use gRPC&rsquo;s asynchronous API, we need to do the following.</p>
<ol>
<li>since we are making asynchronous non-blocking requests, we must not wait for packets to be returned when we send the request.</li>
<li>all packets are processed asynchronously by another thread to avoid blocking of the main process.</li>
<li>the data of the return packet is passed through some medium. gRPC uses a CompletionQueue to do this.</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/01/f1d5e6672b854ae0a820ddc33ad12fa6.png" alt="Asynchronous Client"></p>
<p>The overall process can be seen from the above diagram as follows.</p>
<ol>
<li>start the client and start a bypass thread to loop through the CompletionQueue data.</li>
<li>send an asynchronous call to the server;</li>
<li>if the server returns the packet, it will put the data into the CompletionQueue.</li>
<li>the asynchronous thread gets the CompletionQueue data and returns it.</li>
</ol>
<p>Let&rsquo;s look at the following example.</p>
<h3 id="create">Create</h3>
<p>The first step is to create the client to, and then asynchronously thread the server&rsquo;s packet return, as it will block while processing the packet return.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">  <span class="c1">// 创建客户端
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">GreeterClient</span> <span class="nf">greeter</span><span class="p">(</span><span class="nx">grpc</span><span class="p">::</span><span class="nf">CreateChannel</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;localhost:50051&#34;</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">::</span><span class="nf">InsecureChannelCredentials</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 起新的线程，从队列中取出结果并处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">std</span><span class="p">::</span><span class="nx">thread</span> <span class="nx">thread_</span> <span class="p">=</span> <span class="nx">std</span><span class="p">::</span><span class="nf">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">GreeterClient</span><span class="p">::</span><span class="nx">AsyncCompleteRpc</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">greeter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">std</span><span class="p">::</span><span class="kt">string</span> <span class="nf">user</span><span class="p">(</span><span class="s">&#34;world &#34;</span> <span class="o">+</span> <span class="nx">std</span><span class="p">::</span><span class="nf">to_string</span><span class="p">(</span><span class="nx">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 发送rpc请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">greeter</span><span class="p">.</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>  <span class="c1">// The actual RPC call!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nx">std</span><span class="p">::</span><span class="nx">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Press control-c to quit&#34;</span> <span class="o">&lt;&lt;</span> <span class="nx">std</span><span class="p">::</span><span class="nx">endl</span> <span class="o">&lt;&lt;</span> <span class="nx">std</span><span class="p">::</span><span class="nx">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nx">thread_</span><span class="p">.</span><span class="nf">join</span><span class="p">();</span>  <span class="c1">// blocks forever
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="asynchronous-requests">Asynchronous requests</h3>
<p>Here the request will be sent by calling SayHello.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">class</span> <span class="nx">GreeterClient</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">public</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="nx">explicit</span> <span class="nf">GreeterClient</span><span class="p">(</span><span class="nx">std</span><span class="p">::</span><span class="nx">shared_ptr</span><span class="p">&lt;</span><span class="nx">Channel</span><span class="p">&gt;</span> <span class="nx">channel</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">:</span> <span class="nf">stub_</span><span class="p">(</span><span class="nx">Greeter</span><span class="p">::</span><span class="nf">NewStub</span><span class="p">(</span><span class="nx">channel</span><span class="p">))</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="nx">void</span> <span class="nf">SayHello</span><span class="p">(</span><span class="kd">const</span> <span class="nx">std</span><span class="p">::</span><span class="kt">string</span><span class="o">&amp;</span> <span class="nx">user</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">HelloRequest</span> <span class="nx">request</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">request</span><span class="p">.</span><span class="nf">set_name</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 用来存储 rpc 数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">AsyncClientCall</span><span class="o">*</span> <span class="nx">call</span> <span class="p">=</span> <span class="nx">new</span> <span class="nx">AsyncClientCall</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里是调用 Async 方法创建 RPC 对象，但是不会理吗开始进行 RPC请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">call</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">response_reader</span> <span class="p">=</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stub_</span><span class="o">-</span><span class="p">&gt;</span><span class="nf">PrepareAsyncSayHello</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">call</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">context</span><span class="p">,</span> <span class="nx">request</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">cq_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 初始化RPC调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">call</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">response_reader</span><span class="o">-</span><span class="p">&gt;</span><span class="nf">StartCall</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 进行RPC请求，然后 call 对象作为一个 tag 放进去，会包数据会放到 reply中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// 这里不会阻塞等待请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">call</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">response_reader</span><span class="o">-</span><span class="p">&gt;</span><span class="nf">Finish</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">call</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">reply</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">call</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">status</span><span class="p">,</span> <span class="p">(</span><span class="nx">void</span><span class="o">*</span><span class="p">)</span> <span class="nx">call</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> <span class="nx">private</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">  <span class="o">...</span>
</span></span><span class="line"><span class="cl">  <span class="nx">CompletionQueue</span> <span class="nx">cq_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Since the packet return logic is not here, you can return directly after calling Finish without waiting. After calling this method, you can wait for the server to return the packet, and the server will stuff the packet data into cq_.</p>
<h3 id="asynchronous-processing-of-packet-returns">Asynchronous processing of packet returns</h3>
<p>The logic for asynchronous packet processing is called in a loop inside the thread we created at the beginning.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">  <span class="nx">void</span> <span class="nf">AsyncCompleteRpc</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">void</span><span class="o">*</span> <span class="nx">got_tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="nx">ok</span> <span class="p">=</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 从队列里面取出回调信息，没有如果还没回包的话会阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">while</span> <span class="p">(</span><span class="nx">cq_</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">got_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">ok</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nx">AsyncClientCall</span><span class="o">*</span> <span class="nx">call</span> <span class="p">=</span> <span class="nx">static_cast</span><span class="p">&lt;</span><span class="nx">AsyncClientCall</span><span class="o">*</span><span class="p">&gt;(</span><span class="nx">got_tag</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="nf">GPR_ASSERT</span><span class="p">(</span><span class="nx">ok</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">call</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">status</span><span class="p">.</span><span class="nf">ok</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 获取到回包的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">std</span><span class="p">::</span><span class="nx">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Greeter received: &#34;</span> <span class="o">&lt;&lt;</span> <span class="nx">call</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">reply</span><span class="p">.</span><span class="nf">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="nx">std</span><span class="p">::</span><span class="nx">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="nx">std</span><span class="p">::</span><span class="nx">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;RPC failed&#34;</span> <span class="o">&lt;&lt;</span> <span class="nx">std</span><span class="p">::</span><span class="nx">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// 销毁new的对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">delete</span> <span class="nx">call</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here will keep calling the Next method to process the server&rsquo;s response, if there is no packet return will keep blocking, so here we need to start a new thread to avoid blocking the main process.</p>
<h2 id="asynchronous-server">Asynchronous Server</h2>
<p>Generally, when we write the Server side, if it is a synchronous operation, the request will be processed immediately after it is received, and then the packet will be returned to the client, and the process of returning the packet needs to wait until the whole RPC request is finished, so there is a blocking waiting process.</p>
<p>However, when understanding the gRPC asynchronous API, it can still feel very awkward to understand the example code at first.</p>
<p>First of all, gRPC makes you prepare a CallData object as a container like a pipeline operation, and then gRPC sends various events to the CallData object through ServerCompletionQueue and lets the object process them according to its own state.</p>
<p>Then after processing the current event, you need to manually create another CallData object, which is prepared for the next Client request, the whole process is like a pipeline.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/01/5f35f0b28f5c440783a522abdca8bf01.png" alt="Asynchronous Server"></p>
<p>The above asynchronous process has a little state machine in it, all reversed by the CallData object.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/01/dd459e2a608d4c06a42360169dcce31d.png" alt="CallData object"></p>
<ul>
<li>When the CallData object is first created, it is reversed from the CREATE state to the PROCESS state, indicating that it is waiting to receive the request.</li>
<li>After the request comes in, a CallData object is first created, then reversed to the FINISH state after processing, waiting for the end of the packet return to the Client.</li>
<li>The CallData object itself will be deleted after the packet return is completed.</li>
</ul>
<p>After it is clear what this CallData object is used to do, let&rsquo;s look at the entire Server process as follows:</p>
<ol>
<li>the Server is started, registered, and a CallData object is created, which is used to prepare for the next Client request.</li>
<li>the created CallData object will be hosted by gRPC, and when an event comes, the event will be put into the CallData object pair, and then notified with a ServerCompletionQueue object.</li>
<li>wait for the Client request to come&hellip;</li>
<li>unpacking the data from the ServerCompletionQueue object when an event comes, turning it into a CallData object to call the Proceed method, then performing business logic processing and re-creating the CallData object to prepare for the next Client request.</li>
<li>wait for the packet return to the Client to finish.</li>
<li>Continue to process the event events returned by ServerCompletionQueue and clean up its own CallData object.</li>
</ol>
<p>Take a look at the code below.</p>
<h3 id="start-registration">Start registration</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">  <span class="nx">void</span> <span class="nf">Run</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 启动注册监听
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">std</span><span class="p">::</span><span class="kt">string</span> <span class="nf">server_address</span><span class="p">(</span><span class="s">&#34;0.0.0.0:50051&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">ServerBuilder</span> <span class="nx">builder</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">builder</span><span class="p">.</span><span class="nf">AddListeningPort</span><span class="p">(</span><span class="nx">server_address</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">::</span><span class="nf">InsecureServerCredentials</span><span class="p">());</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">builder</span><span class="p">.</span><span class="nf">RegisterService</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">service_</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">cq_</span> <span class="p">=</span> <span class="nx">builder</span><span class="p">.</span><span class="nf">AddCompletionQueue</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">server_</span> <span class="p">=</span> <span class="nx">builder</span><span class="p">.</span><span class="nf">BuildAndStart</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nx">std</span><span class="p">::</span><span class="nx">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Server listening on &#34;</span> <span class="o">&lt;&lt;</span> <span class="nx">server_address</span> <span class="o">&lt;&lt;</span> <span class="nx">std</span><span class="p">::</span><span class="nx">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 处理RPC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">HandleRpcs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="start-the-main-process">Start the main process</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">  <span class="nx">std</span><span class="p">::</span><span class="nx">unique_ptr</span><span class="p">&lt;</span><span class="nx">ServerCompletionQueue</span><span class="p">&gt;</span> <span class="nx">cq_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">void</span> <span class="nf">HandleRpcs</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 这里其实是异步逻辑的处理地方
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">new</span> <span class="nf">CallData</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">service_</span><span class="p">,</span> <span class="nx">cq_</span><span class="p">.</span><span class="nf">get</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="nx">void</span><span class="o">*</span> <span class="nx">tag</span><span class="p">;</span>  <span class="c1">// uniquely identifies a request.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="nx">ok</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="c1">// Next方法会阻塞，直到有下个请求过来，才会继续往下走
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">GPR_ASSERT</span><span class="p">(</span><span class="nx">cq_</span><span class="o">-</span><span class="p">&gt;</span><span class="nf">Next</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">ok</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 必须检查 Next 的返回值，这个返回值告诉我们是有事件到来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 还是 cq_ 正在关闭。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nf">GPR_ASSERT</span><span class="p">(</span><span class="nx">ok</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 转成 CallData 调用 Proceed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nx">static_cast</span><span class="p">&lt;</span><span class="nx">CallData</span><span class="o">*</span><span class="p">&gt;(</span><span class="nx">tag</span><span class="p">)</span><span class="o">-</span><span class="p">&gt;</span><span class="nf">Proceed</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The main flow here will create CallData object and then continuously loop through the events from the cq object, which is a waiting queue and will keep blocking when there are no events coming. When there is an event, the tag will be taken from cq_ and converted into a CallData object to call the Proceed method.</p>
<h3 id="create-calldata--logical-processing--completion">Create CallData &amp; Logical Processing &amp; Completion</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">class</span> <span class="nx">ServerImpl</span> <span class="nx">final</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"> <span class="nx">private</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">  <span class="nx">class</span> <span class="nx">CallData</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">public</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">CallData</span><span class="p">(</span><span class="nx">Greeter</span><span class="p">::</span><span class="nx">AsyncService</span><span class="o">*</span> <span class="nx">service</span><span class="p">,</span> <span class="nx">ServerCompletionQueue</span><span class="o">*</span> <span class="nx">cq</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">:</span> <span class="nf">service_</span><span class="p">(</span><span class="nx">service</span><span class="p">),</span> <span class="nf">cq_</span><span class="p">(</span><span class="nx">cq</span><span class="p">),</span> <span class="nf">responder_</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ctx_</span><span class="p">),</span> <span class="nf">status_</span><span class="p">(</span><span class="nx">CREATE</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">      <span class="nf">Proceed</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">void</span> <span class="nf">Proceed</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">status_</span> <span class="o">==</span> <span class="nx">CREATE</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 首次进入，改变状态到 PROCESS
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">status_</span> <span class="p">=</span> <span class="nx">PROCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 需要注意的是，这里将 this 作为 tag 塞入到请求中作为唯一识别请求
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">service_</span><span class="o">-</span><span class="p">&gt;</span><span class="nf">RequestSayHello</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ctx_</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">request_</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">responder_</span><span class="p">,</span> <span class="nx">cq_</span><span class="p">,</span> <span class="nx">cq_</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                  <span class="nx">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">status_</span> <span class="o">==</span> <span class="nx">PROCESS</span><span class="p">)</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 在我们处理这个请求之前，创建一个新的 CallData 实例用于处理未来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 的新请求。实例会在它的 FINISH 状态流程中释放自己占用的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">new</span> <span class="nf">CallData</span><span class="p">(</span><span class="nx">service_</span><span class="p">,</span> <span class="nx">cq_</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 实际的业务逻辑了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">std</span><span class="p">::</span><span class="kt">string</span> <span class="nf">prefix</span><span class="p">(</span><span class="s">&#34;Hello &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 从request_中获取client请求数据，并设置回包数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">reply_</span><span class="p">.</span><span class="nf">set_message</span><span class="p">(</span><span class="nx">prefix</span> <span class="o">+</span> <span class="nx">request_</span><span class="p">.</span><span class="nf">name</span><span class="p">());</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 业务处理完毕，让 gRPC 运行时知道我们已经完成了，使用这个实例的内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 地址作为事件内唯一识别请求的 tag
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">status_</span> <span class="p">=</span> <span class="nx">FINISH</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nx">responder_</span><span class="p">.</span><span class="nf">Finish</span><span class="p">(</span><span class="nx">reply_</span><span class="p">,</span> <span class="nx">Status</span><span class="p">::</span><span class="nx">OK</span><span class="p">,</span> <span class="nx">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">GPR_ASSERT</span><span class="p">(</span><span class="nx">status_</span> <span class="o">==</span> <span class="nx">FINISH</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="c1">// 已经到达 FINISH 状态，释放自身占用内存（CallData）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">delete</span> <span class="nx">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">private</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">    <span class="nx">Greeter</span><span class="p">::</span><span class="nx">AsyncService</span><span class="o">*</span> <span class="nx">service_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 生产-消费队列，用来异步服务消息通知
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ServerCompletionQueue</span><span class="o">*</span> <span class="nx">cq_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// RPC 的上下文信息，用于例如压缩、鉴权以及发送元数据给客户等用途。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ServerContext</span> <span class="nx">ctx_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 从客户端接受到了什么
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">HelloRequest</span> <span class="nx">request_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 从客户端返回什么
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">HelloReply</span> <span class="nx">reply_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 用于回复客户端的方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ServerAsyncResponseWriter</span><span class="p">&lt;</span><span class="nx">HelloReply</span><span class="p">&gt;</span> <span class="nx">responder_</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 状态机
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">enum</span> <span class="nx">CallStatus</span> <span class="p">{</span> <span class="nx">CREATE</span><span class="p">,</span> <span class="nx">PROCESS</span><span class="p">,</span> <span class="nx">FINISH</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nx">CallStatus</span> <span class="nx">status_</span><span class="p">;</span>  <span class="c1">// The current serving state.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">};</span>
</span></span><span class="line"><span class="cl">  <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>From here we can relate to the HandleRpcs method above.</p>
<ol>
<li>first the new CallData will call the Proceed method directly, this time going to the first branch of if, then writing itself this to cq_ and reversing the state to PROCESS.</li>
<li>this time will continue to wait for events in the while loop of the HandleRpcs method.</li>
<li>when a Client sends a request, it goes to the second if branch of Proceed to process the business logic.
<ol>
<li>here first new CallData will be used for the next request;</li>
<li>then the Client request parameters are obtained from request_ and processed;</li>
<li>the packet return data is written to reply_ and finally the Finish call is made.</li>
</ol>
</li>
<li>this time will continue to HandleRpcs method in the while loop waiting for the response to the Client packet end.</li>
<li>after receiving the reply packet, it will continue to call the if third branch of the Proceed method to delete the current object.</li>
</ol>
<h2 id="summary">Summary</h2>
<p>In fact, compared to go&rsquo;s grpc asynchronous API, I have to say that cpp&rsquo;s API design is very problematic, at first glance, I don&rsquo;t know what new CallData is for, why it doesn&rsquo;t do anything after new, and there is no delete operation, won&rsquo;t memory overflow? And then into the constructor method to find the logic are in the constructor, such a way of writing code I have only seen here.</p>
<p>There are also a lot of people spit it out the design of this api: <a href="https://github.com/grpc/grpc/issues/7352">https://github.com/grpc/grpc/issues/7352</a> , the official also promised to modify, but a shake 6 years later also did not improve the meaning.</p>
<hr>
<p>Reference <code>https://www.luozhiyun.com/archives/671</code></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/grpc/">grpc</a>
          <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/2022-05/kubevirt/">
            <span class="next-text nav-default">Kubevirt Managing Virtual Machines</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
