<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Analysis of memory authentication algorithms - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article analyzes and summarizes the memory authentication algorithm." /><meta name="keywords" content="Memory Authentication" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-05/memory-authentication/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Analysis of memory authentication algorithms" />
<meta property="og:description" content="This article analyzes and summarizes the memory authentication algorithm." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-05/memory-authentication/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-16T13:04:19+08:00" />
<meta property="article:modified_time" content="2022-05-16T13:04:19+08:00" />

<meta itemprop="name" content="Analysis of memory authentication algorithms">
<meta itemprop="description" content="This article analyzes and summarizes the memory authentication algorithm."><meta itemprop="datePublished" content="2022-05-16T13:04:19+08:00" />
<meta itemprop="dateModified" content="2022-05-16T13:04:19+08:00" />
<meta itemprop="wordCount" content="1872">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Analysis of memory authentication algorithms"/>
<meta name="twitter:description" content="This article analyzes and summarizes the memory authentication algorithm."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Analysis of memory authentication algorithms</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-05-16 13:04:19 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1872 words </span>
          <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#threat-model">Threat Model</a></li>
        <li><a href="#authentication-primitives">Authentication Primitives</a></li>
        <li><a href="#integrity-tree">Integrity Tree</a></li>
        <li><a href="#cached-trees">Cached Trees</a></li>
        <li><a href="#the-bonsai-merkle-tree">The Bonsai Merkle Tree</a></li>
        <li><a href="#mountable-merkle-tree">Mountable Merkle Tree</a></li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>The background of memory authentication computing is trusted computing, for example, to do some processing involving important data, from the software, we hope that even if the system is illegally accessed by the attacker, we can ensure that important information will not be leaked; from the hardware, we hope that even if the system can be attacked by some physical operations (such as exporting or modifying memory, etc.), we can ensure that the attacker cannot read or tamper with the data.</p>
<p>The following is mainly based on <a href="https://link.springer.com/chapter/10.1007/978-3-642-01004-0_1">Hardware Mechanisms for Memory Authentication: A Survey of Existing Techniques and Engines</a>, a 2009 article.</p>
<h2 id="threat-model">Threat Model</h2>
<p>As a defense mechanism, it is important to first determine the capabilities of the attacker. A common threat model assumes that an attacker has physical control and can manipulate data in memory at will, but cannot read or modify data inside the CPU. That is, only the data inside the CPU chip is trusted; anything outside the chip is within the attacker&rsquo;s control. A simple idea is to make the data stored in the memory encrypted, so how can an attacker attack the encrypted data? Here are a few typical attack methods.</p>
<ul>
<li>Spoofing attack: Changing in-memory data to arbitrary attacker-controlled data; this attack can be solved by signatures</li>
<li>Splicing or relocation attack: Move a section of memory data to another section, so that the signature of the data is still correct; so the address needs to be taken into account when calculating the signature, so that the address has changed, the verification of the signature will fail.</li>
<li>Replay attack: If the memory of the same address has changed, the attacker can write the old memory data in again, so that the signature and address are correct; to prevent replay attacks, you also need to introduce counters or random nonce</li>
</ul>
<h2 id="authentication-primitives">Authentication Primitives</h2>
<p>In order to defend against the above-mentioned attacks, the following ideas are mentioned in the article mentioned above.</p>
<p>One is Hash Function, which divides the memory into many blocks and calculates a cryptographic Hash for each block to be stored in the chip, then when reading data, the whole block of data is read in and the Hash is calculated once and compared with the result stored in the chip; when writing data, the Hash of the modified data is calculated again and updated to the storage in the chip. The disadvantages of this method are that there is no encryption, the attacker can see the content, but once modified, it will be discovered by the CPU (unless there is a Hash conflict), and the storage cost is high: for example, for a 512-bit block, each block calculates a 128-bit Hash, which wastes 25% of the space, and the on-chip space is very valuable.</p>
<p>Second, the MAC Function, which is the message authentication code of cryptography, requires a Key that is saved in the slice; since the attacker does not know the password, according to the nature of the MAC, the attacker cannot tamper with the data or forge the MAC, so the computed MAC can be directly saved into memory as well. In order to defend against replay attacks, we need to introduce random nonce and save the nonce in the slice, for example, for every 512-bit data, 64-bit nonce is saved, so 12.5% of the space in the slice needs to be saved, which is still quite a lot. The MAC itself is not encrypted, so if you do not want the attacker to see the plaintext, you also need to encrypt it.</p>
<p>The third is Block-Level AREA, which means that the plaintext and random nonce are stitched together and saved in memory using a block encryption algorithm; when decrypting, the final nonce is verified to be the same as the one saved in the slice. This method is similar to MAC, which does the encryption thing and also needs to save the random nonce corresponding to each block of data in the chip.</p>
<h2 id="integrity-tree">Integrity Tree</h2>
<p>For example, if we want to protect 1GB of memory, then we need to keep hundreds of MB of data inside the chip, which is too large for on-chip storage. In this case, we can use Merkle Tree or similar methods commonly used in blockchain to trade time for space.</p>
<p>The main idea of this method is to first divide the memory into many blocks, which correspond to the leaf nodes of a tree; build a tree from the bottom up, and each node can verify the integrity of its child nodes, then after log(n) layers of the tree, only a small root node will be obtained in the end, and only the root node needs to be kept in the slice.</p>
<p>To verify the integrity of a particular block, start from the leaf node corresponding to this block, keep computing a value and compare it with the father node; then recursively go up and finally compute the value of the root node and compare it with the value saved in the slice. The complexity of verification in this way is O(log), but the data saved in the slice becomes O(1), so it is time for space. When updating the data, it is similarly calculated step by step from the leaf node and finally updates the value of the root node.</p>
<p>The space wasted by this method, considering all the data saved by non-leaf nodes, is half the total size of the data if it is a binary tree, but the advantage is that most of it can be saved in memory, so it is relatively easy to implement. The disadvantage is that each read and write requires O(logn) number of memory accesses and calculations, and the overhead is relatively high.</p>
<p>The above mentioned method of calculating the value of the parent node is a Merkle Tree if it uses the cryptographic Hash function; its authentication process is read-only and can be parallelized, but the update process is serial because the Hash is calculated step by step from the child nodes, and the parent node depends on the Hash result of the child nodes.</p>
<p>Another design is Parallelizable Authentication Tree (PAT), which uses MAC instead of Hash, each node keeps a random nonce and the computed MAC value, the MAC input at the bottom layer is the actual data, the MAC input at the other layers is the nonce of the child nodes, and finally the nonce value of the last MAC used is kept within the slice The nonce value of the last MAC used is stored in the slice. The advantage of this is that when updating, each layer can be counted in parallel, because the MAC input is the nonce value and does not involve the MAC calculation results of the child nodes. The disadvantage is that more data, i.e. MAC and nonce, have to be kept.</p>
<p>Another design is the Tamper-Evident Counter Tree (TEC-Tree), which computes the Block-level AREA mentioned above. similarly, the bottom layer is encrypted with data and random nonce, while the other layers are encrypted with random nonce of the child nodes, and then stitched with the nonce of this layer. When verifying, the bottom layer is decrypted first, then the data is judged to match, then the upper layer is decrypted again, and the nonce is judged to match, recursively, and finally the nonce of the root is decrypted and matched with the nonce saved in the slice. When updating, we can similarly produce a series of nonce at once, and then encrypt the result of each layer in parallel.</p>
<p>Finally, to quote a comparison from the article.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/16/3da470a63a74462089b1df47591457f3.png" alt="comparison"></p>
<p>It can be seen that the latter two algorithms can update the nodes of the tree in parallel and also need to save more data.</p>
<h2 id="cached-trees">Cached Trees</h2>
<p>From the Integrity Tree algorithm above, we can see that each read or write has to access memory O(logn) times, which has a huge impact on performance. A simple idea is to save some frequently accessed tree nodes in the in-chip cache, so as to reduce the number of memory accesses; furthermore, if it is believed that the attacker cannot tamper with the in-chip cache, then it is straightforward to assume that the in-chip nodes are all trusted, and when verifying and updating, it is only necessary to traverse from the leaf nodes to the in-chip cache nodes.</p>
<h2 id="the-bonsai-merkle-tree">The Bonsai Merkle Tree</h2>
<p>To further reduce space consumption, the Bonsai Merkle Tree (MKT) is based on the idea that instead of encrypting each memory block, the MAC is computed once for C consecutive memory blocks, and an additional counter is added, where the input to the MAC computation is the data, address, and counter. So similarly, the Merkle Tree protects these counters, and since the number of counter bits is smaller, the space overhead can be further reduced, and the number of tree layers is also smaller.</p>
<p>Specifically, to avoid replay attacks, each time the data is updated, the counter is added by one, similar to the original use of a sufficiently long (e.g., 64-bit) random nonce. However, the counter has a limited number of bits, and if the overflow is bypassed, it gives the attacker a chance to perform a replay attack, so the key has to be changed once and re-encrypted.</p>
<p>Re-encryption is very time-consuming, so a two-level counter is designed: a 7-bit local counter, which adds one to each update, and a 64-bit global counter, which adds one when one of the local counters overflows. This is equivalent to making a common prefix of counter, so that when the memory access is more even, for example, each local counter takes turns to add one, then only a small range of memory needs to be re-encrypted each time, reducing This reduces the overhead.</p>
<p>Some related algorithms are mentioned later in the article, so I won&rsquo;t continue to summarize them here.</p>
<h2 id="mountable-merkle-tree">Mountable Merkle Tree</h2>
<p>Let&rsquo;s take a look at the Mountable Merkle Tree design mentioned in <a href="https://www.usenix.org/system/files/osdi21-feng.pdf">Scalable Memory Protection in the Penglai Enclave</a>. It mainly considers dynamically variable protected memory regions, such as the mentioned microservices scenario, and the access to the protected memory region is time-local, so it is thought that instead of constructing a Merkle Tree corresponding to the complete memory, it allows some subtrees to not exist. Specifically, it designs a concept of Sub-root nodes, which corresponds to the middle layer of the Merkle Tree. This layer up is pre-allocated and mostly kept in memory, with the root nodes kept within the slice, and this layer down is dynamically allocated. For example, if an application creates a new enclave, it needs a new protected memory area, and then dynamically allocates several Merkle Trees to the Sub-root nodes layer, which become new subtrees.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/16/316ac387243540ffa670263f808df5a3.png" alt="Mountable Merkle Tree"></p>
<p>Since the space inside the slice is limited, a caching approach is adopted here to keep only a part of the commonly used tree nodes inside the slice; if a subtree has not been accessed, it can be swapped out into memory. If an existing enclave is deleted, then the corresponding subtree can be deleted to reduce the memory space occupation.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-642-01004-0_1">Hardware Mechanisms for Memory Authentication: A Survey of Existing Techniques and Engines</a></li>
<li><a href="https://www.usenix.org/system/files/osdi21-feng.pdf">Scalable Memory Protection in the Penglai Enclave</a></li>
</ul>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2022-05/rocket-chip-custom-debug/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Learn how to add custom debug signals to the Rocket Chip</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-05/js-event-loop/">
            <span class="next-text nav-default">Event Loop mechanism</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
