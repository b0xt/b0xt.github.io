<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>In-depth explanation of the distributed application efficiency improvement framework Apache EventMesh - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore the distributed application efficiency improvement framework Apache EventMesh." /><meta name="keywords" content="Apache EventMesh" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-05/apache-eventmesh/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="In-depth explanation of the distributed application efficiency improvement framework Apache EventMesh" />
<meta property="og:description" content="Explore the distributed application efficiency improvement framework Apache EventMesh." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-05/apache-eventmesh/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-05-12T19:03:41+08:00" />
<meta property="article:modified_time" content="2022-05-12T19:03:41+08:00" />

<meta itemprop="name" content="In-depth explanation of the distributed application efficiency improvement framework Apache EventMesh">
<meta itemprop="description" content="Explore the distributed application efficiency improvement framework Apache EventMesh."><meta itemprop="datePublished" content="2022-05-12T19:03:41+08:00" />
<meta itemprop="dateModified" content="2022-05-12T19:03:41+08:00" />
<meta itemprop="wordCount" content="2490">
<meta itemprop="keywords" content="eventmesh," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="In-depth explanation of the distributed application efficiency improvement framework Apache EventMesh"/>
<meta name="twitter:description" content="Explore the distributed application efficiency improvement framework Apache EventMesh."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">In-depth explanation of the distributed application efficiency improvement framework Apache EventMesh</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-05-12 19:03:41 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2490 words </span>
          <span class="more-meta"> 12 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#eventmesh">EventMesh</a>
          <ul>
            <li><a href="#sevicemesh-vs-eventmesh">SeviceMesh vs EventMesh</a></li>
          </ul>
        </li>
        <li><a href="#eventmesh-feature">EventMesh Feature</a>
          <ul>
            <li><a href="#pubsub">Pub/Sub+</a></li>
            <li><a href="#event-bus">Event Bus</a></li>
            <li><a href="#streaming">Streaming</a></li>
            <li><a href="#orchestration-and-coordination">Orchestration and coordination</a></li>
            <li><a href="#dynamic-expansion-and-contraction">Dynamic expansion and contraction</a></li>
            <li><a href="#bridgefederated-governance">Bridge（Federated Governance）</a></li>
          </ul>
        </li>
        <li><a href="#eventmesh-in-webank-message-busdefibus">EventMesh in WeBank Message Bus（DeFiBus）</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Today we share Apache EventMesh event-driven distributed application runtime, which is a relatively new concept, and we hope we can bring some inspiration to you through this sharing.</p>
<p>We all understand two concepts - message and event. Message refers to the update of a specific event, and this update is sent from one point to another after the message is deleted, and the message is a temporary state of existence; while event refers to what happens at a specific time, it is not bound to a specific recipient or client, and it is often can be replayed, backtracked and reworked.</p>
<p>According to a report by Gartner, the value of data will diminish over time. In many real-time scenarios, it would bring great value if events could be analyzed and data mined in real time, like the very hot streaming computing Flink, Spark, and ClickHouse, etc. They are all very concerned about the real-time nature of data, and EventMesh can deliver data in a timely manner.</p>
<h2 id="eventmesh">EventMesh</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/a97319ff9b3a4c46958ea3c179980c4f.png" alt="EventMesh"></p>
<p>Let&rsquo;s start with the EventMesh architecture diagram, <strong>EventMesh is positioned as an event-driven distributed application runtime</strong>. EventMesh can provide a very lightweight, multi-language client and a wide variety of protocols such as MQTT, Cloudevents, Web Socket and MQP, along with gRPC, TCP and HTTP transport protocols.</p>
<p>EventMesh Runtime is a plug-in architecture that can be connected to back-end middleware or services, such as event storage RocketMQ, Kafaka and Apache Pulsar, etc. If there is a need for some state update maintenance, it can be connected to back-end Redis, MySQL and Mongo DB, etc. If there is a need for some cold data update, it can also be connected to S3, ES and other storage through a plug-in form.</p>
<p>At the control level, EventMesh Runtime can also interface to ETCD, NACOS, Prometheus, Zipkin, Skywalking, OpenTelemetry, etc. if there is a need for event call chain tracking, metadata management, and distributed orchestration. The most common plugins we use internally are RocketMQ and Redis, but EventMesh can also be easily integrated with Kubernetes because EventMesh Runtime can be deployed as Sidecar or as a Gateway.</p>
<p>Let&rsquo;s take a look at the current REST Drive and Event Drive in the microservices space, their respective advantages and disadvantages are very obvious. In the case of Spring Cloud, HTTP2, and gRPC communication, when REST calls a service, it is very easy to develop due to the industry&rsquo;s very well-documented tools and development tool clients, but all calls to REST Drive are synchronous, and synchronous means blocking. If there is a slow call or failure of a service at any node in a chain, it affects the front-end service calls and costs more when Spring Cloud establishes communication with Dubbo services.</p>
<p>However, in the event-driven domain, when accessing the gateway or performing business-level framework layer adaptation, it is invoked asynchronously, all states are ultimately consistent, and can be decoupled from many services and middle layers. In addition, like the Queue subscription publishing method, it is very easy to scale. But it needs to rely on a layer of middleware, the complexity of the middleware needs to be handled manually, but this layer of complexity can be shielded using EventMesh, so for the application development itself, lightweight and convenient.</p>
<h3 id="sevicemesh-vs-eventmesh">SeviceMesh vs EventMesh</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/0625c6fe0624465a8910bc91222012b9.png" alt="SeviceMesh vs EventMesh"></p>
<p>Next we share the difference between SeviceMesh vs EventMesh.</p>
<p>SeviceMesh requires Sidecar and all data level communication is forwarded between Sidecar, but in EventMesh, we see that single or multiple services can hang on a single node of EventMesh, <strong>EventMesh has strong microservice orchestration capabilities</strong>, but EventMesh does not solve all the problems. The advantage of EventMesh is that it is event-driven, and it can also do Request, Reply.</p>
<p>There are synchronous and asynchronous services, and SeviceMesh can be used for synchronous calls, while EventMesh can be used for asynchronous calls. Of course, EventMesh can also do synchronous calls, and SeviceMes can also do asynchronous calls, but the positioning of the two themselves and the scenarios they handle are different, so SeviceMesh and EventMesh can be used in combination.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/338c2f2d0c5043f58644097e4e551798.png" alt="SeviceMesh and EventMesh can be used in combination"></p>
<p>For example, the front-end Web App forwards the calls that come in through the API gateway to the front-end or to a service in a business domain, and it makes calls between internal services, and this process generates data that goes to a relational database or a NoSQL database. But this action of entering the database may need to be subscribed or noticed by other services. At this time, we can forward the events or services to EventMesh, and let EventMesh drive the services that care about these events for follow-up work.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/fc113c085ba84d9faf0b58a58e592471.png" alt="EventMesh makes Simple"></p>
<p>Next, let&rsquo;s take a look at what EventMesh does.</p>
<p>In a DMZ or ECN zone, the purpose of deploying a gateway or front-end service is to perform protocol translation - from an external service with an HTTP or HTTPS interface protocol to an internal protocol with a different service framework (e.g. Dubbo, Spring Cloud). When external, public or partner traffic enters this area, the internal area will form a very complex mesh and the border zone traffic governance is very inconvenient.</p>
<p>The common practice now is to place gateways at the boundary, but with EventMesh, we only need two EventMesh (either clusters or nodes) in the outbound and internal areas, so that services in the boundary area only need to communicate between the EventMesh, and when the request comes to the internal services, through the internal area EventMesh can form many meshes, and each EventMesh mesh proxies the services registered to it. <strong>By connecting the different EventMesh and the services it proxies to form a larger event grid, the governance of many complex invocation scenarios becomes extremely simple</strong>.</p>
<h2 id="eventmesh-feature">EventMesh Feature</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/9e55a404fd074b52b8ca6590d4c5d5d4.png" alt="EventMesh Feature"></p>
<p>In this section I will introduce a few important EventMesh Features.</p>
<h3 id="pubsub">Pub/Sub+</h3>
<p>Nowadays there are very many services in various cloud and private deployment environments, and the connection between services can be done through EventMesh. Services in different regions use different protocols and languages, but any protocols, nodes, and services added in the form of Pub/Sub+ can be unified and aggregated into the grid formed by EventMesh.</p>
<p>As an example, when everyone publishes an event on Amazon Cloud and a service node in a private deployment of Kubernetes subscribes to the message, the message can be routed across many nodes to the Kubernetes service. Also, when services in multiple regions subscribe to the same topic, just send the message to the corresponding topic and the corresponding service will automatically take the message down. <strong>eventMesh can address the diversity of connection protocols, languages, and can address connectivity issues in boundary zones</strong>.</p>
<h3 id="event-bus">Event Bus</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/b5eb45edecb34d3baa0ce20bfda9145a.png" alt="Event Bus"></p>
<p>Event-driven architecture (EDA) is an asynchronous architecture design model that decouples different systems using events as a link. In EDA, the event-driven operational flow naturally delineates the business semantics of each system, and the user can flexibly customize the event and the response to that event according to the requirements, which makes it easy to build highly scalable applications based on EDA architecture.</p>
<p>HTTP Source event source is one of the event sources supported by EventMesh, which exposes the HTTP request address for publishing events in the form of a Webhook, allowing users to configure HTTP Source event source in scenarios with URL callbacks or to publish events directly using the simplest HTTP client. HTTP Source provides Webhook URLs that support different request methods and network environments such as HTTP and HTTPS, public cloud VPC, etc., making it easy for users to integrate them into various applications. No client is required to access the Webhook URL, just ensure that the application can access it, making the access process simple and efficient.</p>
<p>When converting HTTP requests to CloudEvent, EventMesh places the header and message body parts of the request in the CloudEvents field, and the rest of the fields are populated based on user EventMesh resource properties and system default rules. The user can filter and extract the required content from the event rules, and finally assemble the required message content to be delivered to the event target according to the template.</p>
<h3 id="streaming">Streaming</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/8ae888cdd9ca47be943e079987b0adad.png" alt="Streaming"></p>
<p>In current microservices, when we do traffic scheduling, we definitely need to decode the message headers and route to the corresponding service in order to add policies based on the specific fields in the message headers.</p>
<p>In fact, in event-driven, we do not need to decode messages in the first place, we can solve similar problems in its message topic design. For example, it is possible to design a very large number of Topic levels, with progressive relationships between levels, to achieve dynamic filtering. Second, when the message arrives, it can be easily parsed for the message, and on top of the generated events, we can add a lot of Match processing functions, and the generated messages can be processed by the filter chain in real time. The processing of events can be done by EventMesh.</p>
<h3 id="orchestration-and-coordination">Orchestration and coordination</h3>
<p>In the left area of the diagram above, when writing complex Cases, If else conditions or introducing workflows, it has a lot of serial branches in the orchestration, but with EventMesh orchestration, it will look very clean.</p>
<p>We only need to subscribe to the event of interest and send the corresponding event to the other party&rsquo;s topic, we do not need to pay attention to the location of the other party&rsquo;s IP, nor do we need to pay attention to whether the service is deployed on a virtual machine or a container, and the number of instances of the other party&rsquo;s service, and of course, we do not need to pay attention to whether we need to fuse the other party&rsquo;s instance after it hangs, etc. The downstream EventMesh can do everything, for example, when its downstream service fails, the message will be automatically distributed to the current online service instance. From the above diagram, you can see that the use of EventMesh makes the orchestration and coordination process much clearer.</p>
<h3 id="dynamic-expansion-and-contraction">Dynamic expansion and contraction</h3>
<p>Next is the scaling scenario. There are two common scenarios when existing Kubernetes is being scaled.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/773878b7e4ca451aa2197df00bb5c5bb.png" alt="Kubernetes scaled"></p>
<p>The first is the expansion scenario, for example, when the current CPU occupancy is high, the normal situation will trigger the expansion event, but we do not see a particularly large number of messages stacked in the message queue, that is, this time does not need to expand the capacity, in fact, this expansion is wasted; second is the scaling scenario, for example, in the message queue, there is currently no message stacking, theoretically the instance can be scaled down, even to zero, but because of the CPU usage can not be smoothly scaled down.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/1c561233c37943bea0607064a623c2df.png" alt="monitor queue metrics"></p>
<p>However, for both scenarios, if we use Queue queue stacking monitoring with event-driven services, we can achieve the following effects. Firstly, if the resource usage is high but the queue tasks are not stacked, no scaling can be done; secondly, if the current CPU resources are occupied but no tasks are processed, scaling can be done. In my opinion, the metrics for scaling monitoring should be judged based on the current stack of processed tasks.</p>
<h3 id="bridgefederated-governance">Bridge（Federated Governance）</h3>
<p>Before governance, it was like the figure below, where silos of data were formed between different regions.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/6744d329eb854621a7899e051dcb04d7.png" alt="silos of data"></p>
<p>But when governed, it becomes a grid state like the one below, clear and concise.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/ebde6077c72244199c6349d0c5c2df0e.png" alt="grid state"></p>
<p>For most of the last decade, enterprises have struggled with data silos, isolated persistent stores with countless but inaccessible knowledge, whose primary weapon is the data lake: a giant centralized data store that holds terabytes of domain-specific data in one logical location. Data experts without domain knowledge have difficulty trying to extract data value from disparate datasets, and there is little incentive for data producers who contribute high-quality data to the data lake.</p>
<p>With EventMesh&rsquo;s capabilities for real-time analytics, large-scale data collection, platform-agnostic connectivity, and support for open standards, ideally any changes to customer data should be pushed to dependent consumers in real-time via something like an EventMesh, but if the data is less important or untimely, data consumers can pull (or query) the data when needed.</p>
<p>We are transitioning from data anarchy to federated governance and mature enterprise data policies - ideally, policies that can be effectively represented as the end state of the code. Federated governance requires standards such as task-specific tools, event catalogs, and AsyncAPI. Enterprise data policies also include features/functions such as access control, regulations (i.e. GDPR), confidentiality (e.g. PII and PHI), redaction, and encryption. Examples of features may include mandatory header metadata (to contextualize data), observability requirements, topic structure (for routing), and data quality achieved through schema validation and other tools.</p>
<h2 id="eventmesh-in-webank-message-busdefibus">EventMesh in WeBank Message Bus（DeFiBus）</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/05/12/45c5a66182ec4225b798a28cc724d0a5.png" alt="EventMesh in WeBank Message Bus（DeFiBus）"></p>
<p>In WeBank, DeFiBus, a messaging bus that has been open sourced, is shown in the figure above. Here is an example of three nodes of EventMesh, each EventMesh node, can subscribe to services on it. When the sender publishes an event, any service on the other EventMesh that subscribes to Topic can send this event to the corresponding service, which can automatically learn and update the routing table.</p>
<p>EventMesh solves the following problems within WeBank, first of all, it is a multi-language governance problem, for example, AI computing uses Python, many banks&rsquo; systems use C language, EventMesh can simplify the complexity of accessing the message bus, and we know that it is very troublesome to upgrade the SDK that drives the business, when the SDK is light and simplified, we only need to be responsible for When the SDK is light and simplified, we only need to be responsible for the release of the middleware layer, which saves the cost of application-driven upgrades. In addition to the application in the business system, EventMesh is also used in traffic replication playback platform, message bypass filtering, message multi-live routing, AI federal learning, blockchain and other scenarios, more scenarios are in the process of continuous exploration and practice, and we will share them with you in the future.</p>
<h2 id="summary">Summary</h2>
<p>Today&rsquo;s IT systems are generating, collecting and processing more data than ever before. And, they are handling highly complex processes (which are being automated) and integration between systems and devices that span typical organizational boundaries. At the same time, IT systems are expected to be faster and less expensive to develop, while also being highly available, scalable and resilient. To achieve these goals, developers are adopting architectural styles and programming paradigms such as microservices, event-driven architecture, DevOps, etc. New tools and frameworks are being built to help developers meet these expectations. Developers are combining event-driven architecture (EDA) and microservices architectural styles to build systems that are highly scalable, available, fault-tolerant, concurrent, and easy to develop and maintain.</p>
<p>EventMesh, the event infrastructure, is responsible for the transport, routing and serialization of events. The event infrastructure provides support for multiple serialization formats and has a significant impact on architectural quality (e.g., fault tolerance, elastic scalability, throughput, etc.), as well as storing events to create event stores, which are a key architectural pattern for recovery and resiliency.</p>
<p>That concludes this sharing, thank you for reading.</p>
<hr>
<p>Reference <code>https://mp.weixin.qq.com/s/9mpn8jhVoV5NQ2I6Aoae3Q</code></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/eventmesh/">eventmesh</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-05/docker-sbom-cli/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">New command for Docker - sbom</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-05/python-slow/">
            <span class="next-text nav-default">Why is Python so slow?</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
