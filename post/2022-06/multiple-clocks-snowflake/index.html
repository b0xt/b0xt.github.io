<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Multi-clock solves the time redirection problem of snowflake algorithm - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Learn how to solve the time redirection problem of snowflake algorithm by multiple clocks." /><meta name="keywords" content="Snowflake id, time redirection, Multi-clock" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-06/multiple-clocks-snowflake/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Multi-clock solves the time redirection problem of snowflake algorithm" />
<meta property="og:description" content="Learn how to solve the time redirection problem of snowflake algorithm by multiple clocks." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-06/multiple-clocks-snowflake/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-06-20T16:20:29+08:00" />
<meta property="article:modified_time" content="2022-06-20T16:20:29+08:00" />

<meta itemprop="name" content="Multi-clock solves the time redirection problem of snowflake algorithm">
<meta itemprop="description" content="Learn how to solve the time redirection problem of snowflake algorithm by multiple clocks."><meta itemprop="datePublished" content="2022-06-20T16:20:29+08:00" />
<meta itemprop="dateModified" content="2022-06-20T16:20:29+08:00" />
<meta itemprop="wordCount" content="1575">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Multi-clock solves the time redirection problem of snowflake algorithm"/>
<meta name="twitter:description" content="Learn how to solve the time redirection problem of snowflake algorithm by multiple clocks."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Multi-clock solves the time redirection problem of snowflake algorithm</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-06-20 16:20:29 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1575 words </span>
          <span class="more-meta"> 4 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#time-redirection-problem-of-snowflake-algorithm">Time redirection problem of snowflake algorithm</a></li>
        <li><a href="#an-idea-to-solve-the-time-redirection-problem-of-the-snowflake-algorithm---multiple-clocks">An idea to solve the time redirection problem of the snowflake algorithm - multiple clocks</a>
          <ul>
            <li><a href="#algorithm-description">Algorithm description</a></li>
            <li><a href="#scenario-analysis">Scenario analysis</a></li>
            <li><a href="#extreme-scenario-process-restart--time-redirection">Extreme scenario: process restart + time redirection</a></li>
            <li><a href="#high-concurrency-optimization-idea-clock-id-reuse">High concurrency optimization idea: clock ID reuse</a></li>
          </ul>
        </li>
        <li><a href="#some-problems-with-the-multi-clock-snowflake-algorithm">Some problems with the multi-clock snowflake algorithm</a></li>
        <li><a href="#other-ideas-for-solving-the-snowflake-algorithm-time-redirection-problem">Other ideas for solving the snowflake algorithm time redirection problem</a></li>
        <li><a href="#summary">Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Distributed ID generation algorithms are used to generate globally unique ID identifiers in distributed systems, and one well-known algorithm is the snowflake algorithm proposed by twitter, which generates a 64-bit globally unique integer each time, with a very clever underlying idea.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl"> 0        1010......101     1010101010     101010101010
</span></span><span class="line"><span class="cl">\_/       \___________/     \________/     \__________/
</span></span><span class="line"><span class="cl">1           2               3               4
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>The first bit is not used</li>
<li>41-bit millisecond timestamp</li>
<li>10-bit machine ID</li>
<li>12-bit serial number</li>
</ol>
<p>Except for the first bit at the beginning, which is not used, the next 41 bits of the timestamp are the number of milliseconds elapsed from the specified start time to the current time. For example, if you set the system start time to 0:00 on March 15, 2022, then at 12:00:00.123 on April 1, 2022, the value of this timestamp should be <code>1,512,000,123</code>, and the entire timestamp fragment supports a maximum of <code>69.7</code> years, which is clearly beyond the lifetime of most IT systems.</p>
<p>The 10-bit machine ID, which corresponds to a distributed cluster of up to 1024 ID generator instances, and the 12-bit sequence number incrementing continuously from 0 to 4095, can support 4096 ID generation requests per millisecond for a single instance, which means that the entire cluster of ID generator instances can theoretically support up to <code>4194304</code> ID generation per millisecond, which is very efficient. This is very efficient.</p>
<p>The theoretical basis for the global uniqueness of IDs generated by the snowflake algorithm is the combination of global uniqueness and single-instance uniqueness, where global uniqueness is guaranteed by unique machine IDs, and different machine IDs guarantee that IDs generated by different instances must not be the same, while single-instance uniqueness is guaranteed by the same millisecond combined with different sequence numbers, where the sequence numbers can only reach the theoretical upper limit, i.e., theoretically there will not be more than 4096 requests in a millisecond.</p>
<h2 id="time-redirection-problem-of-snowflake-algorithm">Time redirection problem of snowflake algorithm</h2>
<p>The time redirection problem refers to the system time jumping back to a certain time in the past, either actively or passively, possibly due to network time calibration or manual settings, during the operation of the system.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/06/20/3c8fc57f26184fd39e8c176355e9d809.png" alt="time redirection"></p>
<p>Since the snowflake algorithm relies heavily on the current time of the machine, it is possible that if a time rewind occurs, the generated ID may be duplicated with one of the previously generated IDs (<strong>provided that the serial number also happens to be the same when the ID is generated in the same millisecond</strong>), which is the most frequently discussed problem of the snowflake algorithm - time callback. In the original implementation of the snowflake algorithm, for this problem, the algorithm itself just returns the error, and the application decides the processing logic separately. If it is in a business system with low concurrency or low request volume, the error waiting or retry strategy is not a big problem, but if it is in a highly concurrent system, this strategy seems too brutal.</p>
<h2 id="an-idea-to-solve-the-time-redirection-problem-of-the-snowflake-algorithm---multiple-clocks">An idea to solve the time redirection problem of the snowflake algorithm - multiple clocks</h2>
<p>There are many ideas and discussions on the Internet for solving the time redirection problem of the snowflake algorithm, I introduce here is an idea based on the extended bit, but for the sake of understanding, I named myself the multi-clock snowflake algorithm.</p>
<p>Algorithm ideas are also relatively simple, since the time dial back the essence of the problem is the time back to the &ldquo;past&rdquo;, then even if back in the past, as long as the realization of &ldquo;this time is not the other time&rdquo; is not to achieve the time unique? If we think along this line, an intuitive way of thinking is: <strong>Since I have found the time rewind, I will consider the original &ldquo;clock&rdquo; is no longer available, use a new &ldquo;clock&rdquo; can be</strong>, and the new current time is still the new clock&rsquo;s time.</p>
<h3 id="algorithm-description">Algorithm description</h3>
<p>Similar to the classic snowflake algorithm, the multi-clock based improved snowflake algorithm requires a small number of bits for storing the clock ID, the required number of bits can only be split from the original timestamp, machine ID or sequence number, the specific business implementation needs to be combined with the concurrency of the business, cluster size and other comprehensive considerations, here for the convenience of the discussion, assuming 2 bits each from the machine ID and sequence number, for a 4-bit clock ID.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl"> 0       1010......101    0001     10101010   1010101010
</span></span><span class="line"><span class="cl">\_/      \___________/    \__/     \______/   \________/
</span></span><span class="line"><span class="cl">1         2                3        4           5
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>1st bit not used</li>
<li>41-bit millisecond timestamp</li>
<li>4-bit clock ID</li>
<li>8-bit machine ID</li>
<li>10-bit serial number</li>
</ol>
<p>Thus, the new algorithm theoretically.</p>
<ul>
<li>still supports a maximum runtime of 69+ years.</li>
<li>the distributed instance size is reduced to 256.</li>
<li>single instance supports up to 1024 requests per millisecond.</li>
<li>a single instance supports up to 16 callbacks to the same time range (the time callback problem is theoretically perfectly solved if the time callbacks occur in mutually non-overlapping time periods).</li>
</ul>
<p>In the specific implementation logic, mainly in each found time back (i.e., the previous last generated ID timestamp is less than or equal to the current timestamp), it will be clock ID plus 1, similar to the sequence number, and so on.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">timeNow</span> <span class="o">:=</span> <span class="nx">当前系统时间</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">last_time</span> <span class="o">&gt;=</span> <span class="nx">timeNow</span><span class="p">:</span>  <span class="c1">// Clock back
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">clock_id</span> <span class="p">=</span> <span class="p">(</span><span class="nx">clock_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">last_time</span> <span class="p">=</span> <span class="nx">timeNow</span>
</span></span><span class="line"><span class="cl"><span class="nx">seq</span> <span class="o">:=</span> <span class="nx">下一个序列号</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nf">encode</span><span class="p">(</span><span class="nx">timeNow</span><span class="p">,</span> <span class="nx">machineID</span><span class="p">,</span> <span class="nx">seq</span><span class="p">,</span> <span class="nx">clock_id</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="scenario-analysis">Scenario analysis</h3>
<p>Still the example in the picture above, if at a certain moment, the system generates ID, the time is 10:15:00, then the system experiences 5 seconds later, at another moment 10:15:05, the system generates ID again, in this time, the system has been using the clock for <code>1</code>. In the next generation of ID, the system found that <code>lastTime</code> is <code>10:15:05</code>, and the system query machine current time is <code>10:15:00</code>, determine the time back, so switch the clock to <code>2</code>, at this time the generated ID will correspond to <code>10:15:00</code> of clock 2, and the previous clock 1 <code>10:15:00</code> in logic is already two different times, so the generated IDs are naturally different.</p>
<h3 id="extreme-scenario-process-restart--time-redirection">Extreme scenario: process restart + time redirection</h3>
<p>The above algorithm is able to cope with the time redirection problem during operation, but if by some unfortunate coincidence, the system happens to finish time redirection during the process restart when it happens to encounter a crash, how can we ensure that the same ID will not be generated because the same clock is used? One way to continue to improve the idea is to try to get the clock ID from the local disk file before the restart when the ID generator is initialized, and add 1, meaning that each restart must not use the clock before the process exits, and in the running process, each time the clock is switched, the new clock ID should be written to disk, taking into account the performance-friendly, this operation is done asynchronously as possible.</p>
<h3 id="high-concurrency-optimization-idea-clock-id-reuse">High concurrency optimization idea: clock ID reuse</h3>
<p>This multi-clock-based optimization algorithm, because of the need for additional bits to store the clock ID, and occupy the bits used to control the concurrency of the sequence number, if the system does have a high concurrency, the optimization can be considered here is to reuse the clock ID: each time the current clock, <strong>once the current sequence number reaches the upper limit reset, are switched to the next clock</strong>, so that, in theory, the same millisecond In this way, the concurrency can theoretically scale up to 2^14, i.e. <code>16384</code>, in the same millisecond. In most cases, clock rollbacks should be a rare occurrence, and this method of multiplexing clock IDs makes fuller use of the 4 bits of the clock ID.</p>
<h2 id="some-problems-with-the-multi-clock-snowflake-algorithm">Some problems with the multi-clock snowflake algorithm</h2>
<p>Of course, this algorithm is not perfect, it is based on a number of assumptions, while some of the problems it still cannot avoid need to be carefully considered before using.</p>
<ul>
<li>time redirection does not occur frequently in the same time period (in the example given above, time redirection does not happen more than 16 times repeatedly on the same time period).</li>
<li>Incremental problem: when time redirection occurs, ID incrementality is broken, and for scenarios that require strict incrementality, other solutions need to be considered, such as improved algorithms based on &ldquo;historical time&rdquo;.</li>
<li>Evaluation of the machine ID and sequence number space: how to ensure that a globally unique machine ID is obtained is also a complex issue, in addition to the introduction of clock IDs, which will occupy additional bits, need to consider from which bit fragments to free up these bits to be reserved for clock IDs.</li>
<li>multi-clock snowflake algorithm only alleviates the clock redirection problem, but can not completely solve the time redirection problem, so still need to consider an extreme case of fault tolerance program, but since it is an extreme scenario, the use of simple programs such as error retry is sufficient.</li>
</ul>
<h2 id="other-ideas-for-solving-the-snowflake-algorithm-time-redirection-problem">Other ideas for solving the snowflake algorithm time redirection problem</h2>
<ul>
<li>Use historical time</li>
<li>Waiting for clock correction</li>
<li>Time catch-up</li>
<li>Error Retry</li>
</ul>
<h2 id="summary">Summary</h2>
<ul>
<li>Time uniqueness in time redirection scenarios is achieved by introducing multiple clocks, which can cope with time redirection infinitely in ideal scenarios</li>
<li>Multi-clock snowflake algorithm can optimize the efficiency of bit utilization by multiplexing clock IDs</li>
<li>Multi-clock snowflake algorithm also needs to be combined with other fault-tolerant processing to cope with time redirection in extreme scenarios</li>
</ul>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/2022-06/ctx-switch/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">The cost of context switching</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-06/golang-error-logs/">
            <span class="next-text nav-default">5 Suggestions for Error Handling and Log Printing in Golang</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
