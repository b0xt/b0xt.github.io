<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Memory Order in C&#43;&#43; - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore Memory Order in C&#43;&#43;." /><meta name="keywords" content="cpp, Memory Order" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-06/cpp-memory-order/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Memory Order in C&#43;&#43;" />
<meta property="og:description" content="Explore Memory Order in C&#43;&#43;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-06/cpp-memory-order/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-06-26T10:17:22+08:00" />
<meta property="article:modified_time" content="2022-06-26T10:17:22+08:00" />

<meta itemprop="name" content="Memory Order in C&#43;&#43;">
<meta itemprop="description" content="Explore Memory Order in C&#43;&#43;."><meta itemprop="datePublished" content="2022-06-26T10:17:22+08:00" />
<meta itemprop="dateModified" content="2022-06-26T10:17:22+08:00" />
<meta itemprop="wordCount" content="6033">
<meta itemprop="keywords" content="cpp," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Memory Order in C&#43;&#43;"/>
<meta name="twitter:description" content="Explore Memory Order in C&#43;&#43;."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Memory Order in C&#43;&#43;</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-06-26 10:17:22 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 6033 words </span>
          <span class="more-meta"> 13 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-atomic-variables">1. Atomic variables</a>
          <ul>
            <li><a href="#11-operations-on-atomic-variables">1.1 Operations on atomic variables</a></li>
          </ul>
        </li>
        <li><a href="#2-basic-concepts">2. Basic Concepts</a>
          <ul>
            <li><a href="#21-modification-orders">2.1 Modification orders</a></li>
            <li><a href="#22-happens-before">2.2 Happens-before</a></li>
            <li><a href="#23-happens-before-does-not-represent-the-actual-order-of-execution-of-instructions">2.3 Happens-before does not represent the actual order of execution of instructions</a></li>
          </ul>
        </li>
        <li><a href="#3-memory-order">3. Memory order</a>
          <ul>
            <li><a href="#31-memory_order_seq_cst">3.1 memory_order_seq_cst</a></li>
            <li><a href="#32-memory_order_relaxed">3.2 memory_order_relaxed</a></li>
            <li><a href="#33-acquire-release">3.3 Acquire-release</a></li>
            <li><a href="#34-release-sequences">3.4* Release sequences</a></li>
            <li><a href="#35-memory_order_consume">3.5* memory_order_consume</a></li>
          </ul>
        </li>
        <li><a href="#4-some-examples">4. Some examples</a>
          <ul>
            <li><a href="#41-spin-locks">4.1 Spin locks</a></li>
            <li><a href="#42-thread-safe-singleton-pattern">4.2 Thread-safe singleton pattern</a></li>
          </ul>
        </li>
        <li><a href="#5-summary">5. Summary</a></li>
        <li><a href="#6-extended-reading">6. Extended Reading</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>C++11 includes multithreading as a standard. Once multi-threading is involved, there are issues such as <strong>concurrency</strong>, <strong>data race</strong>, <strong>thread synchronization</strong>, etc. C++ provides standard libraries such as <code>std::mutex</code> and <code>std::atomic</code> for this purpose. One important concept for manipulating atomic variables is <strong>memory order</strong>, which involves many concepts and can be difficult to understand. In this article, we will talk about this topic.</p>
<p>This article may be a bit long and involve a lot of concepts. Sections 3.4 and 3.5 are marked with an asterisk, but they have few practical applications and can be skipped if you are not interested.</p>
<h2 id="1-atomic-variables">1. Atomic variables</h2>
<p>We cannot access and modify a variable in two threads at the same time, which can lead to data competition problems. The result of the program is undefined. Implementation-wise, we cannot guarantee that read and write operations are atomic, e.g. on a 32-bit machine, it may take two instructions to modify a 64-bit variable; or the variable may be in a register, and changes to it will not be written to memory until later. The solution to data contention is to use atomic variables in addition to locking with <code>std::mutex</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above example shows the simplest use of an atomic variable. You don&rsquo;t have to worry about data contention with atomic variables, and all operations on them are atomic. In addition, the operation of atomic variables can specify memory order, which helps us to synchronize threads, which is the focus of this article. In the above code, thread 1 writes the value to the atomic variable <code>a</code>, and thread 2 reads the value in <code>a</code>. These are the two most basic operations on atomic variables.</p>
<h3 id="11-operations-on-atomic-variables">1.1 Operations on atomic variables</h3>
<p>The operations on atomic variables can be divided into three types</p>
<ol>
<li>store. Saves a value into an atomic variable.</li>
<li>load. Reads the value from an atomic variable.</li>
<li>read-modify-write (RMW). Reads, modifies and writes atomically. Examples include <code>fetch_add</code>, <code>exchange</code> (returns the current value of a variable and writes the specified value), etc.</li>
</ol>
<p>Each atomic operation needs to specify a <strong>memory order)</strong>. Different memory orders have different semantics, implement different order models, and have different performance. There are six types of memory order in C++.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">memory_order</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">memory_order_relaxed</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">memory_order_consume</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">memory_order_acquire</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">memory_order_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">memory_order_acq_rel</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">memory_order_seq_cst</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>These six memory orders can be combined with each other to achieve three ordering models</p>
<ul>
<li>Sequencial consistent ordering. A model that achieves synchronization and guarantees a single total order. It is the most consistent model, and the default ordering model.</li>
<li>Acquire-release ordering. A model that implements synchronization, but does not guarantee global order consistency.</li>
<li>Relaxed ordering. A model that does not implement synchronization, but only guarantees atomicity.</li>
</ul>
<p>We will discuss these six types of memory ordering in more detail later. The <code>atomic::store</code> and <code>atomic::load</code> functions both have a memory order argument, which defaults to <code>memory_order_seq_cst</code>. They are declared as follows</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">store</span><span class="p">(</span><span class="n">T</span> <span class="n">desired</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="nf">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In addition, <code>std::atomic</code> overloads the operators so that we can read and write atomic variables as if they were normal variables. For example, in the above code, the two threads are calling <code>std::atomic&lt;int&gt;::operator=(int)</code> and <code>std::atomic&lt;int&gt;::operator int()</code> respectively. This uses the default memory order, which is <code>memory_order_seq_cst</code>.</p>
<h2 id="2-basic-concepts">2. Basic Concepts</h2>
<p>Before we start talking about the six types of memory orders, it is important to understand a few basic concepts.</p>
<h3 id="21-modification-orders">2.1 Modification orders</h3>
<p>There is always a certain order in which all modifications to an atomic variable are performed, and this order is agreed upon by all threads, even if the modifications are performed in different threads. This order, which all threads agree on, is called the <strong>modification order</strong>. This means that</p>
<ul>
<li>two modifications cannot be performed at the same time, there must be an order of precedence. This is easy to understand, because it is a requirement for atomic operations, otherwise there would be data contention.</li>
<li>Even though the order of modifications may be different for each run, all threads always see the same order of modifications. If thread a sees the atomic variable x change from 1 to 2, then thread b cannot see x change from 2 to 1.</li>
</ul>
<p>Regardless of the memory order used, atomic variable operations will always satisfy the consistency of the modification order, even in the loosest <code>memory_order_relaxed</code>. Let&rsquo;s look at an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread3</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread4</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">thread1</span><span class="p">),</span> <span class="n">t2</span><span class="p">(</span><span class="n">thread2</span><span class="p">),</span> <span class="n">t3</span><span class="p">(</span><span class="n">thread3</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v3</span><span class="p">),</span> <span class="n">t4</span><span class="p">(</span><span class="n">thread4</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">v3</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">v4</span><span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above code creates 4 threads. <code>thread1</code> and <code>thread2</code> write even and odd numbers to the atomic variable <code>a</code>, respectively, and <code>thread3</code> and <code>thread4</code> read them in turn. Finally, the values of <code>thread3</code> and <code>thread4</code> are output each time they are read. The program may look like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">test</span><span class="o">-</span><span class="n">modification</span><span class="o">-</span><span class="n">order</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl"><span class="mi">0</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">8</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="p">.</span><span class="o">/</span><span class="n">test</span><span class="o">-</span><span class="n">modification</span><span class="o">-</span><span class="n">order</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">8</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">8</span> <span class="mi">8</span> <span class="mi">8</span> <span class="mi">8</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Although the order of changes varies from run to run, and it is unlikely that each thread will see the results of each change, they will see the same order of changes. For example, if <code>thread3</code> sees 8 before 9, <code>thread4</code> will also see 8 before 9, and vice versa.</p>
<h3 id="22-happens-before">2.2 Happens-before</h3>
<p><strong>Happens-before</strong> is a very important concept. If operation a &ldquo;happens-before&rdquo; operation b, then the result of operation a is visible to operation b. The happens-before relationship can be established between two operations using one thread, or between two operations in different threads.</p>
<h4 id="221-the-single-threaded-case-sequenced-before">2.2.1 The single-threaded case: sequenced-before</h4>
<p>The single-threaded case is easy to understand. The statements of a function are executed sequentially, with the previous statements executed first and the later ones executed later. Formally, the preceding statement is always <strong>&ldquo;sequenced-before &ldquo;</strong> the following statement. Clearly, by definition, sequenced-before is transitive:</p>
<ul>
<li>If operation a &ldquo;sequenced-before&rdquo; operates on k, and operation k &ldquo;sequenced-before&rdquo; operates on b, then operation a &ldquo;sequenced-before&rdquo; operates on b.</li>
</ul>
<p>Sequenced-before can directly form the happens-before relation. If operation a &ldquo;sequenced-before&rdquo; operates on b, then operation a &ldquo;happens-before&rdquo; operates on b. For example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// (2)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Statement (1) precedes statement (2), so statement (1) &ldquo;sequenced-before&rdquo; statement (2), which is also (1) &ldquo;happens-before&rdquo; statement (2). So (2) prints the result of the assignment of (1).</p>
<h4 id="222-the-multi-threaded-case-synchronizes-with-and-inter-thread-happens-before">2.2.2 The multi-threaded case: synchronizes-with and inter-thread happens-before</h4>
<p>The multithreaded case is a little more complicated. Generally, multiple threads are executed concurrently, and without proper synchronization, there is no guarantee that there is a happens-before relationship between the two operations. If we synchronize two operations in different threads by some means, we say that the two operations have a <strong>synchronizes-with</strong> relationship. Later we will discuss in detail how to combine the 6 memory orders to make a synchronizes-with relationship between two operations.</p>
<p>If operation a in thread 1 &ldquo;synchronizes-with&rdquo; operation b in thread 2, then operation a <strong>&ldquo;inter-thread happens-before &ldquo;</strong> operation b. In addition, synchronizes-with can be &ldquo;followed&rdquo; by a sequenced-before relationship as inter-thread happens-before relationship:</p>
<ul>
<li>If operation a &ldquo;synchronizes-with&rdquo; operation k, and operation k &ldquo;sequenced-before&rdquo; operation b, then operation a &ldquo;inter-thread happens-before&rdquo; operation b.</li>
</ul>
<p>The inter-thread happens-before relation can then be &ldquo;prepended&rdquo; to a sequenced-before relation to extend its scope; and the inter-thread happens-before relation is transitive:</p>
<ul>
<li>If operation a &ldquo;sequenced-before&rdquo; operates on k, and operation k &ldquo;inter-thread happens-before&rdquo; operates on b, then operation a &ldquo;inter-thread happens-before&rdquo; operates on b. * If operation a &ldquo;inter-thread happens-before&rdquo; operates on k, then operation a &ldquo;inter-thread happens-before&rdquo; operates on b.</li>
<li>If operation a &ldquo;inter-thread happens-before&rdquo; operation k, and operation k &ldquo;inter-thread happens-before&rdquo; operation b, then operation a &ldquo;inter-thread happens-before&rdquo; operation b.</li>
</ul>
<p>As its name implies, if operation a &ldquo;inter-thread happens-before&rdquo; operation b, then operation a &ldquo;happens-before&rdquo; operation b. The following diagram illustrates the relationship between these concepts:</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/06/26/ed0953069fac40b597bbce3e837aab58.png" alt="inter-thread happens-before"></p>
<p>Note that while sequenced-before and inter-thread happens-before are both transferable, <strong>happens-before is not</strong>. We will see the importance of this property later in Section 3.5, and why C++ defines so many concepts.</p>
<p>Now let&rsquo;s look at an example. Suppose the following code has the <code>unlock()</code> operation &ldquo;synchronizes-with&rdquo; the <code>lock()</code> operation.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">unlock</span><span class="p">();</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lock</span><span class="p">();</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Assume that <code>thread2</code> blocks in <code>lock()</code> at (3) until <code>thread1</code> reaches (2). Then we can deduce:</p>
<ul>
<li>Depending on the order of the statements, there are (1) &ldquo;sequenced-before&rdquo; (2) and (3) &ldquo;sequenced-before&rdquo; (4);</li>
<li>Because (2) &ldquo;synchronizes-with&rdquo; (3) and (3) &ldquo;sequenced-before&rdquo; (4), so (2) &ldquo;inter-thread happens-before&rdquo; (4);</li>
<li>because (1) &ldquo;sequenced-before&rdquo; (2) and (2) &ldquo;inter-thread happens-before&rdquo; (4), so (1) &ldquo;inter-thread happens-before&rdquo; (4); so (1) &ldquo;happens-before&rdquo; (4).</li>
</ul>
<p>Therefore (4) can read the changes made by (1) to the variable <code>a</code>.</p>
<h3 id="23-happens-before-does-not-represent-the-actual-order-of-execution-of-instructions">2.3 Happens-before does not represent the actual order of execution of instructions</h3>
<p>It is important to note that happens-before is a C++ semantic concept and does not represent the actual order of execution of instructions in the CPU. To optimize performance, the compiler will reorder instructions without breaking the semantics. For example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Although there is <code>a++;</code> &ldquo;happens-before&rdquo; <code>b++;</code> , the actual instructions generated by the compiler may load <code>a</code> and <code>b</code> variables into registers, then perform &ldquo;plus one&rdquo; operations, then perform <code>a + b</code>, and finally write the result of the self-increment to memory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">add():
</span></span><span class="line"><span class="cl">    movl    a(%rip), %eax   # 将变量 a 加载到寄存器
</span></span><span class="line"><span class="cl">    movl    b(%rip), %ecx   # 将变量 b 加载到寄存器
</span></span><span class="line"><span class="cl">    addl    $1, %eax        # a 的值加一
</span></span><span class="line"><span class="cl">    leal    1(%rcx), %edx   # b 的值加一
</span></span><span class="line"><span class="cl">    movl    %eax, a(%rip)   # 将 a 加一的结果写入内存
</span></span><span class="line"><span class="cl">    addl    %edx, %eax      # a + b
</span></span><span class="line"><span class="cl">    movl    %edx, b(%rip)   # 将 b 加一的结果写入内存
</span></span><span class="line"><span class="cl">    ret
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above shows one possible compilation result under x86-64. You can see that a C++ statement can generate multiple instructions, all of which are interleaved. In fact, the compiler may even increment <code>b</code> and then <code>a</code>. This rearrangement does not affect the semantics, and the result of the two self-increment operations is still visible for <code>return a + b;</code>.</p>
<h2 id="3-memory-order">3. Memory order</h2>
<p>We mentioned earlier that C++&rsquo;s six memory orders can be combined with each other to implement three sequential models. Now let&rsquo;s look at how these six memory orders are used, and how they can be combined to achieve a synchronizes-with relationship.</p>
<h3 id="31-memory_order_seq_cst">3.1 memory_order_seq_cst</h3>
<p><code>memory_order_seq_cst</code> can be used for store, load and read-modify-write operations to implement a sequencial consistent sequential model. In this model, all operations seen by all threads have a consistent order, even though the operations may target different variables and run in different threads. In Section 2.1 we introduced the modification order, where the modification order of a single variable is consistent across all threads. Sequencial consistency extends this consistency to all variables. For example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="nb">false</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">);</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>thread1</code> and <code>thread2</code> modify the atomic variables <code>x</code> and <code>y</code>, respectively. During the run, it is possible to execute (1) first and then (2), or to execute (2) first and then (1). But in any case, the order seen in all threads is the same. So if we test this code like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">z</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">read_x_then_y</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">));</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">))</span> <span class="o">++</span><span class="n">z</span><span class="p">;</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">read_y_then_x</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">));</span> <span class="c1">// (5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_seq_cst</span><span class="p">))</span> <span class="o">++</span><span class="n">z</span><span class="p">;</span> <span class="c1">// (6)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">a</span><span class="p">(</span><span class="n">thread1</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">thread2</span><span class="p">),</span> <span class="n">c</span><span class="p">(</span><span class="n">read_x_then_y</span><span class="p">),</span> <span class="n">d</span><span class="p">(</span><span class="n">read_y_then_x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">c</span><span class="p">.</span><span class="n">join</span><span class="p">(),</span> <span class="n">d</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">load</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// (7)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The assertion at (7) never fails. Since the modification order of x and y is globally consistent, if (1) is executed first and then (2), then when loop (5) in read_y_then_x exits, y is guaranteed to be true, so x must also be true, and therefore (6) will be executed; similarly, if (2) is executed first and then (1), then y must also be true when loop (3) exits, so (4) will be executed. will be executed. In any case, z will not end up equal to 0.</p>
<p>Sequencial consistency allows for a synchronizes-with relationship. If a <code>memory_order_seq_cst</code> load operation reads the value written to an atomic variable by a <code>memory_order_seq_cst</code> store operation on that atomic variable, the store operation &ldquo;synchronizes-with&rdquo; the load operation. In the above example, there are (1) &ldquo;synchronizes-with&rdquo; (3) and (2) &ldquo;synchronizes-with&rdquo; (5).</p>
<p>There is some overhead in implementing a sequencial consistent model. Modern CPUs usually have multiple cores, each with its own cache. To achieve global sequential consistency, each write operation must be synchronized to the other cores. To reduce the performance overhead, if global sequential consistency is not needed, we should consider using a more relaxed sequential model.</p>
<h3 id="32-memory_order_relaxed">3.2 memory_order_relaxed</h3>
<p><code>memory_order_relaxed</code> can be used for store, load and read-modify-write operations to implement the relaxed order model. In this model, only atomicity and modification order of operations are guaranteed, and no synchronizes-with relationship can be achieved. For example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="nb">false</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>thread1</code> performs store operations on different variables. Then, in some threads, it may look like <code>x</code> first becomes <code>true</code> and y later becomes <code>true</code>; in other threads, it may look like <code>y</code> first becomes <code>true</code> and <code>x</code> later becomes <code>true</code>. If you test this code like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">());</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The assertion at (4) is likely to fail. Since there is no synchronizes-with relationship between (2) and (3), it is not guaranteed that (1) &ldquo;happens-before&rdquo; (4). Therefore (4) may read <code>false</code>. An example of the consistency of the modification order guaranteed by the relaxed sequential model was discussed in Section 2.1, and will not be repeated here.</p>
<p>The overhead of the relaxed sequential model is small. On the x86 architecture, the <code>memory_order_relaxed</code> operation does not generate any other instructions, and only affects compiler optimizations to ensure that operations are atomic. The Relaxed model can be used in scenarios where thread synchronization is not required, but care should be taken when using it. For example, <code>std::shared_ptr</code> is used to increase the reference count because it does not need to be synchronized; but it cannot be used to reduce the application count because it needs to be synchronized with the destructor operation.</p>
<h3 id="33-acquire-release">3.3 Acquire-release</h3>
<p>In the acquire-release model, the three memory orders <code>memory_order_acquire</code>, <code>memory_order_release</code> and <code>memory_order_acq_rel</code> are used. Here&rsquo;s how they are used:</p>
<ul>
<li>The <code>memory_order_acquire</code> memory order can be used for loads of atomic variables. This is called the <strong>acquire operation</strong>.</li>
<li>Store of atomic variables can use <code>memory_order_release</code> memory order. This is called the <strong>release operation</strong>.</li>
<li>The read-modify-write operation is both read (load) and write (store), and it can use <code>memory_order_acquire</code>, <code>memory_order_release</code> and <code>memory_order_acq_rel</code>:
<ul>
<li>If <code>memory_order_acquire</code> is used, it acts as an acquire operation;</li>
<li>If <code>memory_order_release</code> is used, it is a release operation;</li>
<li>If <code>memory_order_acq_rel</code> is used, then both.</li>
</ul>
</li>
</ul>
<p>Acquire-release can implement a synchronizes-with relationship. If an acquire operation reads the value written by a release operation on the same atomic variable, the release operation &ldquo;synchronizes-with&rdquo; the acquire operation. Let&rsquo;s look at an example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="nb">false</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">));</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the above example, statement (2) uses <code>memory_order_release</code> to write <code>true</code> to <code>y</code>, and statement (3) uses <code>memory_order_acquire</code> to read the value from <code>y</code>. When loop (3) exits, it has already read the value of <code>y</code> as <code>true</code>, i.e., it has read the value written in operation (2). Therefore, it has (2) &ldquo;synchronizes-with&rdquo; (3). We can deduce this according to the rules described in Section 2.2:</p>
<ul>
<li>Because (2) &ldquo;synchronizes-with&rdquo; (3) and (3) &ldquo;sequenced-before&rdquo; (4), so (2) &ldquo;inter-thread happens-before&rdquo; (4);</li>
<li>Because (1) &ldquo;sequenced-before&rdquo; (2) and (2) &ldquo;inter-thread happens-before&rdquo; (4), therefore (1) &ldquo;inter-thread happens-before&rdquo; (4);</li>
</ul>
<p>so (1) &ldquo;happens-before&rdquo; (4). Therefore (4) can read the value written in (1), and the assertion will never fail. Even though (1) and (4) use <code>memory_order_relaxed</code>.</p>
<p>In Section 3.1 we mentioned that the sequencial consistent model can implement the synchronizes-with relationship. In fact, a load operation and a store operation with memory order <code>memory_order_seq_cst</code> can be considered as an acquire operation and a release operation, respectively. Therefore, for two store and load operations with <code>memory_order_seq_cst</code> specified, if the latter reads the value written by the former, the former &ldquo;synchronizes-with&rdquo; the latter.</p>
<p>To implement the synchronizes-with relationship, the acquire and release operations should appear in pairs. If the load of <code>memory_order_acquire</code> reads the value written by the store of <code>memory_order_relaxed</code>, or the load of <code>memory_order_relaxed</code> reads the value written by the store of <code>memory_order_release</code>, Neither can achieve a synchronizes-with relationship.</p>
<p>While the sequencial consistent model can synchronize as well as acquire-release, the acquire-release model does not provide global sequential consistency as well as sequencial consistent. If we replace <code>memory_order_seq_cst</code> with <code>memory_order_acquire</code> and <code>memory_order_release</code> in the example in Section 3.1, we will be able to achieve synchronization in the same way as sequencial release.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">read_x_then_y</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="o">++</span><span class="n">z</span><span class="p">;</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">read_y_then_x</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="o">++</span><span class="n">z</span><span class="p">;</span> <span class="c1">// (6)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the same run, <code>read_x_then_y</code> may see (1) before (2), while <code>read_y_then_x</code> may see (2) before (1). It is possible that the result of both (4) and (6) loads will be <code>false</code>, resulting in <code>z</code> remaining at 0.</p>
<p>Acquire-release has less overhead than sequencial consistent. In the x86 architecture, the <code>memory_order_acquire</code> and <code>memory_order_release</code> operations do not generate any other instructions, but only affect the compiler&rsquo;s optimization: no instruction can be reordered before an acquire operation and no instruction can be reordered after a release operation; otherwise, the semantics of otherwise the semantics of acquire-release would be violated. Therefore, many scenarios that require a synchronizes-with relationship will use acquire-release.</p>
<h3 id="34-release-sequences">3.4* Release sequences</h3>
<p>As we have seen so far, for either sequencial consistent or acquire-release to have a synchronizes-with relationship, the acquire operation must read the value written by the release operation on the same atomic variable. If the acquire operation does not read the value written by the release operation, then there is usually no synchronizes-with relationship between the two. For example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// (5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the above example, loop (4) exits as soon as the value of <code>y</code> is not 0. When it exits, it may read the value written in (2), or it may read the value written in (3). In the latter case, it is only guaranteed that (3) &ldquo;synchronizes-with&rdquo; (4), not that there is a synchronization relationship between (2) and (4). Therefore, the assertion at (5) may fail.</p>
<p>However, the synchronizes-with relationship is not only formed when the acquire operation reads the value written by the release operation. To account for this, we need to introduce the concept of <strong>release sequence</strong>.</p>
<p>After a release operation A on an atomic variable M completes, a sequence of other operations on M may follow. If this sequence of operations is performed by</p>
<ul>
<li>a write operation on the same thread, or</li>
<li>read-modify-write operations on any thread</li>
</ul>
<p>on any thread, then the sequence is called a <strong>release sequence</strong> headed by release operation A. The write and read-modify-write operations can use any memory order.</p>
<p>If an acquire operation reads a value written by a release operation on the same atomic variable, or reads a value written by a release sequence headed by this release operation, then the release operation &ldquo;synchronizes-with&rdquo; the acquire operation. Let&rsquo;s look at an example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">flag</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">flag</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">.</span><span class="n">compare_exchange_strong</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">expected</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread3</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// (5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the above example, <code>compare_exchange_strong</code> at (3) is a read-modify-write operation that determines whether the value of the atomic variable is equal to the expected value (first argument), and if so, sets the atomic variable to the target value (second argument) and returns <code>true</code>, otherwise it sets the first argument (reference passed) is set to the current value of the atomic variable and <code>false</code> is returned. Operation (3) keeps looping through it, replacing <code>flag</code> with 2 when the value is 1. So (3) is part of the release sequence of (2). And when loop (4) exits, it has already read the value written by (3), which is the value written by the release sequence headed by release operation (2). So we have (2) &ldquo;synchronizes-with&rdquo; (4). So (1) &ldquo;happens-before&rdquo; (5), and the assertion at (5) does not fail.</p>
<p>Note that the memory order of <code>compare_exchange_strong</code> in (3) is <code>memory_order_relaxed</code>, so (2) and (3) do not form a synchronizes-with relationship. That is, when loop (3) exits, there is no guarantee that <code>thread2</code> will read <code>data.at(0)</code> as 42. But (3) belongs to the release sequence of (2), and when (4) reads the value written to the release sequence of (2) in the memory order of `memory_order_acquire can form a synchronizes-with relationship with (2).</p>
<h3 id="35-memory_order_consume">3.5* memory_order_consume</h3>
<p><code>memory_order_consume</code> is actually part of the acquire-release model, but it is special in that it involves interdependencies between data. For this reason, we will introduce two new concepts: <strong>carries dependency</strong> and <strong>dependency-ordered before</strong>.</p>
<p>If operation a &ldquo;sequenced-before&rdquo; b, and b depends on data from a, then a &ldquo;carries a dependency into&rdquo; b. In general, b is said to depend on a if the value of a is used as an operand of b, or if b reads the value written by a. For example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">p</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">i</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// (3)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>has (1) &ldquo;sequenced-before&rdquo; (2) &ldquo;sequenced-before&rdquo; (3); the values of (1) and (2) are used as operands of the subscript operator <code>[]</code> in (3), so there are (1) &ldquo;carries a dependency into&rdquo; (3) and (2) &ldquo;carries a dependency into&rdquo; (3). But (1) and (2) do not depend on each other, they do not carry a dependency into each other. Similar to sequenced-before, the carries dependency relationship is transitive.</p>
<p><code>memory_order_consume</code> can be used for load operations. A load using <code>memory_order_consume</code> is called a consume operation. A consume operation is &ldquo;dependent-ordered before&rdquo; a consume operation if it reads a value written by a release operation on the same atomic variable, or a value written by a release sequence headed by it.</p>
<p>Dependency-ordered before can be &ldquo;followed&rdquo; by a relation that carries dependency to extend its scope: if a &ldquo;depends-ordered before&rdquo; k and k &ldquo;carries a dependency into&rdquo; b, then a &quot; dependency-ordered before&rdquo; b. Dependency-ordered before can directly form the inter-thread happens-before relation: if a &ldquo;dependency-ordered before&rdquo; b then a &ldquo;inter-thread happens-before&rdquo; b. If a &ldquo;dependency-ordered before&rdquo; b then a &ldquo;inter-thread happens-before&rdquo; b. thread happens-before&rdquo; b.</p>
<p>The concept is complex, but the basic idea is:</p>
<ul>
<li>synchronizes-with, which is a release and acquire operation, can be followed by sequenced-before to form an inter-thread happens-before relationship;</li>
<li>The dependency-ordered before of the release and consume operations can only be followed by the carries dependency to form the inter-thread happens-before relationship.</li>
<li>Regardless of how inter-thread happens-before is constructed, it can be preceded by sequenced-before to extend its scope.</li>
</ul>
<p>Let&rsquo;s look at an example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*&gt;</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">p</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">ptr</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">p2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p2</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_consume</span><span class="p">)));</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="o">*</span><span class="n">p2</span> <span class="o">==</span> <span class="s">&#34;Hello&#34;</span><span class="p">);</span> <span class="c1">// (5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span> <span class="c1">// (6)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When the loop exits at (4), the consume operation (4) reads the value written by the release operation (3), so (3) is &ldquo;dependent-ordered before&rdquo; (4). This leads to the derivation:</p>
<ul>
<li>The value of <code>p2</code> is the operand of (5), so (4) &ldquo;carries a dependency into&rdquo; (5);</li>
<li>Because (3) &ldquo;depends-ordered before&rdquo; (4) and (4) &ldquo;carries a dependency into&rdquo; (5), so (3) &ldquo;inter-thread happens-before&rdquo; (5);</li>
<li>Because (1) &ldquo;sequenced-before&rdquo; (3) and (3) &ldquo;inter-thread happens-before&rdquo; (5), so (1) &ldquo;inter-thread happens-before&rdquo; (5);</li>
</ul>
<p>so (1) &ldquo;happens-before&rdquo; (5). So (5) can read the value written by (1), asserting that (5) will not fail. But operation (6) does not depend on (4), so there is no inter-thread happens-before relationship between (3) and (6), so assertion (6) may fail. Recall from Section 2.2 that happens-before has no transferability. So it cannot be said that because (3) &ldquo;happens-before&rdquo; (4) and (4) &ldquo;happens-before&rdquo; (6) that (2) &ldquo;happens-before&rdquo; (6).</p>
<p>Similar to acquire-release, the use of <code>memory_order_consume</code> under x86 does not generate any other directives, but only affects compiler optimizations. Instructions that have dependencies on the consume operation are not reordered ahead of the consume operation. The restrictions on reordering are more relaxed than for acquire, which requires that all instructions not be reordered before it, while consume requires that only dependent instructions not be reordered before it. Therefore, in some cases, consume may have higher performance.</p>
<h2 id="4-some-examples">4. Some examples</h2>
<p>Having covered a lot of concepts and theory, let&rsquo;s now look at two practical examples to deepen our understanding.</p>
<h3 id="41-spin-locks">4.1 Spin locks</h3>
<p>In some scenarios, if the lock is occupied for a short time, we choose a spinlock to reduce the overhead of context switching. Locks are generally used to protect critical data from being read or written, and we want only one thread to have access to the lock at the same time, and the data protected by the lock to be always up-to-date when the lock is acquired. The former is guaranteed by atomic operations, while the latter requires consideration of memory order.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">spinlock</span> <span class="n">mu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">val</span> <span class="o">=</span> <span class="n">read_from_remote</span><span class="p">()))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">val</span><span class="p">);</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">queue</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span> <span class="c1">// (5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">mu</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span> <span class="c1">// (6)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Two threads are running concurrently, <code>thread1</code> writes data to the queue and <code>thread2</code> reads data from the queue. The in-queue operation (2) may require copying data, moving pointers, or even resizing the queue, so we need to ensure that the results of these operations are fully visible when the lock is acquired. The same goes for the out-queue operations. So the spinlock has to ensure that the unlock operation &ldquo;synchronizes-with&rdquo; the lock operation, and that the data protected by the lock is complete.</p>
<p>We can use the acquire-release model to implement spin locks. Here is a simple implementation:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">spinlock</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">flag</span><span class="p">{</span><span class="nb">false</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">lock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">exchange</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">));</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">flag</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the above implementation, the <code>exchange</code> used for locking at (1) is a read-modify-write operation that writes the target value (the first argument) to an atomic variable and returns the value before it was written. In this implementation, <code>flag</code> is <code>true</code> when the lock is occupied. If the lock is occupied, the exchange operation at (1) keeps returning <code>true</code> and the thread blocks in the loop; until the lock is released, <code>flag</code> is <code>false</code> and the exchange operation resets <code>flag</code> to <code>true</code> to seize the lock and returns its original value of <code>false</code>, the loop exits, and locking is successful. Unlocking is as simple as setting <code>flag</code> to <code>false</code>.</p>
<p>Since the unlock operation uses <code>memory_order_release</code> and the lock operation uses <code>memory_order_acquire</code>, it is guaranteed that the unlock operation is &ldquo;synchronizes-with&rdquo; the previous unlock operation, i.e. the unlock operation &ldquo;synchronizes- with&rdquo; lock operation.</p>
<p>The exchange operation during locking is a read-modify-write operation, which reads and writes at the same time. When it uses <code>memory_order_acquire</code>, only the part it reads is guaranteed to be an acquire operation. If there are two threads acquiring the same lock.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">spinlock</span> <span class="n">mu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// some operations
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mu</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>There is no synchronization between (1) and (2), and assuming that operation (1) is executed before operation (2), the result of the operation before (1) in <code>thread1</code> is not necessarily visible to <code>thread2</code>. What is certain is that only one thread will get the lock, which is guaranteed by the modification order of the atomic variables. Either <code>thread1</code> will set <code>flag</code> to <code>true</code> first, or <code>thread2</code> will set <code>flag</code> to <code>true</code> first, and this order is globally consistent.</p>
<h3 id="42-thread-safe-singleton-pattern">4.2 Thread-safe singleton pattern</h3>
<p>The singleton pattern is a very common design pattern. We usually use a static member pointer to store a unique instance of the class, and then use a static member function to get it, or create it if the pointer is empty.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">App</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">App</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">App</span> <span class="o">*</span><span class="n">get_instance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">App</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>But this approach has concurrency problems with multiple threads. The easiest way to solve this problem is to add a lock. However, it is not necessary to lock the entire function, because the concurrency problem only arises when the object is initially created, and later when only the pointer is returned, which causes an unnecessary performance burden. A better approach would be to add locks only when the object is to be created, which we can do.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">App</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">App</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">App</span> <span class="o">*</span><span class="n">get_instance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instance</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="n">App</span><span class="p">;</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the above implementation, if the <code>instance</code> pointer is found to be empty, a lock is added and the object is created. After the lock is acquired, it is necessary to determine if <code>instance</code> is empty, in case another thread creates the object after (1) and before the lock is acquired. But this is problematic: (1) is not protected by a lock, and it may be concurrent with (2), leading to data contention.</p>
<p>We can solve this problem by using atomic variables, changing the <code>instance</code> pointer to the atomic type <code>std::atomic&lt;App*&gt;</code>. What memory order should be used when reading and writing <code>instance</code>, and will <code>memory_order_relaxed</code> work?</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">App</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">App</span><span class="o">*&gt;</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">App</span> <span class="o">*</span><span class="n">get_instance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)))</span> <span class="p">{</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">App</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">instance</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Suppose thread 1 calls <code>get_instance</code>, finds that the object is not created, then successfully obtains a lock and creates the object, then executes (3) to write the pointer to the new object into <code>instance</code>; then thread 2 also calls <code>get_instance</code> and executes (1) to read the value written by thread 1 in operation (3), can we guarantee that the pointer we get <code>p</code> is valid?</p>
<p>Note that thread 1 needs to call the constructor to initialize the members of <code>App</code> when it executes <code>p = new App</code>. Since (1) and (3) are both <code>memory_order_relaxed</code> memory orders, there is no synchronizes-with relationship between them. So when thread 2 reads the pointer written by thread 1 during operation (1), there is no guarantee that the initialization of the <code>App</code> member will be visible to thread 2. This results in thread 2 getting incomplete object data, which can lead to very unexpected results.</p>
<p>The correct approach is to use the acquire-release model:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">App</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">App</span><span class="o">*&gt;</span> <span class="n">instance</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mu</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">App</span> <span class="o">*</span><span class="n">get_instance</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">auto</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">);</span> <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">mu</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">instance</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)))</span> <span class="p">{</span> <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">App</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">instance</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span> <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>So when thread 2 reads the pointer written by thread 1 in operation (1), it has (3) &ldquo;synchronizes-with&rdquo; (1). So the result of thread 1 initializing the <code>App</code> member is visible to thread 2, which returns <code>p</code> without any problems.</p>
<p>Operation (2) still uses <code>memory_order_relaxed</code>, because it is protected by a lock, which guarantees thread synchronization, so there is no problem.</p>
<h2 id="5-summary">5. Summary</h2>
<p>To summarize these memory order models:</p>
<ul>
<li><code>memory_order_release</code>: the most relaxed memory order, guaranteeing only <strong>atomicity</strong> and <strong>modification order</strong> of operations.</li>
<li><code>memory_order_acquire</code>, <code>memory_order_release</code> and <code>memory_order_acq_rel</code>: implements <strong>acquire operations</strong> and <strong>release operations</strong>, if the acquire operation reads the value written by the release operation, or its If the acquire operation reads the value written by the release operation, or the value written by its release sequence, then it constitutes a <strong>synchronizes-with relationship</strong>, which leads to a <strong>happens-before relationship</strong>.</li>
<li><code>memory_order_consume</code>: implements the <strong>consume operation</strong>, which enables data-dependent synchronization relationships. If the consume operation reads the value written by the release operation, or the value written by its release sequence, it constitutes a <strong>dependency-ordered before relationship</strong>, which can be derived from the <strong>happens-before relationship</strong> for operations that have data dependencies.</li>
<li><code>memory_order_seq_cst</code>: an enhanced version of the acquire-release model, which not only implements <strong>synchronizes-with relationships</strong>, but also guarantees <strong>global order consistency</strong>.</li>
</ul>
<h2 id="6-extended-reading">6. Extended Reading</h2>
<p>For some concepts, such as sequenced-before and carries dependency, this article only describes a few simple cases, and does not give a strict definition. In practice we don&rsquo;t usually need to consider their strict definitions, but if you need to understand them or are interested in them, you can refer to cppreference.com.</p>
<p>C++ also has some features regarding memory order that are not mentioned in this article, such as memory fences. C++&rsquo;s atomic variables also provide many operations, but only some of them are mentioned in this article. For those who are interested or need to know more about them, see <em>C++ Concurrency in Action</em> and cppreference.com. For lack of space, some parts of this article may not be sufficiently detailed or well-defined. For a strict definition of the concept, see cppreference.com; for a more detailed explanation, see <em>C++ Concurrency in Action</em>.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/cpp/">cpp</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-06/shell-1/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">How to use the shell (1/3) - shell compatibility and history</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-06/blackbox-exporter/">
            <span class="next-text nav-default">Testing Network Connectivity with Blackbox Exporter</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
