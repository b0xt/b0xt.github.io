<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>In-depth understanding of eBPF｜7 core issues you need to know - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article introduces the eBPF technology itself by answering 7 core questions to unlock the eBPF for everyone." /><meta name="keywords" content="Ebpf" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-06/ebpf/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="In-depth understanding of eBPF｜7 core issues you need to know" />
<meta property="og:description" content="This article introduces the eBPF technology itself by answering 7 core questions to unlock the eBPF for everyone." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-06/ebpf/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-06-17T12:41:42+08:00" />
<meta property="article:modified_time" content="2022-06-17T12:41:42+08:00" />

<meta itemprop="name" content="In-depth understanding of eBPF｜7 core issues you need to know">
<meta itemprop="description" content="This article introduces the eBPF technology itself by answering 7 core questions to unlock the eBPF for everyone."><meta itemprop="datePublished" content="2022-06-17T12:41:42+08:00" />
<meta itemprop="dateModified" content="2022-06-17T12:41:42+08:00" />
<meta itemprop="wordCount" content="3497">
<meta itemprop="keywords" content="Ebpf," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="In-depth understanding of eBPF｜7 core issues you need to know"/>
<meta name="twitter:description" content="This article introduces the eBPF technology itself by answering 7 core questions to unlock the eBPF for everyone."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">In-depth understanding of eBPF｜7 core issues you need to know</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-06-17 12:41:42 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3497 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#what-is-ebpf">What is eBPF?</a></li>
        <li><a href="#what-are-the-application-scenarios-of-ebpf">What are the application scenarios of eBPF?</a>
          <ul>
            <li><a href="#network-optimization">Network Optimization</a></li>
            <li><a href="#troubleshooting">Troubleshooting</a></li>
            <li><a href="#security-control">Security Control</a></li>
            <li><a href="#performance-monitoring">Performance Monitoring</a></li>
          </ul>
        </li>
        <li><a href="#why-did-ebpf-emerge">Why did eBPF emerge?</a></li>
        <li><a href="#how-to-use-ebpf">How to use eBPF?</a>
          <ul>
            <li><a href="#5-steps">5 steps</a></li>
            <li><a href="#ebpf-program-classification-and-usage-scenarios">eBPF program classification and usage scenarios</a></li>
          </ul>
        </li>
        <li><a href="#what-are-the-best-practices-for-ebpf">What are the best practices for eBPF?</a>
          <ul>
            <li><a href="#finding-the-kernel-stubbing-point">Finding the kernel stubbing point</a></li>
            <li><a href="#find-the-staking-point-of-the-application">Find the staking point of the application</a></li>
            <li><a href="#related-issues-and-staking-points">Related Issues and Staking Points</a></li>
          </ul>
        </li>
        <li><a href="#what-is-the-principle-of-ebpf-implementation">What is the principle of eBPF implementation?</a>
          <ul>
            <li><a href="#5-modules">5 modules</a></li>
            <li><a href="#3-actions">3 actions</a></li>
          </ul>
        </li>
        <li><a href="#the-current-state-of-development-of-ebpf">The current state of development of eBPF?</a>
          <ul>
            <li><a href="#kernel-support">Kernel support</a></li>
            <li><a href="#ecology">Ecology</a></li>
          </ul>
        </li>
        <li><a href="#write-at-the-end">Write at the end</a>
          <ul>
            <li><a href="#the-prerequisite-for-using-ebpf-well-is-the-understanding-of-the-software-stack">The prerequisite for using eBPF well is the understanding of the software stack</a></li>
            <li><a href="#ebpfs-killer-feature-is-full-coverage-non-intrusive-programmable">eBPF&rsquo;s killer feature is full coverage, non-intrusive, programmable</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Over the past year, ARMS has built Kubernetes monitoring based on eBPF technology, providing multi-language non-intrusive application performance, system performance, and network performance observation capabilities, validating the effectiveness of eBPF technology. eBPF technology and ecology are developing well, and the future prospects are vast. As a practitioner of this technology, the goal of this paper is to introduce eBPF technology by answering 7 core questions itself, to unravel the eBPF for everyone.</p>
<h2 id="what-is-ebpf">What is eBPF?</h2>
<p>eBPF is a technology that enables sandboxed programs to be run in the kernel, providing a mechanism to safely inject code when kernel events and user program events occur, allowing non-kernel developers to take control of the kernel as well. As the kernel has evolved, eBPF has gradually expanded from its initial packet filtering to include networking, kernel, security, tracing, etc. And its functional features are still evolving rapidly. Early BPFs were called classic BPFs, or cBPF for short, and it is this functional expansion that has led to the current BPFs being called extended BPFs, or eBPF for short.</p>
<h2 id="what-are-the-application-scenarios-of-ebpf">What are the application scenarios of eBPF?</h2>
<h3 id="network-optimization">Network Optimization</h3>
<p>The eBPF combines high performance and high scalability characteristics, making it the preferred solution for network packet processing in network solutions:</p>
<ul>
<li>
<p>High Performance
The JIT compiler provides near kernel native code execution efficiency.</p>
</li>
<li>
<p>Highly Scalable
Protocol parsing and routing policies can be added quickly in the context of the kernel.</p>
</li>
</ul>
<h3 id="troubleshooting">Troubleshooting</h3>
<p>This end-to-end tracing capability allows for fast troubleshooting, while eBPF supports a more efficient way to leverage profiling statistics without the need to leverage large amounts of sampled data like traditional systems, allowing for continuous real-time profiling is possible.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/06/17/75818425b26d4bc2b2decb1b4dc204e8.png" alt="linux profiling"></p>
<h3 id="security-control">Security Control</h3>
<p>eBPF can see all system calls, all network packets and socket network operations. The integration combined with process context tracking, network operation level filtering, and system call filtering can provide better security control.</p>
<h3 id="performance-monitoring">Performance Monitoring</h3>
<p>Compared to traditional system monitoring components such as sar, which can only provide static counters and gauges, eBPF supports programmatically and dynamically collecting and aggregating custom metrics and events at the edge, greatly improving the efficiency and imagination of performance monitoring.</p>
<h2 id="why-did-ebpf-emerge">Why did eBPF emerge?</h2>
<p>eBPF emerged essentially to solve the contradiction between slow kernel iterations and rapidly changing system requirements. A common example in the eBPF space is that eBPF is similar to the Linux Kernel as Javascript is to HTML, highlighting programmability. In general programmability support usually brings some new problems, for example kernel modules are actually designed to solve this problem, but they do not provide good boundaries, resulting in kernel modules affecting the stability of the kernel itself, the need to do adaptations in different kernel versions, etc. eBPF uses the following strategies to make it a safe and efficient kernel programmable technology.</p>
<ul>
<li>
<p>Security
eBPF programs must be verified by the verifier before execution and cannot contain unreachable instructions. eBPF programs cannot call kernel functions at will, only auxiliary functions defined in the API. eBPF program stack space is at most 512 bytes, and if you want larger storage, you have to use mapped storage.</p>
</li>
<li>
<p>Efficient
With the help of the Just-In-Time (JIT) compiler, and because eBPF instructions still run in the kernel, there is no need to copy data to the user state, which greatly increases the efficiency of event processing.</p>
</li>
<li>
<p>Standard
Provides standard interfaces and data models for developers to use through BPF Helpers, BTF, PERF MAP.</p>
</li>
<li>
<p>Powerful Features
eBPF not only extends the number of registers and introduces a new BPF mapping store, but also gradually extends the original single packet filtering event in the 4.x kernel to include kernel state functions, user state functions, trace points, performance events (perf_events), and security controls.</p>
</li>
</ul>
<h2 id="how-to-use-ebpf">How to use eBPF?</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/06/17/7422fdba26084cef8ebf851508f4c229.png" alt="eBPF"></p>
<h3 id="5-steps">5 steps</h3>
<ol>
<li>
<p>develop an eBPF program using C language.</p>
<p>i.e., the eBPF sandbox program to be called when the staking point triggers an event, which will run in the kernel state.</p>
</li>
<li>
<p>compile the eBPF program into BPF bytecode with the help of LLVM.</p>
<p>The eBPF program is compiled into BPF bytecode for subsequent verification and running inside the eBPF VM.</p>
</li>
<li>
<p>committing the BPF bytecode to the kernel via the bpf system call.</p>
<p>Load the BPF bytecode into the kernel via the bpf system in the user state.</p>
</li>
<li>
<p>the kernel verifies and runs the BPF bytecode and saves the corresponding state to the BPF mapping.</p>
<p>The kernel verifies that the BPF bytecode is safe and ensures that the correct eBPF program is called when the corresponding event occurs. If there is state to be saved, it is written to the corresponding BPF mapping, for example, monitoring data can be written to the BPF mapping.</p>
</li>
<li>
<p>the user program queries the operational status of BPF bytecode through BPF mapping.</p>
<p>The user state gets the status of bytecode operation by querying the content of BPF mapping, such as getting the captured monitoring data.</p>
</li>
</ol>
<p>A complete eBPF program usually consists of two parts: the user state program needs to interact with the kernel through BPF system calls to perform tasks such as eBPF program loading, event mounting, and mapping creation and update; while in the kernel state, the eBPF program cannot arbitrarily call kernel functions, but needs to perform the required tasks through BPF helper functions. In particular, when accessing memory addresses, memory data must be read with the help of the bpf_probe_read family of functions to ensure safe and efficient access to memory. When eBPF programs require large blocks of storage, we also need to introduce a specific type of BPF mapping depending on the application scenario and provide running state data to the user space programs with the help of it.</p>
<h3 id="ebpf-program-classification-and-usage-scenarios">eBPF program classification and usage scenarios</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">bpftool feature probe <span class="p">|</span> grep program_type
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above command allows you to view the types of eBPF programs supported by the system, which are generally of the following types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">eBPF program_type socket_filter is available
</span></span><span class="line"><span class="cl">eBPF program_type kprobe is available
</span></span><span class="line"><span class="cl">eBPF program_type sched_cls is available
</span></span><span class="line"><span class="cl">eBPF program_type sched_act is available
</span></span><span class="line"><span class="cl">eBPF program_type tracepoint is available
</span></span><span class="line"><span class="cl">eBPF program_type xdp is available
</span></span><span class="line"><span class="cl">eBPF program_type perf_event is available
</span></span><span class="line"><span class="cl">eBPF program_type cgroup_skb is available
</span></span><span class="line"><span class="cl">eBPF program_type cgroup_sock is available
</span></span><span class="line"><span class="cl">eBPF program_type lwt_in is available
</span></span><span class="line"><span class="cl">eBPF program_type lwt_out is available
</span></span><span class="line"><span class="cl">eBPF program_type lwt_xmit is available
</span></span><span class="line"><span class="cl">eBPF program_type sock_ops is available
</span></span><span class="line"><span class="cl">eBPF program_type sk_skb is available
</span></span><span class="line"><span class="cl">eBPF program_type cgroup_device is available
</span></span><span class="line"><span class="cl">eBPF program_type sk_msg is available
</span></span><span class="line"><span class="cl">eBPF program_type raw_tracepoint is available
</span></span><span class="line"><span class="cl">eBPF program_type cgroup_sock_addr is available
</span></span><span class="line"><span class="cl">eBPF program_type lwt_seg6local is available
</span></span><span class="line"><span class="cl">eBPF program_type lirc_mode2 is NOT available
</span></span><span class="line"><span class="cl">eBPF program_type sk_reuseport is available
</span></span><span class="line"><span class="cl">eBPF program_type flow_dissector is available
</span></span><span class="line"><span class="cl">eBPF program_type cgroup_sysctl is available
</span></span><span class="line"><span class="cl">eBPF program_type raw_tracepoint_writable is available
</span></span><span class="line"><span class="cl">eBPF program_type cgroup_sockopt is available
</span></span><span class="line"><span class="cl">eBPF program_type tracing is available
</span></span><span class="line"><span class="cl">eBPF program_type struct_ops is available
</span></span><span class="line"><span class="cl">eBPF program_type ext is available
</span></span><span class="line"><span class="cl">eBPF program_type lsm is available
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>For details, please refer to: <a href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf_types.h">https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf_types.h</a></p>
</blockquote>
<p>It is mainly divided into 3 major usage scenarios.</p>
<ul>
<li>
<p>tracing
tracepoint, kprobe, perf_event, etc., are mainly used to extract trace information from the system, which in turn provides data support for monitoring, troubleshooting, performance optimization, etc.</p>
</li>
<li>
<p>Network
xdp, sock_ops, cgroup_sock_addr , sk_msg, etc., mainly used to filter and process network packets, and then implement various rich functions such as network observation, filtering, traffic control and performance optimization, etc., where packets can be dropped and redirected.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/06/17/cf3ded2bb33c4e35b85feb835571c58b.png" alt="Network"></p>
<p>cilium basically uses all hook points.</p>
</li>
<li>
<p>security and others</p>
<p>lsm, for security, and others are flow_dissector, lwt_in are some of the less commonly used, not to repeat.</p>
</li>
</ul>
<h2 id="what-are-the-best-practices-for-ebpf">What are the best practices for eBPF?</h2>
<h3 id="finding-the-kernel-stubbing-point">Finding the kernel stubbing point</h3>
<p>As you can see from the previous section the eBPF program itself is not difficult, the difficulty is finding the right event source for it to trigger the run. For the monitoring and diagnostic domain, the event sources for trace-like eBPF programs contain 3 categories: kernel functions (kprobe), kernel trace points (tracepoint) or performance events (perf_event). At this point there are 2 questions that need to be answered.</p>
<ol>
<li>
<p>What kernel functions, kernel trace points or performance events are available in the kernel?</p>
<ul>
<li>
<p>Use debug information to get kernel functions, kernel trace points.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo ls /sys/kernel/debug/tracing/events
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Use bpftrace to get kernel functions, kernel trace points.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># 查询所有内核插桩和跟踪点</span>
</span></span><span class="line"><span class="cl">sudo bpftrace -l
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用通配符查询所有的系统调用跟踪点</span>
</span></span><span class="line"><span class="cl">sudo bpftrace -l <span class="s1">&#39;tracepoint:syscalls:*&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用通配符查询所有名字包含&#34;open&#34;的跟踪点</span>
</span></span><span class="line"><span class="cl">sudo bpftrace -l <span class="s1">&#39;*open*&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Get performance events with perf list</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo perf list tracepoint
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>For kernel functions and kernel trace points, how do you query the definition format of these data structures when you need to trace their incoming parameters and return values?</p>
<ul>
<li>
<p>Use debug information to obtain</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_openat/format
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Use bpftrace to get</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo bpftrace -lv tracepoint:syscalls:sys_enter_openat
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ol>
<blockquote>
<p>For details on how to use the above information, please refer to bcc.</p>
</blockquote>
<h3 id="find-the-staking-point-of-the-application">Find the staking point of the application</h3>
<ol>
<li>
<p>How to query the tracking points of user processes?</p>
<ul>
<li>
<p>Static compiled language keeps debugging information by -g compile option, application binary will contain DWARF (Debugging With Attributed Record Format), with debugging information, you can query the list of functions, variables and other symbols available for tracing by readelf, objdump, nm and other tools.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># 查询符号表</span>
</span></span><span class="line"><span class="cl">readelf -Ws /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查询USDT信息</span>
</span></span><span class="line"><span class="cl">readelf -n /usr/lib/x86_64-linux-gnu/libc.so.6
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>Using bpftrace</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># 查询uprobe</span>
</span></span><span class="line"><span class="cl">bpftrace -l <span class="s1">&#39;uprobe:/usr/lib/x86_64-linux-gnu/libc.so.6:*&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 查询USDT</span>
</span></span><span class="line"><span class="cl">bpftrace -l <span class="s1">&#39;usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:*&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ol>
<p>uprobe is file-based. When a function in a file is traced, by default all processes that use this file are staked, unless the process PID is filtered.</p>
<p>The above is a statically compiled language, which is similar to the kernel trace in that the application symbolic information can be stored in the ELF binary or as a separate file in the debug file, while the kernel symbolic information can be stored in the kernel binary, but also as /proc/kallsyms and /sys/kernel/debug, etc. to user space.</p>
<p>For non-statically compiled languages, there are two main types.</p>
<ol>
<li>
<p>Interpretive Languages</p>
<p>Using a trace point query method similar to compiled language applications, querying their uprobe and USDT trace points at the interpreter level, how to correlate the interpreter level behavior with the application behavior needs to be analyzed by experts of the language in question.</p>
</li>
<li>
<p>Just-In-Time Compiled Languages</p>
<p>Similar to interpreted programming languages, uprobe and USDT traces can only be used on just-in-time compilers to obtain the final application function information from the just-in-time compiler&rsquo;s trace point parameters. Finding the relationship between the trace points of a live compiler and the application runtime requires an expert in the language in question.</p>
</li>
</ol>
<p>See BCC&rsquo;s application tracing, user process tracing, which is essentially a breakpoint to execute uprobe handlers. Although the kernel community has done a lot of performance tuning for BPF, tracing user-state functions (especially high-frequency functions like lock contention and memory allocation) can have a significant performance overhead. Therefore, we should try to avoid tracking high-frequency functions when using uprobe.</p>
<blockquote>
<p>For details on how to use the above information, please refer to: <a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#events--arguments">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#events&ndash;arguments</a></p>
</blockquote>
<h3 id="related-issues-and-staking-points">Related Issues and Staking Points</h3>
<p>An ideal state is that all issues are clear should be observed those staking points, but this requires technical staff on the end-to-end software stack details are very thorough understanding of a more reasonable approach is the rule of two or eight, the software stack data flow of the most core 80% of the pulse to capture, to ensure that problems will be found in this vein can be. At this point and then use the kernel stack and user stack to view the specific call stack can be found in the core of the problem, for example, found that the network is losing packets, but do not know why, at this time we know that the network packet loss will definitely call kfree_skb kernel function, then we can pass.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo bpftrace -e <span class="s1">&#39;kprobe:kfree_skb /comm==&#34;&lt;your comm&gt;&#34;/ {printf(&#34;kstack: %s\n&#34;, kstack);}&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Discover the call stack of the function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">kstack: kfree_skb+1 udpv6_destroy_sock+66 sk_common_release+34 udp_lib_close+9 inet_release+75 inet6_release+49 __sock_release+66 sock_close+21 __fput+159 ____fput+14 task_work_run+103 exit_to_user_mode_loop+411 exit_to_user_mode_prepare+187 syscall_exit_to_user_mode+23 do_syscall_64+110 entry_SYSCALL_64_after_hwframe+68
</span></span></code></pre></td></tr></table>
</div>
</div><p>Then you can go back to the functions above and see exactly which line they were called under what conditions and you will be able to locate the problem. This method can not only locate the problem, but can also be used to deepen the understanding of kernel calls, for example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">bpftrace -e <span class="s1">&#39;tracepoint:net:* { printf(&#34;%s(%d): %s %s\n&#34;, comm, pid, probe, kstack()); }&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>All network-related trace points and their call stacks can be viewed.</p>
<h2 id="what-is-the-principle-of-ebpf-implementation">What is the principle of eBPF implementation?</h2>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images1/2022/06/17/b7c418cbc91f48c7a55d61e9483894b2.png" alt="eBPF"></p>
<h3 id="5-modules">5 modules</h3>
<p>The eBPF is collaborated in the kernel by 5 main modules.</p>
<ol>
<li>
<p>BPF Verifier
Ensures the security of eBPF programs. The verifier creates the instructions to be executed as a directed acyclic graph (DAG) to ensure that the program does not contain unreachable instructions; then it simulates the execution of the instructions to ensure that no invalid instructions are executed. Here we learn from talking to individual students that the verifier here does not guarantee 100% security, so for all BPF programs, strict monitoring and review is still needed.</p>
</li>
<li>
<p>BPF JIT
Compiles eBPF bytecode into native machine instructions for more efficient execution in the kernel.</p>
</li>
<li>
<p>A memory module consisting of multiple 64-bit registers, a program counter and a 512-byte stack
Used to control the operation of eBPF programs, save stack data, incoming and outgoing parameters.</p>
</li>
<li>
<p>BPF Helpers (helper functions)
A set of functions is provided for eBPF programs to interact with other modules in the kernel. These functions are not available to any eBPF program; the exact set of functions available is determined by the BPF program type. Note that all changes to incoming and outgoing parameters inside eBPF must conform to the BPF specification, except for changes to local variables, which should be done using BPF Helpers, and cannot be modified if not supported by BPF Helpers.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">bpftool feature probe
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above command allows you to see which BPF Helpers can be run for different types of eBPF programs.</p>
</li>
<li>
<p>BPF Map &amp; context
is used to provide large blocks of storage that can be accessed by user space programs to control the running state of eBPF programs.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">bpftool feature probe <span class="p">|</span> grep map_type
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>The above command allows you to see which types of maps are supported by the system.</p>
<h3 id="3-actions">3 actions</h3>
<p>Let&rsquo;s start with the important system call bpf.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">int bpf<span class="o">(</span>int cmd, union bpf_attr *attr, unsigned int size<span class="o">)</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here cmd is the key, attr is the parameter of cmd, size is the size of the parameter, so the key is to see which cmd is.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">// 5.11内核
</span></span><span class="line"><span class="cl">enum bpf_cmd <span class="o">{</span>
</span></span><span class="line"><span class="cl">BPF_MAP_CREATE,  
</span></span><span class="line"><span class="cl">BPF_MAP_LOOKUP_ELEM,  
</span></span><span class="line"><span class="cl">BPF_MAP_UPDATE_ELEM,  
</span></span><span class="line"><span class="cl">BPF_MAP_DELETE_ELEM, 
</span></span><span class="line"><span class="cl">BPF_MAP_GET_NEXT_KEY, 
</span></span><span class="line"><span class="cl">BPF_PROG_LOAD,
</span></span><span class="line"><span class="cl">BPF_OBJ_PIN,
</span></span><span class="line"><span class="cl">BPF_OBJ_GET,  
</span></span><span class="line"><span class="cl">BPF_PROG_ATTACH, 
</span></span><span class="line"><span class="cl">BPF_PROG_DETACH,  
</span></span><span class="line"><span class="cl">BPF_PROG_TEST_RUN,
</span></span><span class="line"><span class="cl">BPF_PROG_GET_NEXT_ID,  
</span></span><span class="line"><span class="cl">BPF_MAP_GET_NEXT_ID, 
</span></span><span class="line"><span class="cl">BPF_PROG_GET_FD_BY_ID, 
</span></span><span class="line"><span class="cl">BPF_MAP_GET_FD_BY_ID,
</span></span><span class="line"><span class="cl">BPF_OBJ_GET_INFO_BY_FD, 
</span></span><span class="line"><span class="cl">BPF_PROG_QUERY, 
</span></span><span class="line"><span class="cl">BPF_RAW_TRACEPOINT_OPEN, 
</span></span><span class="line"><span class="cl">BPF_BTF_LOAD, 
</span></span><span class="line"><span class="cl">BPF_BTF_GET_FD_BY_ID, 
</span></span><span class="line"><span class="cl">BPF_TASK_FD_QUERY, 
</span></span><span class="line"><span class="cl">BPF_MAP_LOOKUP_AND_DELETE_ELEM, 
</span></span><span class="line"><span class="cl">BPF_MAP_FREEZE, 
</span></span><span class="line"><span class="cl">BPF_BTF_GET_NEXT_ID, 
</span></span><span class="line"><span class="cl">BPF_MAP_LOOKUP_BATCH, 
</span></span><span class="line"><span class="cl">BPF_MAP_LOOKUP_AND_DELETE_BATCH, 
</span></span><span class="line"><span class="cl">BPF_MAP_UPDATE_BATCH,  
</span></span><span class="line"><span class="cl">BPF_MAP_DELETE_BATCH,  
</span></span><span class="line"><span class="cl">BPF_LINK_CREATE,
</span></span><span class="line"><span class="cl">BPF_LINK_UPDATE, 
</span></span><span class="line"><span class="cl">BPF_LINK_GET_FD_BY_ID,
</span></span><span class="line"><span class="cl">BPF_LINK_GET_NEXT_ID, 
</span></span><span class="line"><span class="cl">BPF_ENABLE_STATS, 
</span></span><span class="line"><span class="cl">BPF_ITER_CREATE,
</span></span><span class="line"><span class="cl">BPF_LINK_DETACH,
</span></span><span class="line"><span class="cl">BPF_PROG_BIND_MAP,
</span></span><span class="line"><span class="cl"><span class="o">}</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The most core is PROG, MAP related cmd, which is program loading and mapping processing.</p>
<ol>
<li>
<p>Program loading</p>
<p>Calling the BPF_PROG_LOAD cmd loads the BPF program into the kernel, but the eBPF program does not run there all the time after startup like a regular thread, it needs events to trigger before it executes. These events include system calls, kernel trace points, calls to kernel functions and user state functions to exit, network events, and so on, so a 2nd action is required.</p>
</li>
<li>
<p>Binding events</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">b.attach_kprobe<span class="o">(</span><span class="nv">event</span><span class="o">=</span><span class="s2">&#34;xxx&#34;</span>, <span class="nv">fn_name</span><span class="o">=</span><span class="s2">&#34;yyy&#34;</span><span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The above is to bind a specific event to a specific BPF function, the actual implementation principle is as follows.</p>
<ol>
<li>With the help of the bpf system call, the returned file descriptor is remembered after the BPF program is loaded.</li>
<li>The event number of the corresponding function type is known through the attach operation.</li>
<li>Call perf_event_open to create a performance monitoring event based on the return value of attach.</li>
<li>Bind the BPF program to the performance monitoring event by ioctl&rsquo;s PERF_EVENT_IOC_SET_BPF command.</li>
</ol>
</li>
<li>
<p>Mapping operations</p>
<p>Through the MAP-related cmd, the MAP additions and deletions are controlled, and then the user state interacts with the kernel state based on that MAP.</p>
</li>
</ol>
<h2 id="the-current-state-of-development-of-ebpf">The current state of development of eBPF?</h2>
<h3 id="kernel-support">Kernel support</h3>
<p>Recommendation &gt;= 4.14</p>
<h3 id="ecology">Ecology</h3>
<p>The bottom-up ecology of eBPF is as follows.</p>
<ol>
<li>
<p>Infrastructure</p>
<p>Support the development of eBPF infrastructure capabilities.</p>
<ul>
<li>Linux Kernal</li>
<li>LLVM</li>
</ul>
</li>
<li>
<p>Development toolset</p>
<p>It is mainly used to load, compile and debug eBPF programs, and there are different development toolsets for different languages.</p>
<ul>
<li>
<p>Go</p>
<ul>
<li><a href="https://github.com/cilium/ebpf">https://github.com/cilium/ebpf</a></li>
<li><a href="https://github.com/aquasecurity/libbpfgo">https://github.com/aquasecurity/libbpfgo</a></li>
</ul>
</li>
<li>
<p>C/C++</p>
<ul>
<li><a href="https://github.com/libbpf/libbpf">https://github.com/libbpf/libbpf</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>eBPF Application</p>
<ul>
<li>bcc (<a href="https://github.com/iovisor/bcc">https://github.com/iovisor/bcc</a>)</li>
</ul>
<p>Provides a set of development tools and scripts.</p>
<ul>
<li>bpftrace（<a href="https://github.com/iovisor/bpftrace">https://github.com/iovisor/bpftrace</a>）</li>
</ul>
<p>Based on bcc, a scripting language is provided.</p>
<ul>
<li>cilium（<a href="https://github.com/cilium/cilium">https://github.com/cilium/cilium</a>）</li>
</ul>
<p>Network Optimization and Security</p>
<ul>
<li>Falco（<a href="https://github.com/falcosecurity/falco">https://github.com/falcosecurity/falco</a>）</li>
</ul>
<p>Network Security</p>
<ul>
<li>Katran（<a href="https://github.com/facebookincubator/katran">https://github.com/facebookincubator/katran</a>）</li>
</ul>
<p>High-performance 4-tier load balancing</p>
<ul>
<li>Hubble（<a href="https://github.com/cilium/hubble">https://github.com/cilium/hubble</a>）</li>
</ul>
<p>Observable</p>
<ul>
<li>Kindling（<a href="https://github.com/CloudDectective-Harmonycloud/kindling">https://github.com/CloudDectective-Harmonycloud/kindling</a>）</li>
<li>Pixie（<a href="https://github.com/pixie-io/pixie">https://github.com/pixie-io/pixie</a>）</li>
<li>kubectl trace（<a href="https://github.com/iovisor/kubectl-trace">https://github.com/iovisor/kubectl-trace</a>）</li>
</ul>
<p>Scheduling bpftrace script</p>
<ul>
<li>L3AF（<a href="https://github.com/l3af-project/l3afd">https://github.com/l3af-project/l3afd</a>）</li>
</ul>
<p>Platform for launching and managing eBPF programs in a distributed environment</p>
<ul>
<li>ply（<a href="https://github.com/iovisor/ply">https://github.com/iovisor/ply</a>）</li>
</ul>
<p>Dynamic linux tracing</p>
<ul>
<li>Tracee（<a href="https://github.com/aquasecurity/tracee">https://github.com/aquasecurity/tracee</a>）</li>
</ul>
</li>
<li>
<p>Tracking the ecological website</p>
<ul>
<li><a href="https://ebpf.io/projects">https://ebpf.io/projects</a></li>
<li><a href="https://github.com/zoidbergwill/awesome-ebpf">https://github.com/zoidbergwill/awesome-ebpf</a></li>
</ul>
</li>
</ol>
<h2 id="write-at-the-end">Write at the end</h2>
<h3 id="the-prerequisite-for-using-ebpf-well-is-the-understanding-of-the-software-stack">The prerequisite for using eBPF well is the understanding of the software stack</h3>
<p>Through the above introduction, I believe you have enough understanding of eBPF. eBPF provides only a framework and mechanism, the core still requires people who use eBPF to understand the software stack and find the right insertion point that can be associated with the application problem.</p>
<h3 id="ebpfs-killer-feature-is-full-coverage-non-intrusive-programmable">eBPF&rsquo;s killer feature is full coverage, non-intrusive, programmable</h3>
<ol>
<li>
<p>Full coverage
Kernel, full coverage of application staking points.</p>
</li>
<li>
<p>Non-intrusive
No need to modify any of the hooked code.</p>
</li>
<li>
<p>Programmable
Dynamic distribution of eBPF programs, dynamic execution of instructions at the edge, dynamic aggregation analysis.</p>
</li>
</ol>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/ebpf/">Ebpf</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-06/reactive-combine/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">From Reactive programming to Combine Practices</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-06/intel-amd-vulnerabilities/">
            <span class="next-text nav-default">New vulnerabilities found in Intel, AMD CPUs! Hackers can steal encryption keys through &#34;Hertzbleed&#34; attack｜x86 CPU power saving mode are hit</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
