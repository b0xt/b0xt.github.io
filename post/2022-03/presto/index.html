<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Open Source Distributed Query Engine - Presto - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Presto is Facebook&#39;s open source MPP (Massive Parallel Processing) SQL engine, which derives its idea from a parallel database called Volcano, which proposes a model for parallel execution of SQL that is designed to be used exclusively for high-speed, real-time data analysis. Presto is a SQL computation engine, separating the computation and storage layers, which does not store data and enables access to various data sources (Storage) through the Connector SPI." /><meta name="keywords" content="presto" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-03/presto/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Open Source Distributed Query Engine - Presto" />
<meta property="og:description" content="Presto is Facebook&#39;s open source MPP (Massive Parallel Processing) SQL engine, which derives its idea from a parallel database called Volcano, which proposes a model for parallel execution of SQL that is designed to be used exclusively for high-speed, real-time data analysis. Presto is a SQL computation engine, separating the computation and storage layers, which does not store data and enables access to various data sources (Storage) through the Connector SPI." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-03/presto/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-29T22:47:02+08:00" />
<meta property="article:modified_time" content="2022-03-29T22:47:02+08:00" />

<meta itemprop="name" content="Open Source Distributed Query Engine - Presto">
<meta itemprop="description" content="Presto is Facebook&#39;s open source MPP (Massive Parallel Processing) SQL engine, which derives its idea from a parallel database called Volcano, which proposes a model for parallel execution of SQL that is designed to be used exclusively for high-speed, real-time data analysis. Presto is a SQL computation engine, separating the computation and storage layers, which does not store data and enables access to various data sources (Storage) through the Connector SPI."><meta itemprop="datePublished" content="2022-03-29T22:47:02+08:00" />
<meta itemprop="dateModified" content="2022-03-29T22:47:02+08:00" />
<meta itemprop="wordCount" content="3358">
<meta itemprop="keywords" content="presto," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Open Source Distributed Query Engine - Presto"/>
<meta name="twitter:description" content="Presto is Facebook&#39;s open source MPP (Massive Parallel Processing) SQL engine, which derives its idea from a parallel database called Volcano, which proposes a model for parallel execution of SQL that is designed to be used exclusively for high-speed, real-time data analysis. Presto is a SQL computation engine, separating the computation and storage layers, which does not store data and enables access to various data sources (Storage) through the Connector SPI."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Open Source Distributed Query Engine - Presto</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-29 22:47:02 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3358 words </span>
          <span class="more-meta"> 16 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#what-is-presto">What is Presto?</a></li>
        <li><a href="#prestos-architecture">Presto&rsquo;s architecture</a>
          <ul>
            <li><a href="#architecture">Architecture</a></li>
            <li><a href="#query-execution-process">Query execution process</a></li>
            <li><a href="#data-model">Data model</a></li>
            <li><a href="#plugins">Plugins</a></li>
            <li><a href="#memory-management">Memory management</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="what-is-presto">What is Presto?</h2>
<p>Presto is Facebook&rsquo;s open source MPP (Massive Parallel Processing) SQL engine, which derives its idea from a parallel database called Volcano, which proposes a model for parallel execution of SQL that is designed to be used exclusively for high-speed, real-time data analysis. Presto is a SQL computation engine, separating the computation and storage layers, which does not store data and enables access to various data sources (Storage) through the Connector SPI.</p>
<p>Hadoop provides a complete solution for big data storage and computation, but it uses the MapReduce computing framework, which is only suitable for offline and batch computation and cannot meet the performance requirements of fast real-time Ad-Hoc (instant analysis) query computation. However, as more and more data becomes available, a simple data query using Hive can take minutes to hours, which clearly does not meet the needs of interactive queries. Comparison with Hive.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/c8372bc31e864109946d15608a86897c.png" alt="Presto vs Hive"></p>
<p>The above diagram shows the difference between MapReduce and Presto execution process. Each operation of MR either needs to write to disk or wait for the previous stage to finish before starting execution, while Presto converts SQL into multiple stages, each stage is executed by multiple tasks, and each task will be divided into multiple splits. All the tasks are allowed in parallel, and the data is executed in pipeline between stages, and the data is transferred to and from the network in the form of Memory-to-Memory, without disk io operations. This is the decisive reason why Presto&rsquo;s performance is many times faster than Hive.</p>
<p>Presto follows a common Master-Slave architecture, with one Coordinator and multiple Workers, and the Coordinator is responsible for parsing SQL statements, generating execution plans, and distributing execution tasks to the Worker nodes for execution; the Worker nodes are responsible for actually executing the query tasks. Presto provides a set of Connector interfaces for reading meta information and raw data, and Presto has a variety of built-in data sources, such as Hive, MySQL, Kudu, Kafka, etc. At the same time, Presto&rsquo;s extension mechanism allows customizing the Connector to enable querying of custom data sources. If a Hive Connector is configured, a Hive MetaStore service needs to be configured to provide Hive meta information to Presto, and the Worker nodes interact with HDFS through the Hive Connector to read raw data.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/e23f2eb203e9439e95537e865998d090.png" alt="Presto"></p>
<p>Advantages of Presto.</p>
<ul>
<li>Ad-hoc, expect query times in seconds or minutes</li>
<li>10 times faster than Hive</li>
<li>Support multiple data sources, such as Hive, Kafka, MySQL, MonogoDB, Redis, JMX, etc., or you can implement your own Connector</li>
<li>Client Protocol: HTTP+JSON, support various languages(Python, Ruby, PHP, Node.js Java)</li>
<li>JDBC/ODBC connection support</li>
<li>ANSI SQL, support for window functions, joins, aggregates, complex queries, etc.</li>
</ul>
<p>Disadvantages of Presto.</p>
<ul>
<li>No fault tolerance; when a Query is distributed to multiple Workers to execute, when one Worker fails because of various reasons, then the Master will sense that the entire Query also failed, and Presto does not have a retry mechanism, so the user side needs to implement a retry mechanism.</li>
<li>Memory Limitations for aggregations, huge joins; for example, multi-table joins require a lot of memory, and since Presto is a pure memory calculation, Presto does not dump the results to disk when there is not enough memory, so the query also fails, but the latest version of Presto already supports Write to disk operation.</li>
<li>MPP (Massively Parallel Processing) architecture; this can not be said to be a disadvantage, because the MPP architecture is the solution to a large amount of data analysis, but its disadvantages are also very obvious, if we access the Hive data source, if one of the Worke due to load problems, data processing is very slow, then the entire query will be affected, because the upstream needs to wait for the upstream results.</li>
</ul>
<h2 id="prestos-architecture">Presto&rsquo;s architecture</h2>
<h3 id="architecture">Architecture</h3>
<p>The Presto query engine is a Master-Slave architecture, where the Coordinator is the master and the worker is the slave. A Presto cluster consists of a Coordinator node, a Discovery Server node (usually embedded in the Coordinator node), and multiple Worker nodes. Among them, the Coordinator is responsible for receiving query requests, parsing SQL statements, generating execution plans, scheduling tasks to Worker nodes for execution, and worker management; Worker nodes are work nodes, responsible for actually executing the query task Task.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/b5ac995946344978a6b8335b2bb3f159.png" alt="Presto&amp;rsquo;s architecture"></p>
<p>Worker node starts and registers with Discovery Server service; Coordinator obtains the Worker node from Discovery Server that can work properly.</p>
<h3 id="query-execution-process">Query execution process</h3>
<p>The overall query process is.</p>
<ul>
<li>Client sends a query request using HTTP protocol.</li>
<li>Discovery Server discovers the available Server through Discovery Server.</li>
<li>Coordinator builds the query plan (Connector plugin provides Metadata)</li>
<li>Coordinator sends a task to workers</li>
<li>Worker reads data via Connector plugin</li>
<li>Worker executes the task in memory (Worker is a purely in-memory compute engine)</li>
<li>Worker returns the data to the Coordinator, and then Responds Client afterwards</li>
</ul>
<p>SQL execution flow.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/ee95cee2667e4c1ca09953b689011107.png" alt="Presto SQL execution flow."></p>
<p>When the Coordinator receives a Query, the SQL execution process is as shown in the above figure. the SQL is parsed into AST (Abstract Syntax Tree) by Anltr3, and then the original data Metadata information is obtained through the Connector. The logical plan is generated, and then the distribution plan and execution plan are generated in turn. In the execution plan, we need to go to Discovery to get the list of available nodes, and then according to a certain policy, these plans are distributed to the specified Worker machines, which are then executed separately.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/3d2fc0e0a6ba4323a96d7256871cf104.png" alt="Presto proccess"></p>
<p>Presto contains three types of roles, coordinator, discovery, and worker. coordinator is responsible for query parsing and scheduling. discovery is responsible for cluster heartbeat and role management. worker is responsible for performing computations.</p>
<ul>
<li>The query submitted by presto-cli is actually an http POST request. After the query request is sent to the coordinator, it undergoes lexical and syntactic parsing to generate an abstract syntax tree that describes the execution of the query.</li>
<li>The execution plan compiler, based on the abstract syntax tree, expands the structure represented by the syntax tree into a tree-like execution structure consisting of individual operations, called a logical execution plan.</li>
<li>The original logical execution plan, which directly represents the operations expected by the user, may not be the best performance. At this point, the logical execution plan already includes the map-reduce operation and the transfer of intermediate computation results across machines.</li>
<li>The scheduler obtains the data distribution from the data meta, constructs the split, and schedules the corresponding execution plan to the corresponding worker with the logical execution plan.</li>
<li>On the worker, the logical execution plan generates the physical execution plan, and according to the logical execution plan, it generates the execution bytecode and the operator list. operator is handed over to the execution driver to complete the computation.</li>
</ul>
<h4 id="abstract-syntax-tree">Abstract Syntax Tree</h4>
<p>A tree structure generated by the syntax parser based on SQL, parsed to describe the execution process of SQL. In the following, the SQL <code>select avg(response_size) as a , client_address from localfile.logs.http_request_log group by client_address order by a desc limit 10</code> is used as example to describe.</p>
<p>The abstract syntax tree describes the query in terms of Query, with a hierarchy representing the subqueries at different levels. Each level of query contains several key elements: select, from,where,group by,having,order by,limit. where from can be a subquery or a table.</p>
<p>A typical abstract syntax tree.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/5958b3eca8d142fcb8820d8edf9f288e.png" alt="A typical abstract syntax tree"></p>
<h4 id="generate-logic-execution-plan">Generate logic execution plan</h4>
<p>The abstract syntax tree tree, which describes the most primitive user requirements. The information described by the abstract syntax tree is not optimal in terms of execution efficiency and the execution operations are too complex. The abstract syntax tree needs to be transformed into an execution plan. The execution plan is divided into two categories, one is the logical execution plan and the other is the physical execution plan. Logical execution plans, which describe execution in a tree structure, where each node is the simplest operation. The physical execution plan, which generates bytecode based on the logical execution plan, is handed over to the driver for execution.</p>
<p>The process of transcription into a logical execution plan, including transcription and optimization. The abstract syntax tree is transcribed into a node tree consisting of simple operations, and then all aggregate computation nodes in the tree are transcribed into map-reduce form. And insert Exchange nodes in the middle of map-reduce nodes. Then, a series of optimizations are performed to push down some nodes that can accelerate the computation in advance and merge the nodes that can be merged.</p>
<p>Finally, the logical execution plan is divided into different segments (fragament) according to the Exchange nodes, which represent the execution plans of different phases. In scheduling, the execution is scheduled according to the fragment.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="k">avg</span><span class="p">(</span><span class="n">response_size</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">client_address</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">localfile</span><span class="p">.</span><span class="n">logs</span><span class="p">.</span><span class="n">http_request_log</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">client_address</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">DESC</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">10</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The execution logic of the above SQL.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/0405cf97fad04b908a5dd20d9a6a2fb1.png" alt="execution logic of the SQL"></p>
<p>As you can see from the execution plan, the agg nodes are split into two steps, partial and final.</p>
<h4 id="scheduling-execution-plan-to-machines">Scheduling execution plan to machines</h4>
<p>Scheduling involves two issues, first, which machines a certain fragment is assigned to be executed by, and second, how the computation result of a certain fragment is output to the downstream fragment.</p>
<p>In scheduling, it is necessary to specify for each fragment to which machines it is assigned. In terms of scheduling, there are three types of fragment</p>
<ul>
<li>One type is the source type, where the original data storage location determines the scheduling machine of the fragment, how many source nodes are there? If network-topology=flat is specified in the configuration, try to select the machine where the split is located.</li>
<li>Generally, only the final output node is assigned one machine, and the intermediate computation results are assigned to multiple machines. The number of allocated machines is determined by the configuration hash_partition_count. The selection of machines is random.</li>
<li>One type is SINGLE type, only one machine, mainly used for aggregating results, and one machine is randomly selected.</li>
</ul>
<p>For the output of the computation result, there are also various ways, depending on the number of machines in the downstream node.</p>
<ul>
<li>If there are multiple machines in the downstream node, for example, the intermediate result of group by, the hash is calculated according to the key of group by, and a downstream machine is selected according to the hash value. For non-group by calculation, it will randomly select or round robin.</li>
<li>If there is only one machine in the downstream node, it will be output to this machine.</li>
</ul>
<p>In the following figure, for example, fragment 2 is a source type fragment with three splits, so three machines are assigned. Because this layer of computation is group by aggregation, the output is computed according to the key of group by to calculate the hash and select one of the downstream machines for output.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/03e89c85df6341c79c0faacea5847d06.png" alt="fragment"></p>
<p>The tasks before scheduling are done in the coordinator, and after scheduling is done, the tasks are sent to the worker for execution afterwards.</p>
<h4 id="generate-physical-execution-plan">Generate physical execution plan</h4>
<p>After the logical execution plan fragment is sent to the machine, it is transcribed into an operator list in the form of a node tree and dynamically compiled to generate bytecode according to the logical code. Dynamic generation of bytecode, mainly using the compilation principle.</p>
<ul>
<li>Expanding the loop</li>
<li>Directly calling the right function to be used according to the type of data column to reduce branch jumping statements.</li>
</ul>
<p>These means will make better use of the CPU pipeline.</p>
<h4 id="execution-driver">Execution Driver</h4>
<p>The physical execution plan constructs the generated Operator list and hands it to the Driver for execution. Exactly which data is computed is determined by the loaded Split.</p>
<p>Operator list processes data in a serial form, and the result of the previous operator is used as input for the next result. For operators of type source, a new copy of data is fetched with each call; for operators of type Aggregate, the output result is fetched only after all previous operators are finished. only after all previous operators are finished.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/ff6f30edc50e41ca89be84372f97d771.png" alt="data proccess"></p>
<h4 id="aggregate-computation">Aggregate Computation</h4>
<p>The generated execution plans have the aggregation computation split into two steps, Map and Reduce.</p>
<p>There are two types of Operators for aggregation computation, AggregationOperator and HashAggregationOperator.</p>
<p>AggregationOperator computes all rows and updates the results to a single location; HashAggregationOperator uses the hash value of a column as the key of the hash table, and only rows with the same key will save the results together for the group by class.</p>
<p>Aggregation calculations are to be executed in the form of Map-Reduce.</p>
<p>The functions provided by the aggregation calculations have to provide four interfaces, with two inputs and two outputs, respectively:</p>
<ul>
<li>Accepts raw data as input.</li>
<li>Accepts input from intermediate results.</li>
<li>Outputs the intermediate results.</li>
<li>Outputs the final result.</li>
</ul>
<p>1+3 constitutes a Map operation 2+4 constitutes a Reduce operation.</p>
<p>Take Avg as an example.</p>
<ul>
<li>Map phase input 1,2,3,4</li>
<li>Map truncated output 10,4 represents Sum and Count respectively</li>
<li>Reduce input 10,4</li>
<li>Reduce output final average 5</li>
</ul>
<p>We modified the Presto system to enable Presto to provide caching functionality, which is a layer of computation added in the middle of MapReduce to accept intermediate result inputs and intermediate result outputs.</p>
<h4 id="functions">Functions</h4>
<p>There are two types of functions, namely Scaler and Aggregate functions</p>
<ul>
<li>Scaler function provides data conversion processing, does not save the state, an input to produce an output.</li>
<li>Aggregate function provides data aggregation processing, using existing state + input to produce new state.</li>
</ul>
<h3 id="data-model">Data model</h3>
<p>Presto takes a three-tier table structure.</p>
<ul>
<li>catalog corresponds to a certain type of data source, such as data from hive, or data from mysql</li>
<li>schema corresponds to the database in mysql</li>
<li>table corresponds to a table in mysql</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/186d229f8aab43dd8e09ed77b6f5357a.png" alt="Data model"></p>
<p>Presto&rsquo;s storage units include.</p>
<ul>
<li>Page: A collection of multiple rows of data, containing multiple columns of data, with only logical rows provided internally, actually stored in columnar format.</li>
<li>Block: a column of data, depending on the type of data, usually take a different encoding, understanding these encoding methods, help their own storage system to interface with presto.</li>
</ul>
<p>Different types of blocks.</p>
<ul>
<li>array type block, applied to fixed-width types, such as int, long, double. block consists of two parts
<ul>
<li>boolean valueIsNull[] Indicates whether each row has a value.</li>
<li>T values[] The specific value of each row.</li>
</ul>
</li>
<li>Variable-width block, applied to string-like data, consists of three parts of information
<ul>
<li>Slice : A string with all rows of data stitched together.</li>
<li>int offsets[] : The starting cheap position of each row of data. The length of each line is equal to the starting bargain of the next line minus the starting bargain of the current line.</li>
<li>boolean valueIsNull[] : Indicates whether a row has a value. If there is a row with no value, then the cheap amount of this row is equal to the offset of the previous row.</li>
</ul>
</li>
<li>Fixed-width string type block, where all rows of data are stitched together into one long Slice, with each row having a fixed length.</li>
<li>Dictionary block: For some columns, the distinct value is less, suitable for saving using dictionary. There are two main components.
<ul>
<li>dictionary, which can be any type of block (even a nested dictionary block), and each row in the block is sorted and numbered in order.</li>
<li>int ids[] indicates the number of the value in the dictionary corresponding to each row of data. When searching, first find the id of a row, then go to the dictionary to get the real value.</li>
</ul>
</li>
</ul>
<h3 id="plugins">Plugins</h3>
<p>Once you understand the data model of presto, you can write plugins to presto to interface to your own storage system. presto provides a set of connector interfaces to read metadata from custom storage, as well as column storage data. Let&rsquo;s first look at the basic concepts of connector.</p>
<ul>
<li>ConnectorMetadata: Manage table metadata, table metadata, partition and other information. When processing a request, the meta information needs to be fetched in order to confirm the location of the read data. presto will pass in the filter condition in order to reduce the range of the read data. The meta information can be read from disk or cached in memory.</li>
<li>ConnectorSplit: A collection of data processed by an IO Task, which is the unit of scheduling. A split can correspond to one partition, or multiple partitions.</li>
<li>SplitManager : Constructs a split based on the meta of the table.</li>
<li>SlsPageSource : Reads 0 or more pages from disk for the calculation engine based on the information of the split and the information of the columns to be read.</li>
</ul>
<p>Plugins can help developers add these features.</p>
<ul>
<li>Dock to your own storage system.</li>
<li>Add custom data types.</li>
<li>Add custom processing functions.</li>
<li>Custom permission control.</li>
<li>Custom resource control.</li>
<li>Add query event handling logic.</li>
</ul>
<p>Presto provides a simple connector: the local file connector , which can be used as a reference for implementing your own connector, but the local file connector uses a cursor to traverse the data, i.e. a row of data, not a page. hive&rsquo;s connector implements three types of connectors, parquet connector, orc connector, and rc file connector.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/aa12cf696cd44a4b8bddd6f2662a1d76.png" alt="proccess"></p>
<h3 id="memory-management">Memory management</h3>
<p>Presto is an in-memory computing engine, so memory management must be fine-tuned to ensure orderly and smooth execution of queries, and partial starvation, deadlocks and other situations.</p>
<h4 id="memory-pooling">Memory pooling</h4>
<p>Presto uses a logical memory pool to manage different types of memory requirements.</p>
<p>Presto divides the entire memory into three memory pools, System Pool , Reserved Pool, and General Pool.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/78793f76c21a49fdb5964235bbef19a0.png" alt="Memory pooling"></p>
<ul>
<li>System Pool is reserved for system use, default is 40% of the memory space reserved for system use.</li>
<li>Reserved Pool and General Pool are used to allocate memory for query runtime.</li>
<li>Most of the queries use the general pool. The largest query uses the Reserved Pool, so the Reserved Pool is equal to the maximum amount of space used by a query running on a machine, which is 10% by default.</li>
<li>The General Pool has all the memory space except the System Pool and the General Pool.</li>
</ul>
<h4 id="why-memory-pools-are-used">Why memory pools are used</h4>
<p>System Pool is used for memory used by the system, for example, data is passed between machines and buffer is maintained in the memory, which is mounted under the system name.</p>
<p>So, why do you need reserved area memory? And is the reserved memory exactly equal to the maximum memory used by the query on the machine?</p>
<p>If there is no Reserved Pool, then when there are a lot of queries and they are almost running out of memory space, one of the more memory consuming queries starts running. But then there is no more memory space for this query to run, and the query keeps hanging, waiting for available memory. But after other small-memory queries are run, new small-memory queries are added. Since small memory queries take up little memory, it is easy to find available memory. In this case, the big memory query keeps hanging until it starves.</p>
<p>So in order to prevent this starvation, a space must be reserved for the large memory query to run. Every second, Presto picks out a query with the largest memory footprint and allows it to use the reserved pool to avoid running out of memory for that query.</p>
<h4 id="memory-management-1">Memory Management</h4>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/03/29/b39aa6a139cd45eb80145da1056e2d90.png" alt="Memory Management"></p>
<p>Presto memory management, in two parts:</p>
<ul>
<li>query memory management. query is divided into many tasks, each task will have a thread loop to get the state of the task, including the memory used by the task. The memory is aggregated into the memory used by the query. If the aggregated memory of a query exceeds a certain size, the query is forced to terminate.</li>
<li>Machine memory management. coordinator has a thread that regularly rotates through each machine to check the current state of machine memory.</li>
</ul>
<p>When the query memory and machine memory are aggregated, the coordinator selects a query that uses the most memory and assigns it to the Reserved Pool.</p>
<p>Memory management is managed by the coordinator, which makes a judgment every second to specify that a particular query can use reserved memory on all machines. So the question is, if the query is not running on a machine, isn&rsquo;t the memory reserved for that machine wasted? Why not pick out the largest task on a single machine and execute it. The reason is still deadlock, if the query, which enjoys reserved memory on other machines, is executed quickly. But if it is not the largest task on a machine, it will not be run and the query will not be finished.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/presto/">presto</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-03/go-http-keep-alive/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Understanding how the Go standard library http package handles keep-alive connections by example</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-03/java-spring-vulnerability/">
            <span class="next-text nav-default">Jdk9 may have a more serious vulnerability than log4j</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
