<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C&#43;&#43; Simple Dependency Injection - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Learn how to use C&#43;&#43;&#39;s static member variable initialization mechanism to implement a simple object auto-registration and dependency injection management framework." /><meta name="keywords" content="c&#43;&#43;, Dependency Injection" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-09/cpp-di/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="C&#43;&#43; Simple Dependency Injection" />
<meta property="og:description" content="Learn how to use C&#43;&#43;&#39;s static member variable initialization mechanism to implement a simple object auto-registration and dependency injection management framework." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-09/cpp-di/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-09-02T13:28:18+08:00" />
<meta property="article:modified_time" content="2022-09-02T13:28:18+08:00" />

<meta itemprop="name" content="C&#43;&#43; Simple Dependency Injection">
<meta itemprop="description" content="Learn how to use C&#43;&#43;&#39;s static member variable initialization mechanism to implement a simple object auto-registration and dependency injection management framework."><meta itemprop="datePublished" content="2022-09-02T13:28:18+08:00" />
<meta itemprop="dateModified" content="2022-09-02T13:28:18+08:00" />
<meta itemprop="wordCount" content="2081">
<meta itemprop="keywords" content="c&#43;&#43;," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43; Simple Dependency Injection"/>
<meta name="twitter:description" content="Learn how to use C&#43;&#43;&#39;s static member variable initialization mechanism to implement a simple object auto-registration and dependency injection management framework."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C&#43;&#43; Simple Dependency Injection</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-09-02 13:28:18 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2081 words </span>
          <span class="more-meta"> 10 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-preface">1 Preface</a></li>
        <li><a href="#2-code-explanation">2 Code Explanation</a></li>
        <li><a href="#3-static-variable-life-cycle">3 static variable life cycle</a></li>
        <li><a href="#4-conclusion">4 Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="1-preface">1 Preface</h2>
<p>Some time ago, I was looking at the code of an old product, which was a mixed C/C++ code, and the code was full of global variables and used extern references to external global variables. The problem was that since there were dependencies between classes, if all dependencies were passed in through the constructor method, it would lead to a complex construction of the whole object dependency graph. For older code, using global variables + extern references can be a simple and brutal way to insert new call relationships to be added, but it also brings code corruption.</p>
<p>In our division&rsquo;s new C++ Fusion programming specification it is mentioned that</p>
<p>References to external function interfaces and variables by means of declarations are prohibited.</p>
<blockquote>
<p>You can only use interfaces provided by other modules or files by including header files. The use of external function interface variables by declaration can easily lead to inconsistent declaration and definition when the external interface is changed. Also this implicit dependency can easily lead to architectural corruption.</p>
</blockquote>
<p>Avoid the use of global variables (excerpt).</p>
<blockquote>
<p>The use of global variables can lead to data coupling between business code and global variables. The initialization order of global variables as well as global constants in different compilation units is not strictly defined, and it is necessary to pay attention to whether their initialization has interdependencies when using them.</p>
</blockquote>
<p>A complete application is composed of a set of objects that collaborate with each other, and the developer has to focus on how to make these objects work together to accomplish the required functionality with low coupling and high aggregation. If a framework comes out to help us create objects and manage the dependencies between these objects, then we only need to aggregate on the business logic. As a veteran of writing Java code at the same time, I understand that managing dependencies is one of the original design goals of Spring, and Java naturally has dynamic reflection capabilities that provide the basis for IoC framework implementation. But C++ doesn&rsquo;t have the introspection that reflection can have on classes, so how do you implement a simple IoC framework?</p>
<h2 id="2-code-explanation">2 Code Explanation</h2>
<p>Spring has various ways of dependency injection, let&rsquo;s implement a simple property dependency injection first. In C++ you want to achieve the following effect.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">INJECT_PTR</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">m_pA</span><span class="p">);</span> <span class="c1">// INJECT_PTR is a macro that automatically injects a pointer to A for B.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Obviously it is not realistic to achieve automatic injection of C++ objects without the help of some other auxiliary facilities. Referring to the Spring concept, the objects that can be injected must be beans, which are managed in the IoC framework and are called managed objects. So to achieve the above effect, two core issues have to be solved.</p>
<ul>
<li>how objects are automatically managed by the framework</li>
<li>how to discover the dependencies between objects and automatically inject the required objects</li>
</ul>
<p>Three core classes are abstracted.</p>
<ul>
<li><code>IObject</code>: is an interface that abstracts the object initialization (Init) and cleanup (Destroy) methods, equivalent to Spring&rsquo;s @PostConstruct and @PreDestroy capabilities.</li>
<li><code>ManagedObject</code>: is a base class , all the object types that can be managed by the framework to inherit it , it also implements the IObject interface.</li>
<li><code>Container</code>: is an object container that manages all instances of ManagedObject objects , support for calling all objects Init and Destroy methods to complete the object initialization and cleanup.</li>
</ul>
<p>Constraints.</p>
<ul>
<li>Subclasses that inherit from ManagedObject must have a default parameterless constructor method that supports calling parameterless constructors to create objects.</li>
<li>Dependencies can exist between objects of ManagedObject, but they are not constructed with sequential dependencies.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">IObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Init</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="o">~</span><span class="n">IObject</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ManagedObject</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The purpose of providing automatic object creation is achieved through static object initialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">static</span> <span class="k">struct</span> <span class="nc">AutoInit</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">DoNothing</span><span class="p">()</span> <span class="k">const</span> <span class="p">{}</span> <span class="c1">// This will be discussed later
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">explicit</span> <span class="nf">AutoInit</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">m_init</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Inject the callback function type of the member variable and register it with m_valInjectFuncs in the constructor method.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="nc">InjectFunction</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">InjectFunction</span><span class="p">(</span><span class="n">ManagedObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">m_valInjectFuncs</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">func</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">Init</span><span class="p">()</span> <span class="k">final</span><span class="p">;</span> <span class="c1">// Call the callback function of m_valInjectFuncs first, then call OnInit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">Destroy</span><span class="p">()</span> <span class="k">final</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnInit</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// Initialization by subclass override
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnDestroy</span><span class="p">()</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span> <span class="n">m_valInjectFuncs</span><span class="p">;</span> <span class="c1">// Store the callback function for injecting member variables
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Constainer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">Constainer</span> <span class="o">&amp;</span><span class="n">instance</span><span class="p">();</span> <span class="c1">// Single instance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">AddObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">IObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span> <span class="c1">// Registration management object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">IObject</span> <span class="o">*</span><span class="nf">GetObject</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// Get managed objects
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">InitAllObjects</span><span class="p">();</span> <span class="c1">// Initialize all objects and call the Init method of all objects
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="nf">DestroyAllOjects</span><span class="p">();</span>  <span class="c1">// Clean up all objects, call the Destroy method of all objects, and release all object memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">unorder_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">IObject</span> <span class="o">*&gt;</span> <span class="n">m_objs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>How to solve the first problem? This solution uses the feature of C++ that initialization of static member variables precedes the main method. Then you can have a static member object in ManagedObject, create generation in the static member object constructor for the class that inherits it, and then add the object pointer to Container management. If you want to know the specific type of the subclass, you need to use a template to give the subclass type to the static member object constructor method at compile time.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ManagedObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">AutoInit</span><span class="o">::</span><span class="n">AutoInit</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">T</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">();</span> <span class="c1">// Get the subclass type and call the parameterless constructor
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="k">auto</span> <span class="n">name</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">Container</span><span class="o">::</span><span class="n">Instance</span><span class="p">().</span><span class="n">AddOject</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span> <span class="c1">// Register to container
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">ManagedObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">AutoInit</span> <span class="n">ManagedObject</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">m_init</span><span class="p">;</span> <span class="c1">// Static object instantiation
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>To solve the second problem again, construct a temporary InjectFunction object in the macro INJECT_PTR, and in its constructor method, get the required object pointer from the container and assign it to a member variable.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define STR_CONCAT_(a, b) a##b
</span></span></span><span class="line"><span class="cl"><span class="cp">#define STR_CONCAT(a, b) STR_CONCAT_(a, b)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define INJECT_PTR(typeName, valName) typeName *valName;\
</span></span></span><span class="line"><span class="cl"><span class="cp">const InjectFunction STR_CONCAT(inject_, __LINE__) = {\
</span></span></span><span class="line"><span class="cl"><span class="cp">    this, [this]() {\
</span></span></span><span class="line"><span class="cl"><span class="cp">        this-&gt;m_init.DoNothing();\
</span></span></span><span class="line"><span class="cl"><span class="cp">        auto obj = Container::Instance().GetObject(typeid(typeName).name());\
</span></span></span><span class="line"><span class="cl"><span class="cp">        this-&gt;valName = dynamic_cast&lt;typeName *&gt;(obj);\
</span></span></span><span class="line"><span class="cl"><span class="cp">    }\
</span></span></span><span class="line"><span class="cl"><span class="cp">}; \
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>The logic of the above macro.</p>
<ul>
<li>Adds an <code>inject_{__LINE__}</code> member variable to the class, of type InjectFunction, with the variable name with the line number where it is located, and no conflicts.</li>
<li>Uses the C++11 way of initializing variables, calling the constructor method of InjectFunction, passing in this, and a lambda expression</li>
<li>DoNothing() in the lambda expression to solve the problem that template member variables must be called to take effect.</li>
<li>then get the registered object pointer according to the type, and assign a value to the variable valName to be injected</li>
</ul>
<p>Complete use of the following list.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ManagedObject</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ManagedObject</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">INJECT_PTR</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">m_pA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">OnInit</span><span class="p">()</span> <span class="n">overide</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">m_pA</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">C</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ManagedObject</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">private</span><span class="o">:</span> 
</span></span><span class="line"><span class="cl">    <span class="n">INJECT_PTR</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">m_pA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">INJECT_PTR</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">m_pB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">OnInit</span><span class="p">()</span> <span class="n">overide</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">m_pA</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">m_pB</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// static variables precede main method
</span></span></span><span class="line"><span class="cl"><span class="c1">// The static variable m_init of [A, B, C] is instantiated, and the creation of the A, B, C objects is completed and registered with Container, so the A, B, C objects are actually single instances.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Container</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">::</span><span class="n">InitAllObjects</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// InitAllObjects() --&gt; call Init of [A, B, C] --&gt; call m_valInjectFuncs callback method of [B, C] --&gt; dependency injection assignment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Container</span><span class="o">::</span><span class="n">Instance</span><span class="p">()</span><span class="o">::</span><span class="n">DestroyAllOjects</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="3-static-variable-life-cycle">3 static variable life cycle</h2>
<p>C++ static member variables, like normal static variables, allocate memory in a global data area in a memory partition and do not release it until the end of the program. This means that static member variables do not allocate memory with the creation of an object and do not release memory with the destruction of an object. In contrast, ordinary member variables allocate memory at object creation and release memory at object destruction.</p>
<p>C also has static variables, but the life cycle differs slightly from that of C++, with different initialization.</p>
<table>
<thead>
<tr>
<th></th>
<th>Global variables</th>
<th>Static variables of a file domain</th>
<th>Static member variables of a class</th>
<th>Static local variables</th>
</tr>
</thead>
<tbody>
<tr>
<td>C</td>
<td>Compile-time initialization</td>
<td>Compile-time initialization</td>
<td>N/A</td>
<td>Compile-time initialization</td>
</tr>
<tr>
<td>C++</td>
<td>before main execution</td>
<td>before main execution</td>
<td>before main execution</td>
<td>initialized on first execution of related code</td>
</tr>
</tbody>
</table>
<p>Going back to the scenario in the code explanation, classes A, B, and C in the example can also be placed in different h/cpp files and will be automatically constructed and registered with the container before main execution as long as the compile and link unit is added. If the constructor method of any of the classes is time consuming, it will cause the program to take longer to start.</p>
<p>Some notes.</p>
<ul>
<li>C++ static members belong to the class scope, but not to the class object and cannot be initialized in the class constructor</li>
<li>Static member variables must be initialized and can only be done outside the class body</li>
<li>Static local variables defined in a member function of a class are shared by all objects of the class when this member function is called</li>
<li>The destruction of static variables is managed by atexit(), which is destructed one by one at the end of the program, in the reverse direction of the construction order. For static variables in the same compilation unit, the construction order is the same as the declaration order, and for different compilation units, the construction order is variable.</li>
</ul>
<p>Is main execution before compile-time or run-time? To quote the C++ standard (C++11 N3690 3.6.2).</p>
<blockquote>
<p>Global variables, static variables in file domains, and static member variables of classes are allocated memory and initialized during static initialization prior to main execution; static local variables (generally static variables within functions) are allocated memory and initialized at first use. Variables here include objects of built-in data types and custom types.</p>
</blockquote>
<p>What is static initialization? Continuing with the C++ standard.</p>
<blockquote>
<p>At the level of the language, the initialization of global variables can be divided into two stages as follows.</p>
<ul>
<li>static initialization: static initialization refers to the use of constants to initialize variables, mainly including zero initialization and const initialization, static initialization is done during program loading, for simple types (built-in types, POD, etc.), from the concrete implementation For simple types (built-in types, PODs, etc.), the variables of zero initialization are stored in the bss segment, while the variables of const initialization are placed in the data segment, and the initialization is done when the program is loaded, which is basically the same as the initialization of global variables in C.</li>
<li>dynamic initialization: dynamic initialization refers to initialization that requires a function call to complete, for example, int a = foo(), or initialization of complex types (classes) (requiring a constructor call). The initialization of these variables is done before the execution of the main function by calling the corresponding code at runtime (except for static local variables)</li>
</ul>
</blockquote>
<p>To summarize.</p>
<ul>
<li>For built-in types that have been manually initialized in code, the variable and its initialization value are stored in the data segment of the executable, which does a const initialization on it at runtime</li>
<li>If the variable is not initialized manually, it is placed in the bss segment of the executable, and zero initialization is done at runtime.</li>
<li>For custom types, the variables are placed in the bss segment and dynamically initialized at runtime</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Initialize manually</th>
<th>Not initialized manually</th>
</tr>
</thead>
<tbody>
<tr>
<td>Built-In Type</td>
<td>data segment, const initialization</td>
<td>bss segment, Dynamic，zero initialization</td>
</tr>
<tr>
<td>Custom Type</td>
<td>bss segment, Dynamic initialization</td>
<td>bss segment, Dynamic initialization</td>
</tr>
</tbody>
</table>
<h2 id="4-conclusion">4 Conclusion</h2>
<p>In this paper, we have used the mechanism of static member variable initialization in C++ to implement a simple framework for automatic object registration and dependency injection management. Through the code design application, then the mechanism for static member variables is organized to strengthen the mastery of the underlying fundamentals of C++. Only when you open your brain and delve into the underlying details in the actual work, you will find C++ more and more interesting.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-09/go-script/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Golang Dynamic Script Research</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-09/git-config-include/">
            <span class="next-text nav-default">Configure different git configs for different directories</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
