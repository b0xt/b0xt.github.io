<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Principle of Go channel - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Learn the principle of channel in golang and how to use it." /><meta name="keywords" content="Golang, Channel" />






<meta name="generator" content="Hugo 0.92.2 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/go-channel-principle/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Principle of Go channel" />
<meta property="og:description" content="Learn the principle of channel in golang and how to use it." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/go-channel-principle/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-02T15:46:05+08:00" />
<meta property="article:modified_time" content="2022-04-02T15:46:05+08:00" />

<meta itemprop="name" content="Principle of Go channel">
<meta itemprop="description" content="Learn the principle of channel in golang and how to use it."><meta itemprop="datePublished" content="2022-04-02T15:46:05+08:00" />
<meta itemprop="dateModified" content="2022-04-02T15:46:05+08:00" />
<meta itemprop="wordCount" content="4003">
<meta itemprop="keywords" content="Golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Principle of Go channel"/>
<meta name="twitter:description" content="Learn the principle of channel in golang and how to use it."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Principle of Go channel</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-02 15:46:05 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 4003 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#section1-channel-use">Section1 channel use</a>
          <ul>
            <li><a href="#11-make-channel">1.1 make channel</a></li>
            <li><a href="#12-sends-and-receives">1.2 sends and receives</a></li>
          </ul>
        </li>
        <li><a href="#section2-channel-source-code">Section2 channel source code</a>
          <ul>
            <li><a href="#21-channel-data-storage-structure">2.1 channel data storage structure</a></li>
            <li><a href="#22-ring-queue">2.2 Ring Queue</a></li>
            <li><a href="#23-waiting-queue">2.3 Waiting Queue</a></li>
            <li><a href="#24-type-information">2.4 Type Information</a></li>
            <li><a href="#25-locks">2.5 Locks</a></li>
          </ul>
        </li>
        <li><a href="#section3-channel-reading-and-writing">Section3 channel reading and writing</a>
          <ul>
            <li><a href="#31-creating-a-channel">3.1 Creating a Channel</a></li>
            <li><a href="#32-writing-to-a-channel-by-a-goroutine-goroutine-sender-data">3.2 Writing to a channel by a goroutine (goroutine sender data)</a></li>
            <li><a href="#33-goroutine-receive-data-from-a-channel">3.3 goroutine receive data from a channel</a></li>
            <li><a href="#34-closing-a-channel">3.4 Closing a channel</a></li>
          </ul>
        </li>
        <li><a href="#section4-common-uses">Section4 Common Uses</a>
          <ul>
            <li><a href="#41-unidirectional-channels">4.1 Unidirectional Channels</a></li>
            <li><a href="#42-select">4.2 select</a></li>
            <li><a href="#43-range">4.3 range</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="section1-channel-use">Section1 channel use</h2>
<h3 id="11-make-channel">1.1 make channel</h3>
<p>A channel with cache and a channel without cache are created as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// buffered
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">Task</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// unbuffered
</span><span class="c1"></span><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="buffered-channel">buffered channel</h4>
<p>If we create a channel with a buffer, the underlying data model is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/e2e3bd14667d43e183c78657551c3268.png" alt="buffered channel"></p>
<p>When we write data to the channel, it will be directly stored in the circular queue(send). When the Queue is full, it will be in the following state.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/8a27729ca0b24c76bdae50f10a19d35a.png" alt="circular queue"></p>
<p>When dequeueing an element, the following is shown.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/ec08cb3f4326447c82f71c787c296e00.png" alt="dequeueing an element"></p>
<p>From the above figure, we can see that recvx has increased by one since, indicating that an element is queued, which is actually a circular array to achieve FIFO semantics.</p>
<p>Then there is another question, when we create a new channel, where is the memory allocated for the hchan data structure created by the underlying layer? In fact, Section2 has been analyzed in the source code analysis, hchan is allocated in the heap.</p>
<p>The following figure shows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/1172036d1c3d437fa2899eec3cfb0063.png" alt="heap"></p>
<p>When we use make to create a channel, it actually returns a pointer to the channel, so we can pass the channel object directly between functions instead of passing a pointer to the channel.</p>
<h3 id="12-sends-and-receives">1.2 sends and receives</h3>
<p>When different goroutines read and write on top of the channel, the process involved is more complicated, such as the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/2a39ebc4d3e34eefae41498b16831498.png" alt="sends and receives"></p>
<p>In the above diagram, G1 writes data to the channel and G2 reads data from the channel.</p>
<p>The flow of G1 acting on the underlying hchan is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/ab9c6a028b4641369493b3b2a75478a1.png" alt="G1"></p>
<ol>
<li>first acquire the global lock.</li>
<li>then enqueue the element (by means of a move copy).</li>
<li>releasing the lock.</li>
</ol>
<p>G2 reads when acting on the underlying data structure flow as shown in the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/1ee563389d394276ac501b0b286de0a6.png" alt="G2"></p>
<ol>
<li>first acquire the global lock.</li>
<li>then dequeue the element (by means of a move copy).</li>
<li>releasing the lock.</li>
</ol>
<p>The above read and write idea is actually very simple, except for the hchan data structure, do not go through the shared memory to communicate; instead, through communication (copy) to achieve shared memory.</p>
<h4 id="writing-a-full-channel-scenario">Writing a full channel scenario</h4>
<p>As shown in the figure below: the queue is full after 3 tasks are written to the channel, what will happen when G1 writes the fourth task?</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/9297a40c173b4810a8bb8aa10c282d5d.png" alt="Writing a full channel scenario"></p>
<p>G1 will pause at this point until a receiver appears.</p>
<p>This is where Golang&rsquo;s scheduler needs to be introduced. We know that goroutines are user-space threads, and that they are created and managed by Go&rsquo;s runtime, not by OS&rsquo;s thread.</p>
<p>But Go&rsquo;s runtime schedules execution of goroutines based on OS thread. The following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/4d9bdbd68bd849468ef3c99c0e1e52fd.png" alt="Go&rsquo;s runtime schedules"></p>
<p>What happens when data is written to an already full channel? The following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/11395c99b35e45d79a905ec0ae73d932.png" alt="written to an already full channel"></p>
<p>The flow of the above diagram is roughly as follows.</p>
<ol>
<li>the current goroutine (G1) will call the gopark function to set the current  goroutine to the waiting state.</li>
<li>disconnects M from the G1 binding.</li>
<li>scheduler will schedule another ready goroutine to establish a binding relationship with M, and then M will run another G.</li>
</ol>
<p>So the OS thread will be running all the time and will not be blocked by the blocking of the G1 co-process. Finally the reference of the current G1 will be deposited in the sender queue of the channel (the queue element is the sudog holding the G1).</p>
<p>So how is a blocked G1 restored? <strong>G1 is restored when a receiver receives channel data.</strong></p>
<p>In fact the hchan data structure also stores the channel&rsquo;s sender and receiver&rsquo;s wait queue. The data prototype is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/b3763e23b4544109af91173933453723.png" alt="channel"></p>
<p>Inside the wait queue is a single linked list of sudog, sudog holds a G for goroutine object reference and elem for the elements saved inside the channel. When G1 executes <code>ch&lt;-task4</code>, G1 creates a sudog and saves it into the sendq queue, and the actual hchan structure is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/1f6b851b016849edbe9c7bba77dbd7f0.png" alt="wait queue "></p>
<p>At this time, if G2 performs a read channel operation, the change graphs before and after the read are as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/f29ee54335f54acdb223e40cdec646b1.png" alt="channel"></p>
<p>The whole process is as follows.</p>
<ol>
<li>G2 calls t:=&lt;-ch to get an element.</li>
<li>take an element task1 from the buffer of the channel.</li>
<li>pop a sudog from the sender wait queue.</li>
<li>copy task4 to the position of task1 in the buffer and update the sendx and recvx index values of the buffer.</li>
<li>at this point it is necessary to set G1 to the Runable state, indicating that G1 is ready to resume operation.</li>
</ol>
<p>G2 will call goready(G1) to wake up G1. the flow is shown in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/a5714e3a2904461b867cfe0b3513c102.png" alt="G2 will call goready(G1) to wake up G1"></p>
<ol>
<li>first G2 calls goready(G1) to evoke scheduling of the scheduler.</li>
<li>set G1 to Runable state.</li>
<li>G1 will join the local queue queue of the local scheduler P and wait for it to run.</li>
</ol>
<h4 id="scenario-of-reading-an-empty-channel">Scenario of reading an empty channel</h4>
<p>When the buffer of a channel is empty, if G2 initiates a read operation first. The following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/f61080455e024b04a8f3db95354aaae5.png" alt="G2"></p>
<p>A sudog will be created, and the sudog representing G2 will be deposited into the recvq wait queue. Then G2 will call the gopark function to enter the wait state, giving up the OS thread, and then G2 will enter the blocking state.</p>
<p>At this time, if there is a G1 performing a write operation, the most intuitive flow is.</p>
<ol>
<li>store the task in recvq into buffer.</li>
<li>goready(G2) wakes up G2.</li>
</ol>
<p><strong>But</strong> we have a smarter way: direct send; which actually means that G1 writes the data directly to the elem in G2, so that it doesn&rsquo;t have to go through the process of copying the elem in G2 to the buffer, and then copying from the buffer to G1. as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/3bc1d12e2ecf4024a726e60e616a7f51.png" alt="direct send"></p>
<p>The specific process is that G1 writes data directly to G2&rsquo;s stack. This way G2 does not need to get the global lock of the channel and operate the buffer.</p>
<h2 id="section2-channel-source-code">Section2 channel source code</h2>
<h3 id="21-channel-data-storage-structure">2.1 channel data storage structure</h3>
<p>The channel data model is defined in the source code <code>runtime/chan.go</code>, which can be understood as a buffered queue. This buffered queue is used to store elements and provides the semantics of a FIFO. The source code is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">//channel队列里面总的数据量
</span><span class="c1"></span>    <span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// total data in the queue
</span><span class="c1"></span>    <span class="c1">// 循环队列的容量，如果是非缓冲的channel就是0
</span><span class="c1"></span>    <span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// size of the circular queue
</span><span class="c1"></span>    <span class="c1">// 缓冲队列，数组类型。
</span><span class="c1"></span>    <span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// points to an array of dataqsiz elements
</span><span class="c1"></span>    <span class="c1">// 元素占用字节的size
</span><span class="c1"></span>    <span class="nx">elemsize</span> <span class="kt">uint16</span>
    <span class="c1">// 当前队列关闭标志位，非零表示关闭
</span><span class="c1"></span>    <span class="nx">closed</span>   <span class="kt">uint32</span>
    <span class="c1">// 队列里面元素类型
</span><span class="c1"></span>    <span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span> <span class="c1">// element type
</span><span class="c1"></span>    <span class="c1">// 队列send索引
</span><span class="c1"></span>    <span class="nx">sendx</span>    <span class="kt">uint</span>   <span class="c1">// send index
</span><span class="c1"></span>    <span class="c1">// 队列索引
</span><span class="c1"></span>    <span class="nx">recvx</span>    <span class="kt">uint</span>   <span class="c1">// receive index
</span><span class="c1"></span>    <span class="c1">// 等待channel的G队列。
</span><span class="c1"></span>    <span class="nx">recvq</span>    <span class="nx">waitq</span>  <span class="c1">// list of recv waiters
</span><span class="c1"></span>    <span class="c1">// 向channel发送数据的G队列。
</span><span class="c1"></span>    <span class="nx">sendq</span>    <span class="nx">waitq</span>  <span class="c1">// list of send waiters
</span><span class="c1"></span>
    <span class="c1">// lock protects all fields in hchan, as well as several
</span><span class="c1"></span>    <span class="c1">// fields in sudogs blocked on this channel.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Do not change another G&#39;s status while holding this lock
</span><span class="c1"></span>    <span class="c1">// (in particular, do not ready a G), as this can deadlock
</span><span class="c1"></span>    <span class="c1">// with stack shrinking.
</span><span class="c1"></span>    <span class="c1">// 全局锁
</span><span class="c1"></span>    <span class="nx">lock</span> <span class="nx">mutex</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The data structure of channel is relatively simple and consists of two main structures.</p>
<ol>
<li>an array implementation of the ring queue, the array has two subscript indexes indicating the read and write indexes respectively, which are used to store the channel buffer data.</li>
<li>The channel&rsquo;s send and recv queues, which hold the goroutine&rsquo;s sudog elements, are implemented as doubly linked list.</li>
<li>The global lock of the channel.</li>
</ol>
<h3 id="22-ring-queue">2.2 Ring Queue</h3>
<p>chan internally implements a ring queue as its buffer. The length of the queue is specified when the chan is created.</p>
<p>The following diagram shows a schematic of a chan that can cache 6 elements.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/7066cf7167c84a40ba1a445c3c9bb5b4.png" alt="Ring Queue"></p>
<ul>
<li>dataqsiz: indicates that the queue length is 6, i.e., 6 elements can be cached.</li>
<li>buf: points to the memory of the queue, with two elements remaining in the queue.</li>
<li>qcount: indicates that there are two elements left in the queue.</li>
<li>sendx: indicates the location where the subsequent writes are stored, taking the values [0, 6).</li>
<li>recvx: indicates the location from which data is read, takes the values [0, 6).</li>
</ul>
<h3 id="23-waiting-queue">2.3 Waiting Queue</h3>
<p>Read data from a channel, if the channel buffer is empty or there is no buffer, the current goroutine will be blocked.
Write data to the channel, if the channel buffer is full or if there is no buffer, the current goroutine will be blocked.</p>
<p>The blocked goroutine will hang in the channel&rsquo;s waiting queue.</p>
<ul>
<li>A goroutine blocked by a read will be woken up by a goroutine writing data to the channel.</li>
<li>a goroutine blocked by a write will be woken up by a goroutine that reads data from the channel.</li>
</ul>
<p>The following figure shows a channel without buffers with several goroutines blocking waiting to read data.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/440c00f9546a40f8b1667ee09ce17a69.png" alt="channel without buffers with several goroutines blocking waiting to read data"></p>
<p>Note that in general at least one of recvq and sendq is empty. The only exception is when the same goroutine uses a select statement to write data to a channel while reading data from it.</p>
<h3 id="24-type-information">2.4 Type Information</h3>
<p>A channel can only pass one type of value, and the type information is stored in the hchan data structure.</p>
<ul>
<li>elemtype represents the type and is used for assignment during data transfer.</li>
<li>elemsize represents the type size and is used to locate the element position in the buf.</li>
</ul>
<h3 id="25-locks">2.5 Locks</h3>
<p>A channel can only be read or written by one goroutine at a time. For simplicity, the rest of this chapter does not cover locking and unlocking when describing the read/write process.</p>
<h2 id="section3-channel-reading-and-writing">Section3 channel reading and writing</h2>
<h3 id="31-creating-a-channel">3.1 Creating a Channel</h3>
<p>When we create a new channel, we usually use the <code>make(chan, n)</code> statement, which is rewritten by the compiler and then executed by the makechan function in chan.go. The source code of the function is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
    <span class="nx">elem</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span>

    <span class="c1">// compiler checks this but be safe.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nf">maxSliceCap</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="o">||</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span><span class="o">*</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="c1">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span><span class="c1"></span>    <span class="c1">// buf points into the same allocation, elemtype is persistent.
</span><span class="c1"></span>    <span class="c1">// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span><span class="c1"></span>    <span class="c1">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">// Queue or element size is zero.
</span><span class="c1"></span>        <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
        <span class="c1">// Race detector uses this location for synchronization.
</span><span class="c1"></span>        <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">kind</span><span class="o">&amp;</span><span class="nx">kindNoPointers</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">// Elements do not contain pointers.
</span><span class="c1"></span>        <span class="c1">// Allocate hchan and buf in one call.
</span><span class="c1"></span>        <span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span><span class="o">*</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="c1">// Elements contain pointers.
</span><span class="c1"></span>        <span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span><span class="o">*</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">debugChan</span> <span class="p">{</span>
        <span class="nb">print</span><span class="p">(</span><span class="s">&#34;makechan: chan=&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="s">&#34;; elemsize=&#34;</span><span class="p">,</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="s">&#34;; elemalg=&#34;</span><span class="p">,</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">alg</span><span class="p">,</span> <span class="s">&#34;; dataqsiz=&#34;</span><span class="p">,</span> <span class="nx">size</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The function takes two arguments, one is the data type of the elements stored inside the channel, and one is the buffer capacity (if 0 means non-buffer buffer), the creation process is as follows.</p>
<ul>
<li>Depending on whether the passed buffer size size is zero, create a channel without buffer or a buffered channel with size, respectively.
<ul>
<li>For unbuffered channels, request the memory size of a hchan data structure.</li>
<li>For a buffered channel, new a hchan object and initialize the buffer memory</li>
</ul>
</li>
<li>Update the key attributes of the circular queue in chan: elemsize, elemtype, dataqsiz.</li>
</ul>
<p>The process of creating a channel is actually initializing the hchan structure. Where the type information and buffer length are passed in by the make statement, and the buf size is determined in conjunction with the element size and buffer length.</p>
<p>The pseudo code for creating a channel is shown below.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
    <span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="nx">元素类型大小</span><span class="o">*</span><span class="nx">size</span><span class="p">)</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nx">元素类型大小</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">元素类型</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nx">size</span>

    <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="32-writing-to-a-channel-by-a-goroutine-goroutine-sender-data">3.2 Writing to a channel by a goroutine (goroutine sender data)</h3>
<p>All code that executes c &lt; ep to send ep to a channel ends up calling the chansend function in chan.go.</p>
<p>The function is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
<span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>The function has three parameters, the first represents the data structure of the channel, the second is a pointer to the data to be written, and the third block represents whether the write operation is blocking or not.</p>
<p>The main flow of writing data to a channel is as follows:</p>
<ul>
<li>CASE1: When the channel is empty or uninitialized. If block means blocking, then sending data to it will be permanently blocked; if block means non-positive, it will be returned directly;</li>
<li>CASE2: The previous scenario, block is non-blocking, and the channel is not closed (closed channel can not write data) and (channel is non-buffered queue and receiver wait queue is empty) or (channel is buffered queue but queue is full), this time directly return;
<ul>
<li>Call <code>lock(&amp;clock)</code> to lock the channel&rsquo;s global lock;</li>
</ul>
</li>
<li>CASE3:Can&rsquo;t send data to closed channels, it will cause panic.</li>
<li>CASE4: If the recv queue on the channel is not empty, skip the channel&rsquo;s cache queue and send the message directly to the receiving goroutine:
<ul>
<li>Call the sendDirect method to send the message to be written to the receiving goroutine;</li>
<li>Release the global lock on the channel;</li>
<li>Call the goready function to set the receiving qoroutine to the ready state and wait for scheduling.</li>
</ul>
</li>
<li>CASE5: If the cache queue is not full, the message is copied to the cache queue, and then the global lock is released;</li>
<li>CASE6: If the cache queue is full and the receive message queue recy is empty, add the current aoroutine to the send queue:
<ul>
<li>Get the sudog of the current goroutine and put it into the send queue of the channel;</li>
<li>Hibernate the current goroutine</li>
</ul>
</li>
</ul>
<p>The simple process of writing data to a channel is as follows.</p>
<ol>
<li>if the waiting receive queue recvq is not empty, it means that there is no data in the buffer or there is no buffer, at this time, directly take out G from recvq and write the data, finally wake up the G and end the sending process.</li>
<li>if there is a free space in the buffer, write the data to the buffer and end the sending process.</li>
<li>if there is no free space in the buffer, write the data to be sent to G, add the current G to sendq, go to sleep and wait to be woken up by the read goroutine.</li>
</ol>
<p>The flowchart is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/e1dfe5a6e1614a6fbff9904eea9cb017.png" alt="process of writing data to a channel"></p>
<h3 id="33-goroutine-receive-data-from-a-channel">3.3 goroutine receive data from a channel</h3>
<p>All code that executes <code>ep &lt; c</code> to receive data from a channel using ep will end up calling the <code>chanrecv function</code> in chan.go.</p>
<p>The function is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
<span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see from the source comment, this function receives data from the channel and writes the received data to the object pointed to by the ep pointer.</p>
<p>There is also a block argument, which indicates whether the channel blocks when it fails to return data. When block=false and there is no data in the channel, the function returns (false,false).</p>
<p>The flow of receiving data from a channel is as follows:</p>
<ul>
<li>CASE1: Scenario where the preceding channel is nil:
<ul>
<li>If the block is non-blocking, return directly;</li>
<li>If block is blocking, call gopark() to block the current goroutine and throw an exception.</li>
<li>If the block is non-blocking and the channel is a non-buffered queue, the sender wait queue is empty or the channel is a buffered queue but the number of elements in the queue is 0.
and the channel is not closed, this time directly return;</li>
<li>Call <code>lock(&amp;clock)</code> to lock the global lock on the channel;</li>
</ul>
</li>
<li>CASE2: The channel has been closed and there is no more data in the channel buffer, then return directly to success and null;</li>
<li>CASE3:sender queue is not empty, call <code>func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int)</code> function to handle:
<ul>
<li>channel is a non-buffered channel, call the recvDirect function directly to recv elements from sender directly to ep object, so that only one copy is used;</li>
<li>For non-empty sender queue, the buffer queue of the buffered channel must be full:
<ul>
<li>First take the pair of head elements of the channel buffer queue and copy them to the receiver (that is, ep);</li>
<li>Copy the data inside the header element of the sender queue to the position of the element just popped from the channel buffer queue, so that the buffer queue doesn&rsquo;t have to move the data.</li>
</ul>
</li>
<li>Release the global lock on the channel;</li>
<li>Call the goready function to mark the current goroutine as ready to run;</li>
</ul>
</li>
<li>CASE4:sender queue is empty buffer queue is non-empty, take queue elements directly, move header index</li>
<li>CASE5:sender queue is empty, buffer queue is also not empty and does not block the goroutine, directly return(falsefalse);</li>
<li>CASE6:sender queue is empty, cache queue of channel is empty, add aoroutine to recv queue and yin stuff.</li>
</ul>
<p>The simple process of reading data from a channel is as follows.</p>
<ol>
<li>if the waiting send queue sendq is not empty and there is no buffer, take out G from sendq directly, read the data in G out, and finally wake up G to end the reading process.</li>
<li>if the waiting send queue sendq is not empty, it means the buffer is full, read out the data from the first part of the buffer, write the data in G to the end of the buffer, wake up G, and end the reading process.</li>
<li>if there is data in the buffer, retrieve the data from the buffer and end the reading process.</li>
<li>add the current goroutine to recvq, go to sleep and wait to be woken up by the write goroutine.</li>
</ol>
<p>The simple flowchart is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/02/4c1b6209580047c3957a7caf9f03d234.png" alt="simple process of reading data from a channel"></p>
<h3 id="34-closing-a-channel">3.4 Closing a channel</h3>
<p>The channel is closed when we perform the close operation of the channel.</p>
<p>The main flow of closing is shown below.</p>
<ol>
<li>obtaining a global lock.</li>
<li>set the close flag bit of the channel data structure chan.</li>
<li>get the read goroutines on the current channel and link them into a doubly linked list.</li>
<li>get the write goroutine on the current channel and link it to the back of the previous read doubly linked list.</li>
<li>release the global lock.</li>
<li>wake up all the read and write goroutines.</li>
</ol>
<p>When closing the channel, all Gs in recvq will be woken up, and the data location where Gs should have been written is nil. all Gs in sendq will be woken up, but these Gs will panic.</p>
<p>In addition, there are some common scenarios where panic occurs.</p>
<ol>
<li>closing a channel with a nil value</li>
<li>closing a channel that has already been closed</li>
<li>writing data to a closed channel</li>
</ol>
<h2 id="section4-common-uses">Section4 Common Uses</h2>
<h3 id="41-unidirectional-channels">4.1 Unidirectional Channels</h3>
<p>A unidirectional channel is one that can only be used to send or receive data.</p>
<p>We know that a channel can be passed as an argument, so a one-way channel is just a restriction on the use of a channel, which is the same reason that C uses const to modify function arguments to be read-only.</p>
<ul>
<li>func readChan(chanName &lt;-chan int): Restricts the function internally to read data from the channel only by means of a formal parameter</li>
<li>func writeChan(chanName chan&lt;- int): The function can only write data to the channel internally by means of a formal parameter.</li>
</ul>
<p>A simple example program is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">readChan</span><span class="p">(</span><span class="nx">chanName</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">&lt;-</span> <span class="nx">chanName</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">writeChan</span><span class="p">(</span><span class="nx">chanName</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">chanName</span> <span class="o">&lt;-</span> <span class="mi">1</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">mychan</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
 
    <span class="nf">writeChan</span><span class="p">(</span><span class="nx">mychan</span><span class="p">)</span>
    <span class="nf">readChan</span><span class="p">(</span><span class="nx">mychan</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>mychan is a normal channel, while the readChan() parameter restricts the incoming channel to read only, and the writeChan() parameter restricts the incoming channel to write only.</p>
<h3 id="42-select">4.2 select</h3>
<p>You can use select to monitor multiple channels, for example, monitor multiple channels and read data from one of them when it is available.</p>
<p>A simple example program is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>
 
<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>
 
<span class="kd">func</span> <span class="nf">addNumberToChan</span><span class="p">(</span><span class="nx">chanName</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">chanName</span> <span class="o">&lt;-</span> <span class="mi">1</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
 
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">chan1</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">chan2</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
 
    <span class="k">go</span> <span class="nf">addNumberToChan</span><span class="p">(</span><span class="nx">chan1</span><span class="p">)</span>
    <span class="k">go</span> <span class="nf">addNumberToChan</span><span class="p">(</span><span class="nx">chan2</span><span class="p">)</span>
 
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">e</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">chan1</span> <span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Get element from chan1: %d\n&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">e</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">chan2</span> <span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Get element from chan2: %d\n&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;No element in chan1 and chan2.\n&#34;</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Two channels are created in the program: chan1 and chan2. The addNumberToChan() function writes data to both channels periodically. The select function monitors both channels and reads data from them when either one is readable.</p>
<p>The program output is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">D</span><span class="p">:</span><span class="err">\</span><span class="nx">SourceCode</span><span class="err">\</span><span class="nx">GoExpert</span><span class="err">\</span><span class="nx">src</span><span class="p">&gt;</span><span class="k">go</span> <span class="nx">run</span> <span class="nx">main</span><span class="p">.</span><span class="k">go</span>
<span class="nx">Get</span> <span class="nx">element</span> <span class="nx">from</span> <span class="nx">chan1</span><span class="p">:</span> <span class="mi">1</span>
<span class="nx">Get</span> <span class="nx">element</span> <span class="nx">from</span> <span class="nx">chan2</span><span class="p">:</span> <span class="mi">1</span>
<span class="nx">No</span> <span class="nx">element</span> <span class="nx">in</span> <span class="nx">chan1</span> <span class="nx">and</span> <span class="nx">chan2</span><span class="p">.</span>
<span class="nx">Get</span> <span class="nx">element</span> <span class="nx">from</span> <span class="nx">chan2</span><span class="p">:</span> <span class="mi">1</span>
<span class="nx">Get</span> <span class="nx">element</span> <span class="nx">from</span> <span class="nx">chan1</span><span class="p">:</span> <span class="mi">1</span>
<span class="nx">No</span> <span class="nx">element</span> <span class="nx">in</span> <span class="nx">chan1</span> <span class="nx">and</span> <span class="nx">chan2</span><span class="p">.</span>
<span class="nx">Get</span> <span class="nx">element</span> <span class="nx">from</span> <span class="nx">chan2</span><span class="p">:</span> <span class="mi">1</span>
<span class="nx">Get</span> <span class="nx">element</span> <span class="nx">from</span> <span class="nx">chan1</span><span class="p">:</span> <span class="mi">1</span>
<span class="nx">No</span> <span class="nx">element</span> <span class="nx">in</span> <span class="nx">chan1</span> <span class="nx">and</span> <span class="nx">chan2</span><span class="p">.</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see from the output, the order in which the data is read from the channel is random. In fact, the order in which the multiple cases of the select statement are executed is random, and there is a special section on how select is implemented.</p>
<p>The point I want to make with this example is that <strong>select&rsquo;s case statement reads the channel without blocking</strong>, even though there is no data in the channel. This is because the case statement compiles and calls the read channel with <strong>explicitly passed in non-blocking arguments</strong>, which does not add the current goroutine to the waiting queue when no data is read, but returns it directly.</p>
<h3 id="43-range">4.3 range</h3>
<p>The range can be used to continuously read data from a channel as if it were traversing an array. When there is no data in the channel, it blocks the current goroutine, the same as the blocking mechanism for reading channels.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">chanRange</span><span class="p">(</span><span class="nx">chanName</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">chanName</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Get element from chan: %d\n&#34;</span><span class="p">,</span> <span class="nx">e</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Note: If the goroutine writing to this channel exits, the system will panic when it detects this condition, otherwise the range will block permanently.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">Golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-04/python-local-variables/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Python3 Accessing and Modifying Local Variables via Strings</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-04/golang-memory-allocation/">
            <span class="next-text nav-default">Golang&#39;s memory allocation</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
