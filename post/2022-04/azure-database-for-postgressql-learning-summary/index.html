<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Azure Database for PostgreSQL Learning Summary - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Azure Database for PostgreSQL is an on-cloud database service provided by Azure based on the open source PostgreSQL database. It is a fully managed database service with predictable performance, security, high availability, and dynamic scalability to handle mission-critical workloads." /><meta name="keywords" content="Postgresql, Azure Database" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/azure-database-for-postgressql-learning-summary/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Azure Database for PostgreSQL Learning Summary" />
<meta property="og:description" content="Azure Database for PostgreSQL is an on-cloud database service provided by Azure based on the open source PostgreSQL database. It is a fully managed database service with predictable performance, security, high availability, and dynamic scalability to handle mission-critical workloads." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/azure-database-for-postgressql-learning-summary/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-01T10:56:32+08:00" />
<meta property="article:modified_time" content="2022-04-01T10:56:32+08:00" />

<meta itemprop="name" content="Azure Database for PostgreSQL Learning Summary">
<meta itemprop="description" content="Azure Database for PostgreSQL is an on-cloud database service provided by Azure based on the open source PostgreSQL database. It is a fully managed database service with predictable performance, security, high availability, and dynamic scalability to handle mission-critical workloads."><meta itemprop="datePublished" content="2022-04-01T10:56:32+08:00" />
<meta itemprop="dateModified" content="2022-04-01T10:56:32+08:00" />
<meta itemprop="wordCount" content="3619">
<meta itemprop="keywords" content="PostgreSQL," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Azure Database for PostgreSQL Learning Summary"/>
<meta name="twitter:description" content="Azure Database for PostgreSQL is an on-cloud database service provided by Azure based on the open source PostgreSQL database. It is a fully managed database service with predictable performance, security, high availability, and dynamic scalability to handle mission-critical workloads."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Azure Database for PostgreSQL Learning Summary</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-01 10:56:32 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3619 words </span>
          <span class="more-meta"> 8 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#1-single-server">1 Single Server</a></li>
            <li><a href="#2-flexible-server">2 Flexible Server</a></li>
            <li><a href="#3-large-scale-citus-clustering">3 Large-scale (Citus) clustering</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Azure Database for PostgreSQL is an on-cloud database service provided by Azure based on the open source PostgreSQL database. It is a fully managed database service with predictable performance, security, high availability, and dynamic scalability to handle mission-critical workloads.</p>
<p>Azure Database for PostgreSQL offers.</p>
<ul>
<li>Built-in high availability.</li>
<li>Automatic backups and point-in-time restores (backup data is retained for up to 35 days).</li>
<li>Automated maintenance of the underlying hardware, operating system, and database engine to keep services secure and versions up-to-date.</li>
<li>Predictable performance, using a pay-as-you-go pricing model.</li>
<li>second-level elastic scaling.</li>
<li>Enterprise-class security and industry-leading compliance to protect sensitive data at rest and in motion.</li>
<li>Rich monitoring and automation traits.</li>
<li>Industry-leading support experience.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/01/f2c63414cb3e4274bdec1fe09b783074.png" alt="Azure Database for PostgreSQL"></p>
<p>These features require little to no management, and all features are available at no additional cost. Enables you to focus on application development and accelerating time-to-market, rather than spending valuable time and resources on managing virtual machines and infrastructure.</p>
<p>Azure Database for PostgreSQL offers three deployment models: Single Server, Flexible Server, and Large Scale (Citus) Clustering. Each is described below.</p>
<h3 id="1-single-server">1 Single Server</h3>
<p>Azure Database for PostgreSQL Single Server is a central management point for multiple databases. It is the same construct as if you were building a PostgreSQL server in an On-Premise environment.</p>
<p>For a single server deployment of Azure Database for PostgreSQL.</p>
<ul>
<li>is created in an Azure subscription.</li>
<li>Is the parent resource for the database.</li>
<li>provides a namespace for the database.</li>
<li>is a container with strong lifecycle semantics (deleting the server will delete the contained database).</li>
<li>configures resources in a zone.</li>
<li>provides connection points for server and database access.</li>
<li>provides a range of administrative policies applicable to its databases: logins, firewalls, users, roles, configurations, etc.</li>
<li>Support multiple PostgreSQL versions (<a href="https://docs.microsoft.com/en-us/azure/postgresql/concepts-supported-versions">what are they?</a>).</li>
<li>Support for PostgreSQL extensions (<a href="https://docs.microsoft.com/en-us/azure/postgresql/concepts-extensions">What extensions are supported?</a>).</li>
</ul>
<p>You can create one or more databases in a single server for exclusive use or shared resources by one or more applications. Pricing will be calculated based on pricing tier, vCore and storage (GB) configurations.</p>
<h4 id="how-to-connect">How to connect</h4>
<ul>
<li>
<p>Authentication</p>
<p>Azure Database for PostgreSQL single server supports native PostgreSQL authentication. You can connect using an administrator account.</p>
</li>
<li>
<p>Protocols</p>
<p>The service supports the message-based protocols used by PostgreSQL.</p>
</li>
<li>
<p>TCP/IP</p>
<p>Protocols such as the above are supported by TCP/IP and Unix domain sockets.</p>
</li>
<li>
<p>Firewall</p>
<p>To protect data, Azure shuts down all access by default, and you set up firewall rules (IP whitelisting) on the Server side before opening access to the specified IP.</p>
<p>The firewall determines whether each request has access based on its original IP address. You need to set firewall rules (range of allowed IP addresses) on Server side via Azure portal or Azure CLI, and all databases under the same logical server follow these rules. Please use the subscription owner or subscription contributor to create the firewall rules.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/01/28f410f70660426ea5a756d1f68bd15f.png" alt="Firewall"></p>
</li>
</ul>
<p>You can choose to force TLS to be enabled for enhanced security.</p>
<p>This will allow you to download the certificate and connect using psql.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ wget --no-check-certificate https://dl.cacerts.digicert.com/DigiCertGlobalRootCA.crt.pem
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ psql --host<span class="o">=</span>mydemoserver-pg.postgres.database.azure.com --port<span class="o">=</span><span class="m">5432</span> --username<span class="o">=</span>myadmin --dbname<span class="o">=</span>postgres --set<span class="o">=</span><span class="nv">sslmode</span><span class="o">=</span>require --set<span class="o">=</span><span class="nv">sslrootcert</span><span class="o">=</span>DigiCertGlobalRootCA.crt.pem
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># psql &#34;host=mydemoserver-pg.postgres.database.azure.com port=5432 user=myadmin dbname=postgres sslmode=verify-full sslrootcert=DigiCertGlobalRootCA.crt.pem&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="server-administration">Server Administration</h4>
<p>You can use the Azure portal or Azure CLI to manage Azure Database for PostgreSQL single server.</p>
<p>When you create a server, you set a password for the administrator user. The administrator user is the highest privileged user you have on the server. It belongs to the azure_pg_admin role. This role does not have full superuser privileges.</p>
<p>PostgreSQL superuser privileges are assigned to azure_superuser, which is held by the managed service. You do not have access to this role.</p>
<p>There are several default databases under this server as follows.</p>
<ul>
<li>postgres - the default database to which you can connect once the server is created.</li>
<li>azure_maintenance - This database is used to separate the processes that provide the managed services from user operations, and you do not have access to this database.</li>
<li>azure_sys - The database used for the Query Store. This database does not accumulate data when the Query Store is closed and is closed by default.</li>
</ul>
<h4 id="server-parameters">Server Parameters</h4>
<p>Server parameters determine the configuration of the server. In Azure Database for PostgreSQL, the list of parameters can be viewed and edited using the Azure portal or the Azure CLI.</p>
<p>As a hosted service, the configurable parameters for Azure Database for PostgreSQL are a subset of the configurable parameters for self-built Postgres instances (for more information on Postgres parameters, see <a href="https://www.postgresql.org/docs/14/runtime-config.html">PostgreSQL Runtime Configuration</a>).</p>
<p>Your Azure Database for PostgreSQL server is created using the default values for each parameter. Users cannot configure certain parameters that require a restart or superuser privileges to change.</p>
<h3 id="2-flexible-server">2 Flexible Server</h3>
<p>Azure Database for PostgreSQL Flexible Server is a fully managed database service designed to provide more granular control and flexibility over database management functions and configuration settings. The service provides more flexibility and customization of server configurations based on user requirements. The Flexible Server architecture allows users to co-locate the database engine with client services to reduce latency and select high availability in a single availability zone and across multiple availability zones. Flexible Server also provides better cost-optimized control with the ability to start and stop your servers and burstable compute tiers, ideal for workloads that do not require continuous full compute capacity. The service currently supports PostgreSQL 11, 12 and 13 community editions. The service is currently available in most Azure locales.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/01/3263a8749da34bbb937d288b96541199.png" alt="Flexible Server"></p>
<p>Flexible servers are well suited for the following situations.</p>
<ul>
<li>application development requiring better control and customization.</li>
<li>Regional redundancy and high availability.</li>
<li>Hosted maintenance windows.</li>
</ul>
<h4 id="high-availability">High Availability</h4>
<p>The Flexible Server Deployment Model is designed to support high availability for a single availability zone and across multiple availability zones. The architecture separates compute and storage. The database engine runs on a container inside a Linux virtual machine, while the data files are stored in Azure Storage. Storage maintains three local redundant synchronized copies of the database files to ensure data persistence.</p>
<p>In the event of a server failure during a planned or unplanned failover event, the service maintains high server availability using the following automated procedures.</p>
<ul>
<li>Pre-provisioning of a new computing Linux VM.</li>
<li>Storage with data files mapped to the new VM.</li>
<li>PostgreSQL database engine coming online on the new VM.</li>
</ul>
<p>The following diagram shows the transition of VM and storage failures.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/01/e0460eb0f5b04d27812ffe5080d0c098.png" alt="transition of VM and storage failures"></p>
<p>If regional redundancy high availability is configured, the service will pre-provision and maintain a hot standby server in an available region within the same Azure geography. Data changes on the source server are synchronized and replicated to the standby server, ensuring zero data loss. With region redundancy high availability, the standby server will come online to process the request as soon as a planned or unplanned failover event is triggered. This allows services to recover from failures that support multiple availability regions within the same Region, as shown in the figure below.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/01/22333f25aaea4db596ce269a47954bf9.png" alt="Region"></p>
<h4 id="automated-patching-using-managed-maintenance-window">Automated patching using Managed Maintenance Window</h4>
<p>This service performs automatic patching of the underlying hardware, operating system and database engine. This includes security patches and software updates. For the PostgreSQL engine, minor version upgrades are also included in the scheduled maintenance releases. Users can configure the patching schedule to be system-hosted or to customize maintenance times. During maintenance, patches will be applied and may require a server restart to complete the update. By customizing maintenance times, users can make their patch cycles predictable and choose the maintenance window that has the least impact on the business. Typically, the service is released once a month as part of continuous integration and release.</p>
<h4 id="automatic-backup">Automatic Backup</h4>
<p>Flexible Server automatically backs up data and stores them on Zone Redundant Storage (ZRS) within the same Region. Backups can be used to restore your server to any point in time within the backup retention period. The default backup retention period is 7 days and can be configured to a maximum of 35 days. All backups are encrypted using the AES 256 encryption algorithm.</p>
<h4 id="expands-in-seconds">Expands in seconds</h4>
<p>Flexible Server has three compute tiers to choose from: Burst, Generic, and Memory Optimized. Burst is best suited for low-cost development and low-concurrency workloads that do not require continuous full compute capacity. The general-purpose and memory-optimized models are better suited for production workloads that require high concurrency, large scale, and predictable performance. You can spend a few dollars a month to build your first application on a small database and then seamlessly scale to meet your solution needs.</p>
<h4 id="start-and-stop-servers-to-reduce-tco">Start and stop servers to reduce TCO</h4>
<p>Flexible Server allows you to stop and start servers on demand to reduce your TCO. compute layer billing stops immediately when a server is stopped. This allows you to achieve significant cost savings during development, testing, and time-bound predictable production workloads. The server will remain down for 7 days unless restarted early.</p>
<h4 id="enterprise-grade-security">Enterprise-grade security</h4>
<p>The Flexible Server uses a FIPS 140-2 validated encryption module to store static data encrypted. Data created when running queries (including backups and temporary files) is encrypted. The service uses the AES 256 key included in Azure Storage Encryption, and the key can be managed by the system (by default). The service encrypts dynamic data using the default enhanced transport layer security (SSL/TLS). The service is only enhanced and supports TLS version 1.2.</p>
<p>Allows fully private access to servers using Azure Virtual Network (VNet integration). Servers in an Azure Virtual Network can only be accessed and connected to via private IP addresses. With VNet integration, public access is denied and the server cannot be accessed using public endpoints.</p>
<h4 id="monitoring-and-alerting">Monitoring and Alerting</h4>
<p>Flexible Server is equipped with built-in performance monitoring and alerting capabilities. All Azure metrics are captured once a minute and each metric provides a 30-day history. You can configure alerts on the metrics. Host server metrics provide open access for monitoring resource utilization and allow configuration of slow query logs. Using these tools, you can quickly optimize your workloads and can optimize your configurations for optimal performance.</p>
<h4 id="built-in-pgbouncer">Built-In PgBouncer</h4>
<p>Flexible Server comes with a built-in PgBouncer (a connection pool). You can choose to enable it and connect your applications to your database server via PgBouncer using the same hostname and port 6432.</p>
<h4 id="data-migration">Data Migration</h4>
<p>This service runs the PostgreSQL Community Edition. This allows full application compatibility and minimal refactoring costs to migrate existing applications developed on the PostgreSQL engine to Azure Flexible Server.</p>
<ul>
<li>Dump and Restore For offline migrations, users can afford some downtime and use community tools such as pg_dump and pg_restore to perform dumps and restores.</li>
<li>Azure Database Migration ServiceFor seamless migration to Flexible Server with minimal downtime, you can use Azure Database Migration Service.</li>
</ul>
<h3 id="3-large-scale-citus-clustering">3 Large-scale (Citus) clustering</h3>
<p>A large scale (Citus) cluster is a deployment option that uses sharding to scale queries horizontally across multiple machines. Its query engine performs parallel queries on incoming SQL across these servers to provide faster responses to large data sets. It scales larger and performs better than the two deployment options above. The workload is typically close to or over 100 GB.</p>
<p>Large-scale clusters provide the ability to.</p>
<ul>
<li>Horizontal scaling across multiple machines using sharding.</li>
<li>Parallel queries on multiple machines for faster response to large data sets.</li>
<li>Excellent support for multi-tenant applications, real-time operational analysis, and high-throughput transactional workloads.</li>
</ul>
<p>Applications built with PostgreSQL can run distributed queries on large-scale (Citus) clusters using standard join libraries and minimal changes.</p>
<h4 id="node-division-of-labor">Node Division of Labor</h4>
<p>Large-scale (Citus) cluster hosting types allow Azure Database for PostgreSQL servers (called nodes) to coordinate with each other in a &ldquo;no-share&rdquo; architecture. Nodes in a server group share more data and use more CPU cores than a single server. The architecture also allows the database to be expanded by adding more nodes to the server group.</p>
<p>Each server group has a coordinating node and multiple worker nodes. Applications send their queries to the coordinating node (applications cannot connect directly to worker nodes), and the coordinating node forwards them to the relevant worker nodes and consolidates their results.</p>
<p>Large-scale (Citus) clusters allow the DBA to define table slicing rules to store different rows on different worker nodes. Distributed tables are the key to strong performance in large scale (Citus) clusters. An unsliced table would have the data entirely on the coordinating node, which means that the parallelism advantage of multiple machines cannot be taken advantage of.</p>
<p>For each query on a distributed table, the coordinator decides to route it to a single worker node or parallelize it to multiple nodes, depending on the distribution of the required data. The coordinator decides how to do this by querying metadata tables that keep track of the DNS names and operational status of the worker nodes, as well as the distribution of data across the nodes.</p>
<h4 id="table-type">Table Type</h4>
<p>There are three types of tables in a large scale (Citus) cluster server group, each stored differently on nodes and used for different purposes.</p>
<ul>
<li>
<p>Distributed Tables</p>
<p>Distributed tables are like normal tables for SQL statements, but they are partitioned horizontally between the working nodes. This means that the rows of the table are stored on different nodes (in segmented tables called slices). Large-scale (Citus) clusters run not only SQL across the cluster, but also DDL statements. Changing the schema of a distributed table cascades the updates of table slices on all working nodes.</p>
<p>Large-scale (Citus) clusters use a sharding algorithm to store rows on different nodes, which is determined by the distribution column that must be specified by the DBA or cluster administrator when the table is distributed. The choice of this column is important for performance and functionality.</p>
</li>
<li>
<p>Referencing Tables</p>
<p>A reference table is a special type of distributed table whose entire contents are concentrated in a slice. The slice is replicated to each worker node. Queries from any worker node can be performed locally without requesting rows from other nodes, saving network overhead. Reference tables do not have distribution columns, because there is no need to distinguish separate slices for rows.</p>
<p>The reference table is typically small and is used to store data related to queries running on any worker node. Enumerated values are an example, such as order status or product categories.</p>
</li>
<li>
<p>Local Tables</p>
<p>When you are using a large-scale (Citus) cluster, the coordinator node you connect to is a regular PostgreSQL database. You can create regular tables on the coordinator and choose not to slice them.</p>
<p>A good scenario for local tables is small administrative tables that do not participate in join queries. A good example is the user table used for application login and authentication.</p>
</li>
</ul>
<h4 id="slicing">Slicing</h4>
<p>Moving on from the above section, the technical details of sharding are discussed.</p>
<p>The <code>pg_dist_shard</code> metadata table on the coordinator records information about each shard for each distributed table in the system. This information is a match between the slice ID and a range of integers in the hash space (shardminvalue, shardmaxvalue).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">SELECT * from pg_dist_shard<span class="p">;</span>
</span></span><span class="line"><span class="cl"> logicalrelid  <span class="p">|</span> shardid <span class="p">|</span> shardstorage <span class="p">|</span> shardminvalue <span class="p">|</span> shardmaxvalue
</span></span><span class="line"><span class="cl">---------------+---------+--------------+---------------+---------------
</span></span><span class="line"><span class="cl"> github_events <span class="p">|</span>  <span class="m">102026</span> <span class="p">|</span> t            <span class="p">|</span> <span class="m">268435456</span>     <span class="p">|</span> <span class="m">402653183</span>
</span></span><span class="line"><span class="cl"> github_events <span class="p">|</span>  <span class="m">102027</span> <span class="p">|</span> t            <span class="p">|</span> <span class="m">402653184</span>     <span class="p">|</span> <span class="m">536870911</span>
</span></span><span class="line"><span class="cl"> github_events <span class="p">|</span>  <span class="m">102028</span> <span class="p">|</span> t            <span class="p">|</span> <span class="m">536870912</span>     <span class="p">|</span> <span class="m">671088639</span>
</span></span><span class="line"><span class="cl"> github_events <span class="p">|</span>  <span class="m">102029</span> <span class="p">|</span> t            <span class="p">|</span> <span class="m">671088640</span>     <span class="p">|</span> <span class="m">805306367</span>
</span></span><span class="line"><span class="cl"> <span class="o">(</span><span class="m">4</span> rows<span class="o">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the coordinator node wants to determine which slice holds the row of github_events, it hashes the value of the distribution column in that row. Then it checks which slice&rsquo;s range contains the hash value. The range is defined so that the image of the hash function is their disjoint set.</p>
<p>Assume that slice 102027 is associated with the row you want to request. The row is read or written in a table named github_events_102027 on one of the worker nodes. Which worker node? This is entirely determined by the metadata table. The mapping of slices to worker nodes is called slice placement.</p>
<p>The coordinator node rewrites the query as a slice that references a specific table (such as github_events_102027) and runs those slices on the appropriate worker node. The following is an example of running a query in the background to find the node holding slice ID 102027.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">shardid</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">node</span><span class="p">.</span><span class="n">nodename</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">node</span><span class="p">.</span><span class="n">nodeport</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">pg_dist_placement</span><span class="w"> </span><span class="n">placement</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">JOIN</span><span class="w"> </span><span class="n">pg_dist_node</span><span class="w"> </span><span class="n">node</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">ON</span><span class="w"> </span><span class="n">placement</span><span class="p">.</span><span class="n">groupid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">groupid</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">noderole</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;primary&#39;</span><span class="p">::</span><span class="n">noderole</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">shardid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">102027</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">┌─────────┬───────────┬──────────┐
</span></span><span class="line"><span class="cl">│ shardid │ nodename  │ nodeport │
</span></span><span class="line"><span class="cl">├─────────┼───────────┼──────────┤
</span></span><span class="line"><span class="cl">│  102027 │ localhost │     5433 │
</span></span><span class="line"><span class="cl">└─────────┴───────────┴──────────┘
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="table-colocation">Table Colocation</h4>
<p>Table Colocation means that related information is stored together on the same node. This saves network overhead by getting the desired data from one node at a time, and queries can be faster. Placing related data on different nodes allows queries to run efficiently and in parallel on each node.</p>
<p>If the value corresponding to the distribution column of a row falls within the hash range of a slice after hashing, the row is stored in that slice. Tracts with the same hash range are always placed on the same node. Rows with equal distribution column values are always located on different slice tables of the same node.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/01/ff0b7033cd3d462e827240fad2ad4f7e.png" alt="Table Colocation"></p>
<p>Consider the following tables that might be used by a web analytics system for a SaaS multi-tenant scenario.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">event</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">tenant_id</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">event_id</span><span class="w"> </span><span class="nb">bigint</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">page_id</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">payload</span><span class="w"> </span><span class="n">jsonb</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">tenant_id</span><span class="p">,</span><span class="w"> </span><span class="n">event_id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">tenant_id</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">page_id</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">path</span><span class="w"> </span><span class="nb">text</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">tenant_id</span><span class="p">,</span><span class="w"> </span><span class="n">page_id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Consider a query that might be launched by the Dashboard for this system&rsquo;s web page: &ldquo;Return the number of visits to all pages in Tenant 6 that start with &lsquo;/blog&rsquo; in the past week&rdquo;.</p>
<p>If our data exists in a single server, we can easily do the query using the following SQL.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">page_id</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">event_id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">page</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">event</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">payload</span><span class="o">-&gt;&gt;</span><span class="s1">&#39;time&#39;</span><span class="p">)::</span><span class="n">timestamptz</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">interval</span><span class="w"> </span><span class="s1">&#39;1 week&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">recent</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">USING</span><span class="w"> </span><span class="p">(</span><span class="n">tenant_id</span><span class="p">,</span><span class="w"> </span><span class="n">page_id</span><span class="p">)</span><span class="w"> </span><span class="c1">-- 相当于 ON p.tenant_id = r.tenant_id AND p.page_id = r.page_id
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">tenant_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;/blog%&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">page_id</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>When using large scale (Citus) clusters, certain modifications are required and there are two main options for sharding.</p>
<ul>
<li>
<p>Sharding by ID</p>
<p>As the number of tenants increases and the data grows across tenants, single server queries start to slow down and both memory and CPU can become bottlenecks.</p>
<p>In this case, large-scale (Citus) clustering comes in handy. When we decide to slice, the most important thing is to determine the distribution columns. For now, try using <code>event_id</code> and <code>page_id</code> as the distribution columns for the <code>event</code> and <code>page</code> tables, respectively.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- naively use event_id and page_id as distribution columns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">create_distributed_table</span><span class="p">(</span><span class="s1">&#39;event&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;event_id&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">create_distributed_table</span><span class="p">(</span><span class="s1">&#39;page&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;page_id&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>When data is scattered across different worker nodes, we can&rsquo;t perform join operations like we can on a single PostgreSQL node. We need to initiate two queries.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- (Q1) get the relevant page_ids
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">page_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">page</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;/blog%&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">tenant_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- (Q2) get the counts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">page_id</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">count</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> </span><span class="n">event</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">page_id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span><span class="cm">/*…page IDs from first query…*/</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">AND</span><span class="w"> </span><span class="n">tenant_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">AND</span><span class="w"> </span><span class="p">(</span><span class="n">payload</span><span class="o">-&gt;&gt;</span><span class="s1">&#39;time&#39;</span><span class="p">)::</span><span class="nb">date</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">interval</span><span class="w"> </span><span class="s1">&#39;1 week&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">page_id</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">count</span><span class="w"> </span><span class="k">DESC</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Running these two queries will access the data in the shards that are scattered across the nodes.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/01/88c183c30fb342e7961b43b083b5999d.png" alt="queries"></p>
<p>Afterwards, the application is required to integrate the results of these two steps.</p>
<p>In this case, data distribution creates significant drawbacks:</p>
<ul>
<li>the overhead of querying each slice and running multiple queries.</li>
<li>the overhead of Q1 returning many rows to the client.</li>
<li>Q2 becomes very large.</li>
<li>Partitioning into multiple queries requires changes to the application.</li>
</ul>
<p>Data is decentralized, so queries can be parallelized. It is only beneficial if the query is much larger than the overhead of querying many splits.</p>
</li>
<li>
<p>Slice by Tenant</p>
<p>In a large scale (Citus) cluster, rows with the same distribution column value are guaranteed to be located on the same node. Thus, it is only appropriate to choose <code>tenant_id</code> as the distribution column.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- co-locate tables by using a common distribution column
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">create_distributed_table</span><span class="p">(</span><span class="s1">&#39;event&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;tenant_id&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">create_distributed_table</span><span class="p">(</span><span class="s1">&#39;page&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;tenant_id&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">colocate_with</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s1">&#39;event&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This way, no modifications are required for original queries that can be run on a single PostgreSQL node.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="n">page_id</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="n">event_id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">page</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">LEFT</span><span class="w"> </span><span class="k">JOIN</span><span class="w">  </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">event</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="p">(</span><span class="n">payload</span><span class="o">-&gt;&gt;</span><span class="s1">&#39;time&#39;</span><span class="p">)::</span><span class="n">timestamptz</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">now</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">interval</span><span class="w"> </span><span class="s1">&#39;1 week&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">recent</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">USING</span><span class="w"> </span><span class="p">(</span><span class="n">tenant_id</span><span class="p">,</span><span class="w"> </span><span class="n">page_id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">tenant_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;/blog%&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">page_id</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Because of the filtering and joining of tenant_id, large scale (Citus) clusters know that the entire query can be responded to by using a same-location slice set containing that particular tenant&rsquo;s data. A single PostgreSQL node can respond to a query in a single step.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/01/6441a1d865dd4440b6d43d3aeff71b24.png" alt="query in a single step"></p>
<p>In some cases, the query and table schema must be modified to include the tenant ID in the unique constraints and join conditions. This modification is relatively straightforward.</p>
</li>
</ul>
<p>This completes our initial look at the three types of PostgreSQL services offered by Azure.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/postgresql/">PostgreSQL</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-04/golang-reverse-proxy/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go Simple and powerful reverse proxy</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-04/postgresql-mac-startup-failure/">
            <span class="next-text nav-default">Resolving PostgreSQL service startup failure on macOS</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
