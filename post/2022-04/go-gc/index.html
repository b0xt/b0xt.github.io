<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Analysis of GC implementation in Go language - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="In-depth analysis of the Go language GC implementation." /><meta name="keywords" content="golang, Gc" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/go-gc/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Analysis of GC implementation in Go language" />
<meta property="og:description" content="In-depth analysis of the Go language GC implementation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/go-gc/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-08T19:40:39+08:00" />
<meta property="article:modified_time" content="2022-04-08T19:40:39+08:00" />

<meta itemprop="name" content="Analysis of GC implementation in Go language">
<meta itemprop="description" content="In-depth analysis of the Go language GC implementation."><meta itemprop="datePublished" content="2022-04-08T19:40:39+08:00" />
<meta itemprop="dateModified" content="2022-04-08T19:40:39+08:00" />
<meta itemprop="wordCount" content="3407">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Analysis of GC implementation in Go language"/>
<meta name="twitter:description" content="In-depth analysis of the Go language GC implementation."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Analysis of GC implementation in Go language</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-08 19:40:39 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3407 words </span>
          <span class="more-meta"> 16 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#gc-to-the-rescue-of-programmers">GC to the Rescue of Programmers</a></li>
        <li><a href="#the-three-players-of-memory-management">The Three Players of Memory Management</a></li>
        <li><a href="#allocating-memory">Allocating memory</a>
          <ul>
            <li><a href="#relationship-between-memory-allocation-data-structures">Relationship between memory allocation data structures</a></li>
          </ul>
        </li>
        <li><a href="#garbage-collection">Garbage collection</a>
          <ul>
            <li><a href="#waste-sorting">Waste sorting</a></li>
            <li><a href="#gc-flow">GC Flow</a></li>
            <li><a href="#markup-flow">Markup flow</a></li>
            <li><a href="#assist-marker">Assist marker</a></li>
            <li><a href="#object-loss-problem">Object Loss Problem</a></li>
            <li><a href="#write-barrier">write barrier</a></li>
            <li><a href="#recycle-process">Recycle process</a></li>
          </ul>
        </li>
        <li><a href="#problem-analysis">Problem Analysis</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>In the various widely circulated C rules, there is generally this mysterious rule that no local variables can be returned.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* ... */</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When the function returns, the stack frame of the function (stack frame) is destroyed, and the memory referenced by the destroyed location is lightly confused with data, and heavily segmentation fault.</p>
<p>After a long period of study, finally became a master of C language, but still can not escape from the complex heap of object reference relationship resulting in dangling pointer.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/8e6468adf5894d6982deb4bd8789cbb9.gif" alt="dangling pointer"></p>
<p>This is a typical dangling pointer problem, and the object dependencies on the heap can be very complex. The object dependencies on the heap can be very complex. We have to draw the object graph first to write the free logic correctly.</p>
<p>It is unscientific and unreasonable to rely on people to deal with these problems. C and C++ programmers have been suffering for decades and should not repeat the same mistakes.</p>
<h2 id="gc-to-the-rescue-of-programmers">GC to the Rescue of Programmers</h2>
<p>Garbage Collection, also known as automatic memory management technology, is quite widely used in modern programming languages, with the common Java, Go, and C# all integrating corresponding implementations in the language&rsquo;s runtime.</p>
<p>In traditional programming languages we need to pay attention to where objects are allocated and have to choose for ourselves whether they are allocated on the heap or the stack, but in Go, a language with GC, an escape analysis feature is integrated to help us automatically determine whether an object should be on the heap or the stack, and you can use <code>go build -gcflags=&quot;-m&quot;</code> to observe the results of the escape analysis.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10240</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">println</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>Larger objects are also placed on the heap.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/c54866d7793e44cc8de08634a2f319ce.png" alt="go build -gcflags=&quot;-m&quot;"></p>
<blockquote>
<p>The output of executing gcflags=&quot;-m&quot; shows that an escape has occurred.</p>
</blockquote>
<p>If the object is allocated on the stack, it is less expensive to manage and the object can be allocated and released by moving the top-of-stack register. If it is allocated on the heap, it has to go through layers of memory request process. However, these processes are transparent to the user and we do not need to care about it when writing code. It is only when optimization is needed that specific escape analysis rules need to be investigated.</p>
<p>The combination of escape analysis and garbage collection has greatly freed programmers&rsquo; minds, and it seems that we no longer need to worry about memory allocation and release when writing code.</p>
<p>However, all abstractions have a cost, and that cost is either spent at compile time or at runtime.</p>
<p>GC is a solution that chooses to solve the problem at runtime, but in extreme cases GC itself can still cause problems that are hard to ignore.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/cd43ddbc33ed42be860c46d27c7a46c2.png" alt="gc"></p>
<p>The scenario above is that hundreds of millions of kv are cached in memory, and the CPU used by GC is even more than 90% of the total CPU usage at this point. Caching objects in memory in a simple and brutal way turns out to be a CPU killer in the end. It eats up a lot of server resources, which is obviously not the result we expect.</p>
<p>To properly analyze the cause, we need to have a slightly deeper understanding of the implementation mechanism of GC itself.</p>
<h2 id="the-three-players-of-memory-management">The Three Players of Memory Management</h2>
<p>When discussing memory management, we will mainly talk about the three players, mutator, allocator and garbage collector.</p>
<ul>
<li>
<p>mutator: refers to our application, i.e. application. We see the objects on the heap as a graph, and if we look beyond the application, the application code is constantly modifying the pointing relationships in this graph of heap objects. The following diagram can help us understand the effect of mutator on the objects on the heap.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/4f4cb816190e47b88087feaf09233537.gif" alt="mutator"></p>
<blockquote>
<p>The reference relationships of objects are constantly modified during the application runtime.</p>
</blockquote>
</li>
<li>
<p>allocator: well understood, memory allocator, applications needing memory have to apply to allocator. allocator to maintain the data structure of memory allocation, multi-threaded allocator to consider the impact of locks in high concurrency scenarios, and targeted design to reduce lock conflicts.</p>
</li>
<li>
<p>collector: garbage collector. Dead heap objects and unused heap memory are reclaimed by the collector and eventually returned to the operating system. The heap objects that survive in memory need to be scanned, and after the scan is complete, the objects that are not scanned are inaccessible heap garbage and need to be reclaimed from the memory they occupy.</p>
</li>
</ul>
<p>The interaction process of the three can be represented by the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/7403fbb2bbb4432dbba59a0086abc53f.png" alt="mutator, allocator and garbage collector"></p>
<h2 id="allocating-memory">Allocating memory</h2>
<p>The application uses mmap to request memory from the OS. The interface provided by the OS is simpler, and mmap returns a contiguous region of memory.</p>
<p>mutator requests memory from an application perspective, where I need the memory corresponding to a particular struct, a particular slice, and there is a gap between this and the interface to get memory from the OS. There is a gap between this and the interface to get memory from the OS. It is necessary for allocator to do the mapping and conversion to map the memory viewed as a &ldquo;block&rdquo; to the memory viewed as an &ldquo;object&rdquo;.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/a6fa319f84d547c6b4b89b8514af2c54.png" alt="go Allocating memory"></p>
<p>On modern CPUs, we also have to consider the efficiency of memory allocation itself. Small objects are constantly created and destroyed during application execution, and it would be costly to interact with the OS for each object allocation and release. This requires a well-designed multi-level cache for memory allocation at the application level to minimize lock contention during high-frequency creation and destruction of small objects, a problem that has been solved in the traditional C/C++ language, which is tcmalloc.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/362033ed8fca4cc0878dcbe874e41fc6.png" alt="tcmalloc"></p>
<p>The memory allocator in Go is basically a 1:1 port of tcmalloc. After all, it&rsquo;s all a Google project.</p>
<p>In Go, the memory allocation process is divided into three categories based on the presence or absence of pointers in the object and the size of the object.</p>
<ul>
<li>tiny : size &lt; 16 bytes &amp;&amp; has no pointer(noscan)</li>
<li>small : has pointer(scan) || (size &gt;= 16 bytes &amp;&amp; size &lt;= 32 KB)</li>
<li>large : size &gt; 32 KB</li>
</ul>
<p>The most complex part of the memory allocation process is the allocation of tiny types.</p>
<p>We can analogize the memory allocation path to the CPU&rsquo;s multi-level cache. Here the tiny inside the mcache can be analogous to the L1 cache, while the elements in the alloc array can be analogous to the L2 cache, the global mheap.mcentral structure is the L3 cache, and mheap.arena is L4. The memory is distributed downwards by pageAlloc to manage the free memory in arena.</p>
<table>
<thead>
<tr>
<th>L1</th>
<th>L2</th>
<th>L3</th>
<th>L4</th>
</tr>
</thead>
<tbody>
<tr>
<td>mcache.tiny</td>
<td>mcache.alloc[]</td>
<td>mheap.central</td>
<td>mheap.arenas</td>
</tr>
</tbody>
</table>
<p>If L4 does not meet our memory allocation needs, then we need to ask the OS for memory.</p>
<p>Compared to the tiny four-level allocation path, the small type of memory does not have a local mcache.tiny cache, but the rest is identical to the tiny allocation path.</p>
<table>
<thead>
<tr>
<th>L1</th>
<th>L2</th>
<th>L3</th>
</tr>
</thead>
<tbody>
<tr>
<td>mcache.alloc[]</td>
<td>mheap.central</td>
<td>mheap.arenas</td>
</tr>
</tbody>
</table>
<p>The large memory allocation is a little bit special. Instead of the complicated caching process above, we ask for memory directly from mheap.arenas and go directly to the pageAlloc page allocator.</p>
<p>The page allocator has iterated through many versions in Go, from simple freelist structures, to treap structures, to the latest version of radix structures, and its lookup time complexity has gone from O(N) -&gt; O(log(n)) -&gt; O(1).</p>
<p>In the current version, only constant time complexity is needed to determine whether the radix tree of free pages can satisfy the memory allocation requirement. If it is not satisfied, the arena continues to be sliced or more arena is requested from the OS.</p>
<h3 id="relationship-between-memory-allocation-data-structures">Relationship between memory allocation data structures</h3>
<p>arenas are in units of 64MB. arenas are sliced into pages of 8KB, one or more pages can form an mspan, and each mspan can be divided into multiple elements according to the sizeclass.</p>
<p>The following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/9755598e12514766a5f106effe0b75ef.png" alt="mspan "></p>
<blockquote>
<p>The relationship between the various memory allocation structures, with the structure of the page allocator omitted from the diagram.</p>
</blockquote>
<p>Each mspan has an allocBits structure. When allocating an element from an mspan, you just need to set the bit position one of the corresponding element position in the mspan. In fact, it is the bit position one of the corresponding allocBits of the mspan, and there are some optimizations in the code, so we won&rsquo;t go into details.</p>
<h2 id="garbage-collection">Garbage collection</h2>
<p>Go uses the concurrent mark and sweep algorithm as its GC implementation. The concurrent mark and sweep algorithm cannot solve the memory fragmentation problem, while tcmalloc alleviates the memory fragmentation problem to some extent, and the two complement each other.</p>
<p><strong>This is not to say that tcmalloc is completely free of memory fragmentation, search for max waste</strong> in the code if you don&rsquo;t believe me.</p>
<h3 id="waste-sorting">Waste sorting</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/017c91c9cea74a7c9b6d425b1ab4aba2.png" alt="Waste sorting"></p>
<blockquote>
<p>Syntactic garbage and semantic garbage.</p>
</blockquote>
<p><strong>semantic garbage</strong>, also known as memory leaks in some scenarios.</p>
<p>Semantic garbage refers to objects that are syntactically reachable (can be referenced by local and global variables), but semantically they are garbage and the garbage collector can&rsquo;t do anything about it.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/01702e6e07dc47189b53e19cdb45447f.png" alt="semantic garbage"></p>
<p>We initialize a slice, the elements of which are pointers, each pointing to an object on the heap of 10MB in size.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/86a3c1af735d4cf29c98b264ad3ec8bf.png" alt="semantic garbage"></p>
<p>When this slice is shrunk, the last two elements of the underlying array are no longer accessible, but their associated heap memory is still unfree.</p>
<p>In a similar scenario, you may need to <strong>set the array elements to nil</strong> before scaling.</p>
<p><strong>syntactic garbage.</strong></p>
<p>Syntactic garbage is about those objects that are syntactically unreachable, and these are the main targets of the garbage collector.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/52268c02c2a4418698bcfe61b4a29a89.png" alt="syntactic garbage"></p>
<p>After allocOnHeap returns, a on the heap is inaccessible and becomes syntactic garbage.</p>
<h3 id="gc-flow">GC Flow</h3>
<p>Almost every iteration of Go optimizes the GC.</p>
<p>After many optimizations, the newer GC flow is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/7cd689449db34235bbd91d1009ba1dbe.png" alt="go GC flow"></p>
<p>There are two brief stw before the start of concurrent tagging and when concurrent tagging terminates. This stw can be observed using pprof&rsquo;s pauseNs or captured directly into the monitoring system.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/a4f3a29145a34ba2b132892e19cb3bc2.png" alt="go GC"></p>
<blockquote>
<p>pauseNs is the duration of each stw.</p>
</blockquote>
<p>Despite the official claim that Go&rsquo;s stw is already sub-millisecond, we still see millisecond stw in high stress systems.</p>
<h3 id="markup-flow">Markup flow</h3>
<p>The Go language uses a three-color abstraction as its implementation of concurrent tagging, starting with an understanding of the three color abstractions.</p>
<ul>
<li>Black: has been scanned and the child nodes have been scanned. (gcmarkbits = 1 and is outside the queue)</li>
<li>Gray: already scanned, child nodes not scanned. (gcmarkbits = 1, and inside the queue)</li>
<li>White: not scanned, collector does not know any relevant information.</li>
</ul>
<p>The main purpose of the three-color abstraction is to enable the garbage collection process to be executed concurrently with the application process, so that the object scanning process can be split into multiple stages without the need to complete the entire scanning process at once.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/898fa54e2e314a709eed2d21a2eb2181.png" alt="three color abstractions"></p>
<blockquote>
<p>GC threads and application threads are executed concurrently in most cases.</p>
</blockquote>
<p>The starting point of the GC scan is the root object, ignoring those unimportant (finalizer-related first omitted), the common root object can be seen in the following figure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/39d2d8cff0fe4f87ae315ee2fc1becca.png" alt="root object"></p>
<p>So in Go, scanning from the root means scanning from the .bss segment, the .data segment, and the goroutine&rsquo;s stack, eventually traversing the entire object tree on the heap.</p>
<p>The marking process is a breadth-first traversal process that scans nodes, pushes the nodes&rsquo; children into the task queue, and then recursively scans the children&rsquo;s children until all the work queues are emptied.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/bdeb22678efe4d2f9eebd576d45f6e87.gif" alt="markprocess"></p>
<blockquote>
<p>The process of marking workers in the background.</p>
</blockquote>
<p>The mark phase marks the white object and advances it into the queue as a gray object. We can see the exact process of scanobject.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/d28408723bab47dd8e468787c4013e11.gif" alt="scanobject"></p>
<blockquote>
<p>A mark worker in the background performs an object scan and pushes ptr to the work queue.</p>
</blockquote>
<p>During the mark process, the gc mark worker will pop objects from the work queue (gcw) while pushing its child objects to the work queue (gcw), and if the work queue is full, it will have to transfer some of the elements to the global queue.</p>
<p>We know that objects on the heap are essentially graphs and will store references when they cross each other, and there is simple pruning logic in the marking process.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/53b32fa4b6d84219a9be004c04a64277.png" alt="go gc"></p>
<p>D is a common child of A and B. It will naturally reduce branches during the marking process to prevent wasting computational resources by repeated marking.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/b390ebac58a9462e826ebf0fff5f2d7d.png" alt="go gc"></p>
<p>If multiple background mark workers do generate concurrency, the marker uses atomic.Or8, which is also concurrency-safe.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/a7d371b4904e44af904470ee9cf98d9c.png" alt="go gc"></p>
<h3 id="assist-marker">Assist marker</h3>
<p>When the application allocates memory too fast, the mark worker in the background cannot finish the marking work in time, and then the application itself needs to do heap memory allocation, it will determine whether it needs to assist the GC marking process appropriately to prevent the application from OOM due to the fast allocation.</p>
<p>When this happens, we will see the corresponding call stack for assisting the marker in the flame chart.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/fbf70d76da3449c28dad203b548fd194.png" alt="flame chart"></p>
<p>Assisted tagging can have an impact on the response latency of the application and can be optimized by trying to reduce the number of objects allocated to the application.</p>
<p>Go implements the assisted tagging process internally through a bookkeeping repayment system, which is not the focus of this article, so I&rsquo;ll skip it for now.</p>
<h3 id="object-loss-problem">Object Loss Problem</h3>
<p>As mentioned earlier, the GC thread/co-process is executed concurrently with the application thread/co-process, and the application will also keep modifying the reference relationship of objects on the heap during the GC tagging worker&rsquo;s work. The following is a typical case when the application and GC are executed concurrently, and the object is mistakenly reclaimed by GC due to the application&rsquo;s change of the pointer that causes the object to miss tagging.</p>
<p>As shown in the figure, during the GC tagging process, the application dynamically modifies the pointers of A and C so that the internal pointer of object A points to B and the internal pointer of C points to D. If the tagging process does not sense this change, eventually object B is white after the tagging is completed and will be incorrectly recognized as memory garbage and reclaimed.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/256ce7231c9d45a9a9a1039df581355a.gif" alt="Object Loss"></p>
<p>In order to solve the problem of missing markers and wrong markers, we first need to define &ldquo;tricolor invariant&rdquo;, if the reference relationship of objects on our heap can meet tricolor invariant no matter how to modify, then no object loss problem will occur.</p>
<p>Strong tricolor invariant (strong tricolor invariant), prohibit black objects pointing to white objects.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/1ce7bf1f573b4697a6fcc03bea0075b2.png" alt="strong tricolor invariant"></p>
<p>Weak tricolor invariant (weak tricolor invariant), black objects can point to white objects, but the white objects pointed to must have paths that can be reached from the gray objects.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/b3c643ba9f374b9eb78e2f1c4138dcfd.png" alt="weak tricolor invariant"></p>
<p>No matter how the application modifies the relationship of objects on the heap during concurrent execution with GC, as long as the objects on the heap can satisfy any one of the invariants after the modification, no object loss problem will occur.</p>
<p>The implementation of strong/weak tricolor invariants requires the introduction of a barrier technique. In Go language, write barrier is used to solve the above problem.</p>
<h3 id="write-barrier">write barrier</h3>
<p>barrier is essentially : snippet of code insert before pointer modify.</p>
<p><strong>There is also a memory barrier in the concurrent programming world, but its meaning is completely different from the GC world</strong>, so be careful not to get confused when reading the material.</p>
<p>The Go language GC has a write barrier, not a read barrier.</p>
<p>The global variable runtime.writeBarrier.enabled is changed to true during the stw phase before the application enters the GC marking phase, and all heap pointer modification operations are then additionally called to runtime.gcWriteBarrier before they are modified.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/b84d2d37b81346b7a698c1fc9689f3ef.png" alt="write barrier"></p>
<p>In the disassembly result, we can find the original code location by the number of lines.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/9b1f9f62b46c4583a25122973b2a51be.png" alt="write barrier"></p>
<p>There are two common write barriers.</p>
<ul>
<li>
<p>Dijistra Insertion Barrier, where the new object pointed to is marked gray when the pointer is modified.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/666b3515bc154d7fb62e8064e300113c.png" alt="Dijistra Insertion Barrier"></p>
</li>
<li>
<p>Yuasa Deletion Barrier, when the pointer is modified, the object pointed to before the modification is to be grayed out.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/7b23a40ea00844688b8b7b883a9b0a8f.png" alt="Yuasa Deletion Barrier"></p>
</li>
</ul>
<p>Go&rsquo;s write barrier is a mix of both of these barriers.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/031413920297405aaed486eef4840368.png" alt="Go&amp;rsquo;s write barrier"></p>
<p>This does not match the Go language&rsquo;s implementation of the proposal for the hybrid barrier. This is how the proposal was originally written.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/7576c110742249d8a9c07662952fec18.png" alt="proposal"></p>
<p>But the cost of color determination on the stack is very high, so the official choice is still a simpler implementation, i.e. an implementation where both old and new objects with broken pointers are marked gray.</p>
<p>If all objects in Go are allocated on the heap, theoretically we can achieve strong/weak tricolor invariance by choosing any of Dijistra or Yuasa, why do it so complicated?</p>
<p>Because in Go language, objects on the stack are not turned on the write barrier even during the mark execution phase due to too frequent object operations on the stack. If we use only Dijistra or only Yuasa Barrier, we will have the problem of object loss:.</p>
<ul>
<li>Object loss problem of Dijistra Insertion Barrier.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/a9291826348348ef8c61a8ac8abcf475.gif" alt="Dijistra Insertion Barrier obj loss"></p>
<ul>
<li>The object loss problem of Yuasa Deletion Barrier.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/8bb3caa7cf2546b2a502bad2080774d9.gif" alt="Yuasa Deletion Barrier obj loss"></p>
<p>Earlier Go used only Dijistra barriers, but because of the aforementioned object loss problem, a stack rescan was required on the second stw cycle. When the number of goroutines is high, this results in a long stw time.</p>
<p>To eliminate stack rescan, but either barrier alone cannot satisfy Go&rsquo;s requirements, so the latest version of Go&rsquo;s hybrid barrier is actually Dijistra Insertion Barrier + Yuasa Deletion Barrier.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/59ba4c89e9d14ac1b43b5850c7033b35.png" alt="Go&amp;rsquo;s hybrid barrier"></p>
<p>The hybrid write barrier pushes two pointers to the wbBuf structure of p. Let&rsquo;s take a look at this process.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/edf362294f3c4dc6a031c967c23cc5de.gif" alt="write barrier buffer"></p>
<p>Now we can see the complete process of the mutator and the mark worker in the background during concurrent execution.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/238ab37ea904469493c698e6c13d0e25.gif" alt="mark worker full process"></p>
<h3 id="recycle-process">Recycle process</h3>
<p>Compared to the complex tagging process, object recycling and memory release is much simpler.</p>
<p>The process starts with two special goroutines.</p>
<ul>
<li>One is called sweep.g, which is mainly responsible for cleaning up dead objects and merging related free pages.</li>
<li>One is called scvg.g, which is mainly responsible for returning memory to the operating system.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">(dlv) goroutines
</span></span><span class="line"><span class="cl">* Goroutine 1 - User: ./int.go:22 main.main (0x10572a6) (thread 5247606)
</span></span><span class="line"><span class="cl">  Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x102e596) [force gc (idle) 455634h24m29.787802783s]
</span></span><span class="line"><span class="cl">  Goroutine 3 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x102e596) [GC sweep wait]
</span></span><span class="line"><span class="cl">  Goroutine 4 - User: /usr/local/go/src/runtime/proc.go:367 runtime.gopark (0x102e596) [GC scavenge wait]
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note the GC sweep wait and GC scavenge wait here, which are the two goroutines.</p>
<p>When the GC marking process is finished, the sweep goroutine is woken up to do the sweeping, which is actually a cycle of sweepone -&gt; sweep. for each mspan, sweep.g does the job of replacing the bitmap used during allocation with the bitmap generated during marking.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/55e911263b8b487c97db97f87ded0ce6.png" alt="go gc bitmap"></p>
<p>The destination of the mspan is then determined based on the slots in the mspan.</p>
<ul>
<li>If the number of alive objects in the mspan = 0, i.e. all elements become memory garbage, then execute freeSpan -&gt; return the pages used by the constituent mspan and update the global page allocator summary information</li>
<li>If there are no empty slots in the mspan, all objects are alive, put them into the fullSwept queue</li>
<li>If there are empty slots in the mspan, the mspan can still be used for memory allocation, put it in the partialSweep queue</li>
</ul>
<p>After that the &ldquo;scavenger&rdquo; is woken up and executes a linear process that runs all the way to return the page memory to the OS.</p>
<ul>
<li>bgscavenge -&gt; pageAlloc.scavenge -&gt; pageAlloc.scavengeOne -&gt; pageAlloc.scavengeRangeLocked -&gt; sysUnused -&gt; madvise</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/f146002e35864d8999498498a790aec2.png" alt="mspan"></p>
<h2 id="problem-analysis">Problem Analysis</h2>
<p>From the preceding basics, we can summarize the key points of garbage collection in Go language: the</p>
<ul>
<li>no generation separation</li>
<li>Concurrency with application execution</li>
<li>Assist in marking processes</li>
<li>write barrier on concurrent execution</li>
</ul>
<p>Because there is no generation, we need to find ways to reduce the cost of GC scans when we encounter scenarios where we need to keep tens of millions of kv maps in memory (e.g., machine learning feature systems).</p>
<p>Because of assisted markers, when the application&rsquo;s GC occupies more than 25% of CPU, it will trigger a large number of assisted markers, which will affect the application&rsquo;s latency, and it is also necessary to optimize the GC.</p>
<p>Pool can bring a good optimization effect for simple business, but if you encounter some complex business scenarios, you should also consider offheap and other GC cheating solutions, such as <a href="https://dgraph.io/blog/post/manual-memory-management-golang-jemalloc/">dgraph&rsquo;s solution</a>.</p>
<p>Since this article focuses on memory allocation and GC implementation, it will not be expanded.</p>
<p>All the memory management terms covered in this article can be found at: <a href="https://memorymanagement.org">https://memorymanagement.org</a>.</p>
<p>For the theory of garbage collection, we recommend reading: &ldquo;gc handbook&rdquo;, which can answer all your questions.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-04/vue-hook/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">10 useful custom hooks vue.js</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-04/musk-twitter/">
            <span class="next-text nav-default">Musk became a major shareholder of Twitter caused a &#34;shock&#34;: some people made a billion before others, some resigned, some angry mockery</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
