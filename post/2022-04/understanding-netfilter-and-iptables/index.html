<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>In-depth understanding of netfilter and iptables - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore the design and implementation of netfilter and iptables." /><meta name="keywords" content="linux, netfilter, iptables" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/understanding-netfilter-and-iptables/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="In-depth understanding of netfilter and iptables" />
<meta property="og:description" content="Explore the design and implementation of netfilter and iptables." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/understanding-netfilter-and-iptables/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-15T13:55:03+08:00" />
<meta property="article:modified_time" content="2022-04-15T13:55:03+08:00" />

<meta itemprop="name" content="In-depth understanding of netfilter and iptables">
<meta itemprop="description" content="Explore the design and implementation of netfilter and iptables."><meta itemprop="datePublished" content="2022-04-15T13:55:03+08:00" />
<meta itemprop="dateModified" content="2022-04-15T13:55:03+08:00" />
<meta itemprop="wordCount" content="2961">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="In-depth understanding of netfilter and iptables"/>
<meta name="twitter:description" content="Explore the design and implementation of netfilter and iptables."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">In-depth understanding of netfilter and iptables</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-15 13:55:03 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2961 words </span>
          <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#netfilter-design-and-implementation">Netfilter Design and Implementation</a>
          <ul>
            <li><a href="#kernel-packet-processing-flow">Kernel packet processing flow</a></li>
            <li><a href="#netfilter-hooks">netfilter hooks</a></li>
            <li><a href="#callback-functions-and-priorities">Callback functions and priorities</a></li>
          </ul>
        </li>
        <li><a href="#iptables">iptables</a>
          <ul>
            <li><a href="#kernel-space-module">Kernel space module</a></li>
            <li><a href="#user-space-tables-chains-and-rules">User-space tables, chains and rules</a></li>
          </ul>
        </li>
        <li><a href="#conntrack">conntrack</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Netfilter (in conjunction with iptables) enables user-space applications to register the processing rules applied by the kernel network stack when processing packets, enabling efficient network forwarding and filtering. Many common host firewall applications as well as Kubernetes service forwarding are implemented with iptables.</p>
<p>Most of the introductory articles on netfilter describe only abstract concepts, but the basic implementation of the kernel code is not too complicated. This article mainly refers to the Linux kernel code version 2.6 (earlier versions are simpler), which may differ significantly from the latest version 5.x, but the basic design has not changed much and does not affect the understanding of its principles.</p>
<p>This article assumes that the reader already has a basic understanding of the TCP/IP protocol.</p>
<h2 id="netfilter-design-and-implementation">Netfilter Design and Implementation</h2>
<p>The definition of netfilter is a network packet processing framework that works in the Linux kernel. In order to thoroughly understand how netfilter works, we first need to establish a basic understanding of the packet processing path in the Linux kernel.</p>
<h3 id="kernel-packet-processing-flow">Kernel packet processing flow</h3>
<p>The packet processing path in the kernel, i.e. the chain of kernel code calls for processing network packets, can be broadly divided into multiple layers according to the TCP/IP model, taking the reception of an IPv4 tcp packet as an example.</p>
<ol>
<li>
<p>At the physical-network device layer, the NIC writes the received packet to a <code>ring buffer</code> in memory via DMA. After a series of interrupts and scheduling, the OS kernel calls <code>__skb_dequeue</code> to add the packet to the processing queue of the corresponding device and converts it into a <code>sk_buffer</code> type (i.e., socket buffer - the <code>__skb_dequeue</code>). The packets can be considered as <code>sk_buffer</code>), and finally the <code>netif_receive_skb</code> function is called to sort the packets by protocol type and jump to the corresponding processing function. This is shown in the following figure.
<img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/f50ca2d2f253442295f8d1c12cc596fc.png" alt="netif_receive_skb"></p>
</li>
<li>
<p>Assuming the packet is an IP protocol packet, the corresponding receive packet processing function <code>ip_rcv</code> is called and the packet processing enters the network (IP) layer. <code>ip_rcv</code> checks the IP initials of the packet and discards the erroneous packets, and aggregates the sliced IP packets if necessary. The <code>ip_rcv_finish</code> function is then executed to route the packet and decide whether to deliver the packet locally or forward it to another host. Assuming the destination of the packet is this host, the next <code>dst_input</code> function will call the <code>ip_local_deliver</code> function. The <code>ip_local_deliver</code> function will determine the protocol type of the packet based on the protocol number in the IP header, and finally call the packet processing function of the corresponding type. In this example, the <code>tcp_v4_rcv</code> function for TCP protocol will be called, and then the packet processing will enter the transport layer.</p>
</li>
<li>
<p>The <code>tcp_v4_rcv</code> function also reads the TCP header of the packet and calculates the checksum, and then maintains some necessary state in the TCP control buffer corresponding to the packet, including the TCP sequence number and SACK number. The function next calls <code>__tcp_v4_lookup</code> to look up the socket corresponding to the packet, and if it does not find it or if the socket&rsquo;s connection status is <strong>TCP_TIME_WAIT</strong>, the packet is discarded. If the socket is unlocked, the packet will enter the <code>prequeue</code> queue by calling the <code>tcp_prequeue</code> function, after which the packet will be available for processing by the user program in the user state. The processing flow at the transport layer is beyond the scope of this article and is actually much more complex.</p>
</li>
</ol>
<h3 id="netfilter-hooks">netfilter hooks</h3>
<p>Let&rsquo;s get down to business. The primary component of netfilter is netfilter hooks.</p>
<h4 id="hook-trigger-points">hook trigger points</h4>
<p>For different protocols (IPv4, IPv6 or ARP, etc.), the Linux kernel network stack triggers the corresponding hooks at predefined locations along the packet processing path of the protocol stack. The locations of the trigger points in the different protocol processing flows and the corresponding hook names (in bold outside the blue rectangle) are listed below, with a focus on the IPv4 protocol.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/a4c16b6da0c14bbba0c6c4af30016b7b.png" alt="hook trigger points"></p>
<p>The so-called hooks are essentially enumerated objects in the code (integers with values incrementing from 0).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">nf_inet_hooks</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_INET_PRE_ROUTING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_INET_LOCAL_IN</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_INET_FORWARD</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_INET_POST_ROUTING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_INET_NUMHOOKS</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Each hook corresponds to a specific trigger point location in the kernel network stack, for example, the IPv4 stack has the following netfilter hooks definition.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/a88d01f135104780b4663ee50eed8bc2.png" alt="netfilter hooks definition"></p>
<ul>
<li>NF_INET_PRE_ROUTING: This hook is executed in the <code>ip_rcv</code> function of the IPv4 stack or the <code>ipv6_rcv</code> function of the IPv6 stack. The first hook trigger point for all incoming packets (in fact, newer versions of Linux add the INGRESS hook as the earliest trigger point) is executed before the routing determination is made.</li>
<li>NF_INET_LOCAL_IN: This hook is executed in the <code>ip_local_deliver()</code> function of the IPv4 stack or the <code>ip6_input()</code> function of the IPv6 stack. After routing judgment, all incoming packets whose destination address is local arrive at this hook trigger point.</li>
<li>NF_INET_FORWARD: This hook is executed in the <code>ip_forward()</code> function of the IPv4 protocol stack or the <code>ip6_forward()</code> function of the IPv6 protocol stack. After routing, all incoming packets whose destination address is not local arrive at this hook trigger point.</li>
<li>NF_INET_LOCAL_OUT: This hook is executed in the <code>__ip_local_out()</code> function of the IPv4 stack or the <code>__ip6_local_out()</code> function of the IPv6 stack. All locally generated packets ready to be sent first reach this hook trigger point after entering the network stack.</li>
<li>NF_INET_POST_ROUTING: This hook is executed in the <code>ip_output()</code> function of the IPv4 protocol stack or the <code>ip6_finish_output2()</code> function of the IPv6 protocol stack. Locally generated packets that are ready to be sent or forwarded will reach this hook trigger point after routing determination.</li>
</ul>
<h4 id="nf_hook-macro-and-netfilter-vector">NF_HOOK macro and netfilter vector</h4>
<p>The macro <code>NF_HOOK</code> is called uniformly for all trigger point locations to trigger the hook.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">NF_HOOK</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">pf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">NF_HOOK_THRESH</span><span class="p">(</span><span class="n">pf</span><span class="p">,</span> <span class="n">hook</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">okfn</span><span class="p">,</span> <span class="n">INT_MIN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The parameters received by <code>NF-HOOK</code> are as follows.</p>
<ul>
<li>pf: The protocol family of the packet, <code>NFPROTO_IPV4</code> for IPv4.</li>
<li>hook: The netfilter hook enumeration object shown in the above figure, such as NF_INET_PRE_ROUTING or NF_INET_LOCAL_OUT.</li>
<li>skb: SKB object indicating the packet being processed.</li>
<li>in: The input network device for the packet.</li>
<li>out: The output network device for the packet.</li>
<li>okfn: A pointer to a function that will be called when this hook is about to terminate, usually passed to the next processing function on the packet processing path.</li>
</ul>
<p>The return value of <code>NF-HOOK</code> is one of the following netfilter vectors with a specific meaning.</p>
<ol>
<li>NF_ACCEPT: Continue normally on the processing path (actually the last incoming <code>okfn</code> is executed in <code>NF-HOOK</code>).</li>
<li>NF_DROP: Discard the packet and terminate processing.</li>
<li>NF_STOLEN: Packet forwarded, terminate processing. 4.</li>
<li>NF_QUEUE: Queue the packet for other processing.</li>
<li>NF_REPEAT: Re-call the current hook.</li>
</ol>
<p>Going back to the source code, the IPv4 kernel network stack calls <code>NF_HOOK()</code> in the following code module.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/6426fbc785864a4fb81dae65902aabac.png" alt="NF_HOOK"></p>
<p>The actual call is based on the source code of <a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/ip_forward.c#L115">net/ipv4/ip_forward.c</a> for packet forwarding, where the NF_HOOK macro is called at the end of the <code>ip_forward</code> function on line 115 with the <strong>NF_INET_FORWARD</strong> hook as an input. The next function in the network stack, <code>ip_forward_finish</code>, is passed in as an <code>okfn</code> argument.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">ip_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">.....</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="n">rt</span><span class="o">-&gt;</span><span class="n">rt_flags</span><span class="o">&amp;</span><span class="n">RTCF_DOREDIRECT</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">opt</span><span class="o">-&gt;</span><span class="n">srr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skb_sec_path</span><span class="p">(</span><span class="n">skb</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="n">ip_rt_send_redirect</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">skb</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">rt_tos2priority</span><span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">tos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">NF_HOOK</span><span class="p">(</span><span class="n">NFPROTO_IPV4</span><span class="p">,</span> <span class="n">NF_INET_FORWARD</span><span class="p">,</span> <span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">          <span class="n">rt</span><span class="o">-&gt;</span><span class="n">dst</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="n">ip_forward_finish</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">.....</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="callback-functions-and-priorities">Callback functions and priorities</h3>
<p>Another component of netfilter is the hook callback function. The kernel network stack uses both hooks to represent specific trigger locations and hooks (of integer values) as data indexes to access callback functions corresponding to trigger points.</p>
<p>Other modules of the kernel can register callback functions with the specified hook through the api provided by netfilter. The same hook can register multiple callback functions, and the <strong>priority</strong> parameter specified during registration can specify the priority of the callback function when it is executed.</p>
<p>To register a callback function for a hook, first define a <code>nf_hook_ops</code> structure (or an array of such structures), which is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* User fills in from here down. */</span>
</span></span><span class="line"><span class="cl">    <span class="n">nf_hookfn</span> <span class="o">*</span><span class="n">hook</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">u_int8_t</span> <span class="n">pf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hooknum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* Hooks are ordered in ascending priority. */</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>There are 3 important members in the definition.</p>
<ul>
<li>hook: the callback function to be registered, the function parameters are defined similar to <code>NF_HOOK</code> and can be nested with other functions via the <code>okfn</code> parameter.</li>
<li>hooknum: The enumeration value of the target hook to be registered.</li>
<li>priority: the priority of the callback function, <strong>the smaller value is executed first</strong>.</li>
</ul>
<p>After defining the structure, one or more callback functions can be registered by <code>int nf_register_hook(struct nf_hook_ops *reg)</code> or <code>int nf_register_hooks(struct nf_hook_ops *reg, unsigned int n);</code> respectively. All the <code>nf_hook_ops</code> under the same netfilter hook are registered to form a Linked list structure in order of priority, and the registration process will find the appropriate position from the Linked list according to the priority, and then perform the Linked list insertion operation.</p>
<p>When the <code>NF-HOOK</code> macro is executed to trigger the specified hook, the <code>nf_iterate</code> function will be called to iterate over the <code>nf_hook_ops</code> Linked list corresponding to this hook, and each <code>nf_hook_ops</code> will be called in turn with the registered function member <code>hookfn</code>. The diagram is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/6fad941df3b646c3a9489c0915433266.png" alt="hookfn"></p>
<p>This chaining of callback functions works in a way that has also led to the netfilter hook being called Chain, a connection that is particularly reflected in the iptables introduction below.</p>
<p>Each callback function must also return a netfilter vector; if the vector is <strong>NF_ACCEPT</strong>, <code>nf_iterate</code> will continue to call the next <code>nf_hook_ops</code> callback function until all callbacks are called and <strong>NF_ACCEPT</strong> is returned; if the vector is <strong>NF_DROP</strong>, it will break the traversal and return directly to <strong>NF_DROP</strong>; <strong>if the vector is NF_REPEAT, the callback function will be re-executed</strong>. The return value of <code>nf_iterate</code> will also be used as the return value of <code>NF-HOOK</code>, and the network stack will determine whether to continue to execute the processing function based on the value of this vector. The schematic diagram is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/76052f8c10a547199c714cbbc92fe878.png" alt="nf_hook_ops"></p>
<p>The callback function mechanism of netfilter hook has the following features.</p>
<ul>
<li>Callback functions are executed in order of priority, and only the previous callback function returns <strong>NF_ACCEPT</strong> before continuing to the next callback function.</li>
<li>Any callback function can interrupt the execution chain of the hook&rsquo;s callback functions and require the entire network stack to suspend packet processing.</li>
</ul>
<h2 id="iptables">iptables</h2>
<p>Based on the hook callback function mechanism provided by the kernel netfilter, netfilter author Rusty Russell also developed iptables to manage custom rules applied to packets in user space.</p>
<p>iptbles is divided into two parts.</p>
<ul>
<li>The user-space iptables command provides the user with an administrative interface to access the kernel iptables module.</li>
<li>The kernel-space iptables module maintains the rules table in memory, enabling table creation and registration.</li>
</ul>
<h3 id="kernel-space-module">Kernel space module</h3>
<h4 id="initialization-of-xt_table">Initialization of xt_table</h4>
<p>In the kernel network stack, iptables manages a large number of packet processing rules in an orderly manner through the <code>xt_table</code> structure. A <code>xt_table</code> corresponds to a rule table, which corresponds to the user space concept of table.</p>
<ul>
<li>Works for different netfilter hooks.</li>
<li>Different priorities for checking different rule tables in the same hook.</li>
</ul>
<p>Based on the final purpose of the rules, iptables initializes four different rule tables by default, namely raw, filter, nat, and mangle. the following example describes the initialization and invocation process of <code>xt_table</code> for filter.</p>
<p>The definition of filter table is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define FILTER_VALID_HOOKS ((1 &lt;&lt; NF_INET_LOCAL_IN) | \
</span></span></span><span class="line"><span class="cl"><span class="cp">                                          (1 &lt;&lt; NF_INET_FORWARD) | \ 
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>                                            <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xt_table</span> <span class="n">packet_filter</span> <span class="o">=</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;filter&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">valid_hooks</span> <span class="o">=</span> <span class="n">FILTER_VALID_HOOKS</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">me</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">af</span> <span class="o">=</span> <span class="n">NFPROTO_IPV4</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">NF_IP_PRI_FILTER</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="n">net</span><span class="o">/</span><span class="n">ipv4</span><span class="o">/</span><span class="n">netfilter</span><span class="o">/</span><span class="n">iptable_filter</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The initialization function <a href="https://elixir.bootlin.com/linux/v2.6.39.4/source/net/ipv4/netfilter/iptable_filter.c#L87">iptable_filter.c</a> of the <a href="https://elixir.bootlin.com/linux/v2.6.39.4/C/ident/iptable_filter_init">iptable_ filter_init</a>, call <code>xt_hook_link</code> on the <code>xt_table</code> structure packet_filter to perform the the following initialization procedure.</p>
<ol>
<li>Iterate through the <code>.valid_hooks</code> attribute for each hook that <code>xt_table</code> will take effect for, for the filter, the 3 hooks <strong>NF_INET_LOCAL_IN</strong>, <strong>NF_INET_FORWARD</strong> and <strong>NF_INET_LOCAL_OUT</strong>.</li>
<li>For each hook, register a callback function to the hook using the priority property of <code>xt_table</code>.</li>
</ol>
<p>The priority values for different tables are as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">nf_ip_hook_priorities</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_IP_PRI_RAW</span> <span class="o">=</span> <span class="o">-</span><span class="mi">300</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_IP_PRI_MANGLE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">150</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_IP_PRI_NAT_DST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_IP_PRI_FILTER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_IP_PRI_SECURITY</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">NF_IP_PRI_NAT_SRC</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When a packet reaches a hook trigger point, all callback functions registered on that hook by different tables are executed sequentially, always in a fixed relative order according to the priority value above.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/5c6b6d6a2cb6489ca1bc93f9e654ebba.png" alt="hook"></p>
<h4 id="ipt_do_table">ipt_do_table()</h4>
<p>The filter registered hook callback function <a href="https://elixir.bootlin.com/linux/v2.6.39.4/C/ident/iptable_filter_hook">iptable_filter_hook</a> will execute the public rule checking function <a href="https://elixir.bootlin.com/linux/v2.6.39.4/C/ident/ipt_do_table">ipt_do_table</a> on the <code>xt_table</code> structure. <code>ipt_do_table</code> receives <code>skb</code>, <code>hook</code> and <code>xt_table</code> as arguments, and executes the rule set determined by the latter two arguments against <code>skb</code>, returning the netfilter vector as the return value of the callback function.</p>
<p>Before diving into the rule execution process, it is important to understand how the ruleset is represented in memory. Each rule consists of 3 parts.</p>
<ol>
<li>an <code>ipt_entry</code> structure. A <code>.next_offset</code> pointing to the memory offset address of the next <code>ipt_entry</code>.</li>
<li>0 or more <code>ipt_entry_match</code> structures, each of which can dynamically add additional data.</li>
<li>1 <code>ipt_entry_target</code> structure, each of which can be dynamically populated with additional data.</li>
</ol>
<p>The <code>ipt_entry</code> structure is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">ipt_entry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">ipt_ip</span> <span class="n">ip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfcache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* ipt_entry + matches 在内存中的大小*/</span>
</span></span><span class="line"><span class="cl">    <span class="n">u_int16_t</span> <span class="n">target_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* ipt_entry + matches + target 在内存中的大小 */</span>
</span></span><span class="line"><span class="cl">    <span class="n">u_int16_t</span> <span class="n">next_offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 跳转后指向前一规则 */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">comefrom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 数据包计数器 */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">xt_counters</span> <span class="n">counters</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* 长度为0数组的特殊用法，作为 match 的内存地址 */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>ipt_do_table</code> first jumps to the corresponding ruleset memory area based on the hook type and the <code>xt_table.private.entries</code> property, and performs the following procedure.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/07bdc5abeeac402c8ede87f22c5931ab.png" alt="ipt_do_table"></p>
<ol>
<li>first check whether the IP initial of the packet matches the <code>.ipt_ip</code> attribute of the first rule <code>ipt_entry</code>, if it does not match according to the <code>next_offset</code> attribute jump to the next rule.</li>
<li>If the IP initial matches, all <code>ipt_entry_match</code> objects defined by the rule are checked in turn, and the match function associated with the object is called, with the result of returning to the callback function (and whether to drop the packet), jumping to the next rule, or continuing the check, depending on the return value of the call.</li>
<li><code>ipt_entry_target</code> is read after all checks are passed, and according to its properties returns the netfilter vector to the callback function, continues to the next rule or jumps to another rule at the specified memory address. non-standard <code>ipt_entry_target</code> will also call the bound function, but can only return the vector value and cannot jump to another rule.</li>
</ol>
<h4 id="flexibility-and-update-latency">Flexibility and update latency</h4>
<p>The above data structure and execution provides iptables with the power to scale, allowing us to flexibly customize the matching criteria for each rule and perform different behaviors based on the results, and even stack-hop between additional rulesets.</p>
<p>Because each rule is of varying length, has a complex internal structure, and the same ruleset is located in contiguous memory space, iptables uses full replacement to update rules, which allows us to add/remove rules from user space with atomic operations, but non-incremental rule updates can cause serious performance problems when the rules are orders of magnitude larger: if a large If you use the iptables approach to implementing services in a large Kubernetes cluster, when the number of services is large, updating even one service will modify the iptables rule table as a whole. The full commit process is protected by kernel lock, so there is a significant update latency.</p>
<h3 id="user-space-tables-chains-and-rules">User-space tables, chains and rules</h3>
<p>The iptables command line in user space can read data from a given table and render it to the terminal, add new rules (actually replacing the entire table&rsquo;s rules table), etc.</p>
<p>iptables mainly operates on the following objects.</p>
<ul>
<li>table: corresponds to the <code>xt_table</code> structure in kernel space. All operations of iptable are performed on the specified table, which defaults to filter.</li>
<li>chain: The set of rules that the specified table calls through a specific netfilter hook, and you can also customize the rule set and jump from the hook rule set.</li>
<li>rule: corresponds to <code>ipt_entry</code>, <code>ipt_entry_match</code> and <code>ipt_entry_target</code> above, defining the rules for matching packets and the behavior to be performed after the match.</li>
<li>match: A highly scalable custom match rule.</li>
<li>target: A highly scalable custom post-match behavior.</li>
</ul>
<p>Based on the flow of the code invocation process described above, the chain and rule are executed as shown in the following diagram.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/15/c9d7cad3f50a4f7887d42de489400135.png" alt="chain and rule"></p>
<p>For the specific usage and commands of iptables, you can refer to Iptables Essentials: <a href="https://www.digitalocean.com/community/tutorials/iptables-essentials-common-firewall-rules-and-commands">Common Firewall Rules and Commands | DigitalOcean</a>.</p>
<h2 id="conntrack">conntrack</h2>
<p>It is not enough to filter packets by the first part of the layer 3 or 4 information, sometimes it is necessary to further consider the state of the connection. netfilter performs connection tracking with another built-in module <code>conntrack</code> to provide more advanced network filtering functions such as filtering by connection, address translation (NAT), etc. Because of the need to determine the connection status, <code>conntrack</code> has a separate implementation for protocol characteristics, while the overall mechanism is the same.</p>
<p>I was going to continue with <code>conntrack</code> and NAT, but I decided against it because of its length. I will write another article explaining the principles, applications and Linux kernel implementation of conntrack when I have time.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/2022-04/linux-process-input-frames/">
            <span class="next-text nav-default">An analysis of how Linux receives network frames</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
