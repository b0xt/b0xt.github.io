<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Introduction and practice of eBPF - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="This article introduces the history of eBPF and builds an eBPF environment for practice." /><meta name="keywords" content="linux, eBPF" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/ebpf/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Introduction and practice of eBPF" />
<meta property="og:description" content="This article introduces the history of eBPF and builds an eBPF environment for practice." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/ebpf/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-13T13:33:55+08:00" />
<meta property="article:modified_time" content="2022-04-13T13:33:55+08:00" />

<meta itemprop="name" content="Introduction and practice of eBPF">
<meta itemprop="description" content="This article introduces the history of eBPF and builds an eBPF environment for practice."><meta itemprop="datePublished" content="2022-04-13T13:33:55+08:00" />
<meta itemprop="dateModified" content="2022-04-13T13:33:55+08:00" />
<meta itemprop="wordCount" content="9566">
<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Introduction and practice of eBPF"/>
<meta name="twitter:description" content="This article introduces the history of eBPF and builds an eBPF environment for practice."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Introduction and practice of eBPF</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-13 13:33:55 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 9566 words </span>
          <span class="more-meta"> 20 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#technical-background">Technical Background</a>
          <ul>
            <li><a href="#development-history">Development History</a></li>
            <li><a href="#ebpf-vs-cbpf">eBPF vs. cBPF</a></li>
            <li><a href="#ebpf-and-kernel-modules">eBPF and kernel modules</a></li>
            <li><a href="#ebpf-architecture">eBPF architecture</a></li>
            <li><a href="#ebpf-restrictions">eBPF Restrictions</a></li>
          </ul>
        </li>
        <li><a href="#ebpf-in-action">eBPF in action</a>
          <ul>
            <li><a href="#kernel-source-code-compilation">Kernel source code compilation</a></li>
            <li><a href="#hello-world">Hello World</a></li>
            <li><a href="#code-explanation">Code Explanation</a></li>
          </ul>
        </li>
        <li><a href="#ebpf-features">eBPF Features</a>
          <ul>
            <li><a href="#hook-overview">Hook Overview</a></li>
            <li><a href="#verification">Verification</a></li>
            <li><a href="#jit-compilation">JIT Compilation</a></li>
            <li><a href="#maps">Maps</a></li>
            <li><a href="#helper-calls">Helper Calls</a></li>
            <li><a href="#tail-calls">Tail Calls</a></li>
            <li><a href="#bpf-to-bpf-calls">BPF to BPF Calls</a></li>
            <li><a href="#object-pinning">Object Pinning</a></li>
            <li><a href="#hardening">Hardening</a></li>
            <li><a href="#offloads">Offloads</a></li>
          </ul>
        </li>
        <li><a href="#ebpf-interface">eBPF interface</a>
          <ul>
            <li><a href="#bpf-system-call">BPF System Call</a></li>
            <li><a href="#bpf-program-types">BPF Program Types</a></li>
            <li><a href="#bpf-code-call-timing">BPF code call timing</a></li>
            <li><a href="#bpf-attach-type">BPF Attach type</a></li>
            <li><a href="#introduction-to-common-prog-types">Introduction to common prog types</a></li>
          </ul>
        </li>
        <li><a href="#ebpf-tool-chain">eBPF tool chain</a>
          <ul>
            <li><a href="#bcc">bcc</a></li>
            <li><a href="#bpftrace">bpftrace</a></li>
            <li><a href="#ebpf-go-library">eBPF Go Library</a></li>
            <li><a href="#libbpf">libbpf</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>eBPF, derived from <a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">BPF</a>, is essentially an efficient and flexible virtual class virtual machine component in the kernel that executes bytecode at many kernel hook points in a secure manner. BPF was originally intended for efficient Originally intended for efficient network message filtering, eBPF has been redesigned and is no longer limited to the network stack, but has become a top-level subsystem of the kernel, evolving into a general-purpose execution engine. Developers can develop performance analysis tools, software-defined networking, security, and many other scenarios based on eBPF. In this article, we will introduce the history of eBPF and build an eBPF environment for development practice. All the code in this article can be found in this <a href="https://github.com/">Github Repository</a>.</p>
<h2 id="technical-background">Technical Background</h2>
<h3 id="development-history">Development History</h3>
<p>In 1992, Steven McCanne and Van Jacobson wrote a paper entitled <a href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">The BSD Packet Filter: A New Architecture for User-level Packet Capture</a>. In the paper, the authors described how they implemented network packet filtering in the Unix kernel, a new technique that was 20 times faster than the state-of-the-art packet filtering techniques of the time.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/b525245677a8470986ea7f87dcf491e7.png" alt="The BSD Packet Filter: A New Architecture for User-level Packet Capture"></p>
<p>BPF introduces two major innovations in packet filtering.</p>
<ul>
<li>A new virtual machine (VM) design that works efficiently on CPUs with a register-based architecture.</li>
<li>Applications use caches to copy only the data associated with filtered packets, not all of the packet&rsquo;s information, which minimizes the amount of data processed by BPF.</li>
</ul>
<p>Because of these great improvements, all Unix systems chose to use BPF as the network packet filtering technique, and to this day many derivatives of the Unix kernel (including the Linux kernel) still use this implementation. tcpdump uses BPF as the underlying packet filtering technique, and we can add <code>-d</code> to the end of the command to see the tcpdump filtering conditions for the underlying assembly directive.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ tcpdump -d &#39;ip and tcp port 8080&#39;
</span></span><span class="line"><span class="cl">(000) ldh      [12]
</span></span><span class="line"><span class="cl">(001) jeq      #0x800           jt 2    jf 12
</span></span><span class="line"><span class="cl">(002) ldb      [23]
</span></span><span class="line"><span class="cl">(003) jeq      #0x6             jt 4    jf 12
</span></span><span class="line"><span class="cl">(004) ldh      [20]
</span></span><span class="line"><span class="cl">(005) jset     #0x1fff          jt 12   jf 6
</span></span><span class="line"><span class="cl">(006) ldxb     4*([14]&amp;0xf)
</span></span><span class="line"><span class="cl">(007) ldh      [x + 14]
</span></span><span class="line"><span class="cl">(008) jeq      #0x1f90          jt 11   jf 9
</span></span><span class="line"><span class="cl">(009) ldh      [x + 16]
</span></span><span class="line"><span class="cl">(010) jeq      #0x1f90          jt 11   jf 12
</span></span><span class="line"><span class="cl">(011) ret      #262144
</span></span><span class="line"><span class="cl">(012) ret      #0
</span></span></code></pre></td></tr></table>
</div>
</div><p>In early 2014, Alexei Starovoitov implemented eBPF (extended Berkeley Packet Filter). After redesign, eBPF evolved into a general-purpose execution engine on which performance analysis tools, software-defined networks, and many other scenarios can be developed. <strong>eBPF first appeared in the 3.18 kernel, and since then the original BPF has been called the classic BPF (cBPF). cBPF is now largely deprecated. Now, the Linux kernel runs only eBPF, and the kernel transparently converts the loaded cBPF bytecode into eBPF before executing it</strong> .</p>
<h3 id="ebpf-vs-cbpf">eBPF vs. cBPF</h3>
<p>The new design of eBPF is optimized for modern hardware, so the instruction set generated by eBPF executes faster than the machine code generated by the old BPF interpreter. The extended version also increases the number of registers in the virtual machine, increasing the original 2 32-bit registers to 10 64-bit registers. Due to the increased number and width of registers, developers can freely exchange more information and write more complex programs using function parameters. All in all, these improvements make the eBPF version 4 times faster than the original BPF.</p>
<table>
<thead>
<tr>
<th>Dimension</th>
<th>cBPF</th>
<th>eBPF</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kernel Version</td>
<td>Linux 2.1.75（1997）</td>
<td>Linux 3.18（2014）[4.x for kprobe/uprobe/tracepoint/perf-event]</td>
</tr>
<tr>
<td>Number of registers</td>
<td>2: A, X</td>
<td>10: R0 - R9, plus R10 a read-only frame pointer. r0 return and exit values of kernel functions in eBPF, R1 - R5 parameter values of eBF programs in the kernel, R6 - R9 registers saved by the callee that the kernel function will save, R10 a read-only stack frame pointer.</td>
</tr>
<tr>
<td>Register width</td>
<td>32-bit</td>
<td>64-bit</td>
</tr>
<tr>
<td>Storage</td>
<td>16 memory bits: M[0-15]</td>
<td>512-byte stack, unlimited size <code>map</code> storage</td>
</tr>
<tr>
<td>Restricted kernel calls</td>
<td>Very limited, limited to JIT specific</td>
<td>limited, called by the bpf_call instruction</td>
</tr>
<tr>
<td>Target events</td>
<td>Packets, seccomp-BPF</td>
<td>Packets, kernel functions, user functions, trace point PMCs, etc.</td>
</tr>
</tbody>
</table>
<p>In June 2014, <strong>eBPF was extended to the user space, which became a turning point for BPF technology</strong> . As Alexei writes in the notes of the patch commit, &ldquo;This patch demonstrates the potential of eBPF&rdquo;. Currently, eBPF is no longer limited to the network stack and has become a top-level subsystem of the kernel.</p>
<h3 id="ebpf-and-kernel-modules">eBPF and kernel modules</h3>
<p>In contrast to the evolution of the Web, eBPF&rsquo;s relationship to the kernel is somewhat similar to that of JavaScript to the browser kernel. eBPF provides a new kernel-programmable option compared to directly modifying the kernel and writing kernel modules. eBPF program architecture emphasizes security and stability and looks more like a kernel module, but unlike kernel modules, eBPF programs do not need to recompile the Unlike kernel modules, eBPF programs do not require recompilation of the kernel and can ensure that eBPF programs run to completion without crashing the system.</p>
<table>
<thead>
<tr>
<th>Dimension</th>
<th>Linux Kernel Modules</th>
<th>eBPF</th>
</tr>
</thead>
<tbody>
<tr>
<td>kprobes/tracepoints</td>
<td>Support</td>
<td>Support</td>
</tr>
<tr>
<td>Security</td>
<td>May introduce security vulnerabilities or cause kernel Panic</td>
<td>Checked by verifier, can secure the kernel</td>
</tr>
<tr>
<td>Kernel functions</td>
<td>can call kernel functions</td>
<td>can only be called through BPF Helper functions</td>
</tr>
<tr>
<td>compilability</td>
<td>need to compile the kernel</td>
<td>no need to compile the kernel, just introduce the headers</td>
</tr>
<tr>
<td>Running</td>
<td>on the same kernel</td>
<td>Stable ABI-based BPF programs can be compiled once and run everywhere</td>
</tr>
<tr>
<td>interact with the application</td>
<td>print logs or files</td>
<td>via perf_event or map structures</td>
</tr>
<tr>
<td>Data Structure Richness</td>
<td>General</td>
<td>Rich</td>
</tr>
<tr>
<td>Threshold</td>
<td>High</td>
<td>Low</td>
</tr>
<tr>
<td>Upgrade</td>
<td>requires uninstall and load, which may cause processing interruption</td>
<td>atomic replacement upgrade, which does not cause processing interruption</td>
</tr>
<tr>
<td>kernel built-in</td>
<td>depends</td>
<td>kernel built-in support</td>
</tr>
</tbody>
</table>
<h3 id="ebpf-architecture">eBPF architecture</h3>
<p>The eBPF is divided into two parts: a user-space program and a kernel program.</p>
<ul>
<li>The user space program is responsible for loading the BPF bytecode into the kernel and, if needed, for reading the statistics or event details returned by the kernel.</li>
<li>The BPF bytecode in the kernel is responsible for executing specific events in the kernel, and if needed, sending the results to the user space via maps or perf-event events.</li>
<li>The user space program can communicate with the kernel BPF bytecode program in both directions using the map structure, which provides more flexible control over the BPF bytecode program running in the kernel.</li>
</ul>
<p>The overall structure of eBPF is as follows.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/6ad3cea7956d45f0857f183396840851.png" alt="overall structure of eBPF"></p>
<p>The flow of interaction between the user space program and the BPF bytecode in the kernel is as follows.</p>
<ol>
<li>
<p>compile the written BPF code program into BPF bytecode using LLVM or GCC tools</p>
</li>
<li>
<p>load the bytecode into the kernel using the loader</p>
</li>
<li>
<p>The kernel uses the Verfier component to secure the execution of the bytecode to avoid disaster to the kernel, and loads the bytecode into the corresponding kernel module for execution after confirming its security</p>
</li>
<li>
<p>BPF bytecode programs running in the kernel can use two ways to send data back to user space</p>
<ul>
<li><strong>maps</strong> method can be used to pass back to user space statistical summary information implemented in the kernel (e.g. measurement latency, stack information), etc.</li>
<li><strong>perf-event</strong> is used to send events collected by the kernel to user space in real time, which are read and analyzed by user space programs in real time.</li>
</ul>
</li>
</ol>
<h3 id="ebpf-restrictions">eBPF Restrictions</h3>
<p>Although powerful, eBPF technology in the kernel imposes a number of restrictions to ensure safe and timely kernel processing, but as the technology develops and evolves, the restrictions are gradually relaxed or provide corresponding solutions.</p>
<ul>
<li>
<p>eBPF programs cannot call arbitrary kernel parameters, but are limited to the BPF Helper functions listed in the kernel module, and the list of supported functions is growing as the kernel evolves.</p>
</li>
<li>
<p>eBPF programs are not allowed to contain unreachable instructions to prevent loading invalid code and delaying the termination of the program.</p>
</li>
<li>
<p>The number of loops in an eBPF program is limited and must end in a finite amount of time, which is primarily used to prevent inserting arbitrary loops in kprobes that would result in locking the entire system; solutions include expanding loops and adding helper functions for common uses that require loops. Linux 5.3 includes support for bounded loops in the BPF, which has a verifiable upper limit on runtime.</p>
</li>
<li>
<p>The eBPF stack size is limited to MAX_BPF_STACK, which as of kernel Linux 5.8 is set to 512; see <a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/filter.h">include/linux/filter.h</a>, this limit is particularly relevant when storing multiple string buffers on the stack: a char[256] buffer will consume half of this stack. There are no plans to increase this limit; the solution is to switch to bpf mapped storage, which is effectively infinite.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* BPF program can access up to 512 bytes of stack space. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define MAX_BPF_STACK   512
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The eBPF bytecode size was originally limited to 4096 instructions, but as of kernel Linux 5.8, it has now been relaxed to 1 million instructions (BPF_COMPLEXITY_LIMIT_INSNS), see: <a href="https://github.com/torvalds/linux/blob/v5.8/include/linux/bpf.h">include/linux/bpf.h</a>, the 4096 instruction limit ( BPF_MAXINSNS ) is still retained for unprivileged BPF programs; the new version of eBPF also supports cascading calls to multiple eBPF programs, which, although there are some limitations on passing information, can be combined to This new version of eBPF also supports cascading calls to multiple eBPF programs, which can be combined to achieve more powerful functionality, although there are some limitations on passing information.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define BPF_COMPLEXITY_LIMIT_INSNS      1000000 </span><span class="cm">/* yes. 1M insns */</span><span class="cp">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="ebpf-in-action">eBPF in action</h2>
<p>Before we dive into the features of eBPF, let&rsquo;s <code>Get Hands Dirty</code> and get a real feel for what eBPF programs are and how we can develop them. As the eBPF ecosystem evolves, there are now more and more toolchains for developing eBPF programs, which will also be described in detail in the following sections.</p>
<ul>
<li>bcc-based development: bcc provides development of eBPF with a Python API in the front end and a C implementation of the back-end eBPF program. It is simple and easy to use, but the performance is poor.</li>
<li>Based on libebpf-bootstrap development: libebpf-bootstrap provides a convenient scaffolding</li>
<li>Based on kernel source development: kernel source development is a higher threshold, but also more relevant to the underlying eBPF principles, so this approach is used here as an example</li>
</ul>
<h3 id="kernel-source-code-compilation">Kernel source code compilation</h3>
<p>The system environment is as follows, using Tencent Cloud CVM, Ubuntu 20.04, kernel version 5.4.0</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ uname -a
</span></span><span class="line"><span class="cl">Linux VM-1-3-ubuntu 5.4.0-42-generic <span class="c1">#46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>First install the necessary dependencies.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo apt install -y bison build-essential cmake flex git libedit-dev pkg-config libmnl-dev <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   python zlib1g-dev libssl-dev libelf-dev libcap-dev libfl-dev llvm clang pkg-config <span class="se">\
</span></span></span><span class="line"><span class="cl"><span class="se"></span>   gcc-multilib luajit libluajit-5.1-dev libncurses5-dev libclang-dev clang-tools
</span></span></code></pre></td></tr></table>
</div>
</div><p>It is generally recommended to use apt to install the source code, which is easy and only installs the current kernel source code, and the size of the source code is around 200M.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1"># apt-cache search linux-source</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># apt install linux-source-5.4.0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The source code is installed in the <code>/usr/src/</code> directory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ ls -hl
</span></span><span class="line"><span class="cl">total 4.0K
</span></span><span class="line"><span class="cl">drwxr-xr-x <span class="m">4</span> root root 4.0K Nov  <span class="m">9</span> 13:22 linux-source-5.4.0
</span></span><span class="line"><span class="cl">lrwxrwxrwx <span class="m">1</span> root root   <span class="m">45</span> Oct <span class="m">15</span> 10:28 linux-source-5.4.0.tar.bz2 -&gt; linux-source-5.4.0/linux-source-5.4.0.tar.bz2
</span></span><span class="line"><span class="cl">$ tar -jxvf linux-source-5.4.0.tar.bz2
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> linux-source-5.4.0
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ cp -v /boot/config-<span class="k">$(</span>uname -r<span class="k">)</span> .config <span class="c1"># make defconfig 或者 make menuconfig</span>
</span></span><span class="line"><span class="cl">$ make headers_install
</span></span><span class="line"><span class="cl">$ make modules_prepare
</span></span><span class="line"><span class="cl">$ make scripts     <span class="c1"># 可选</span>
</span></span><span class="line"><span class="cl">$ make <span class="nv">M</span><span class="o">=</span>samples/bpf  <span class="c1"># 如果配置出错，可以使用 make oldconfig &amp;&amp; make prepare 修复</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>After successful compilation, you can see a series of target files and binaries in the <code>samples/bpf</code> directory.</p>
<h3 id="hello-world">Hello World</h3>
<p>As mentioned before, eBPF usually consists of two parts: kernel-space programs and user-space programs, and there are many such programs in the <code>samples/bpf</code> directory, with kernel-space programs ending in <code>_kern.c</code> and user-space programs ending in <code>_user.c</code>. Without looking at these complicated programs, let&rsquo;s write a Hello World for the eBPF program manually.</p>
<p>program <code>hello_kern.c</code> in the kernel.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;bpf_helpers.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SEC(NAME) __attribute__((section(NAME), used))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="n">SEC</span><span class="p">(</span><span class="s">&#34;tracepoint/syscalls/sys_enter_execve&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">bpf_prog</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">msg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello BPF from houmin!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bpf_trace_printk</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">_license</span><span class="p">[]</span> <span class="n">SEC</span><span class="p">(</span><span class="s">&#34;license&#34;</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;GPL&#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="function-entry">function entry</h4>
<p>There are some differences between the above code and normal C programming.</p>
<ol>
<li>the entry of the program is specified by <code>pragama __section(&quot;tracepoint/syscalls/sys_enter_execve&quot;)</code> of the compiler.</li>
<li>The entry argument is no longer <code>argc, argv</code> , which varies depending on the prog type. In our case, the prog type is <code>BPF_PROG_TYPE_TRACEPOINT</code>, and its entry argument is <code>void *ctx</code>.</li>
</ol>
<h4 id="headers">headers</h4>
<h5 id="include-linuxbpfh"><code>#include &lt;linux/bpf.h&gt;</code></h5>
<p>The source of this header file is the kernel source header file. It is installed in <code>/usr/include/linux/bpf.h</code>.</p>
<p>It provides many of the symbols needed for bpf programming, for example</p>
<ol>
<li>enum bpf_func_id defines the id of all kerne helper functions</li>
<li>enum bpf_prog_type defines all the types of prog supported by the kernel.</li>
<li>struct __sk_buff is the interface in the bpf code to access the kernel struct sk_buff.</li>
</ol>
<p>etc.</p>
<h5 id="include-bpf_helpersh">#include &ldquo;bpf_helpers.h&rdquo;</h5>
<p>comes from libbpf , which needs to be installed by itself. We refer to this header file because of the call to bpf_printk(). This is a kernel helper function.</p>
<h4 id="program-explanation">program explanation</h4>
<p>Here we briefly explain the kernel state <code>ebpf</code> program, which is very simple.</p>
<ul>
<li><code>bpf_trace_printk</code> is an eBPF helper function that prints information to <code>trace_pipe</code> (/sys/kernel/debug/tracing/trace_pipe), <a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#1-bpf_trace_printk">see here for details</a></li>
<li>The code declares the <code>SEC</code> macro and defines the GPL license, because the eBPF program loaded into the kernel needs to have a license check, similar to the kernel module</li>
</ul>
<h4 id="loads-the-bpf-code">loads the BPF code</h4>
<p>User state program <code>hello_user.c</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;bpf_load.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">load_bpf_file</span><span class="p">(</span><span class="s">&#34;hello_kern.o&#34;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The kernel didn&#39;t load BPF program</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">read_trace_pipe</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the user-state <code>ebpf</code> program, it reads as follows.</p>
<ul>
<li>Load the compiled kernel-state ebpf target file into the kernel via <code>load_bpf_file</code></li>
<li>Read the trace information from <code>trace_pipe</code> via <a href="https://elixir.bootlin.com/linux/latest/source/tools/testing/selftests/bpf/trace_helpers.c#L120"><code>read_trace_pipe</code></a> and print the trace information from <code>trace_ pipe</code> and print the trace information to the console</li>
</ul>
<p>Modify the <code>Makefile</code> file in the <code>samples/bpf</code> directory by adding the following three lines in the corresponding locations.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">hostprogs</span><span class="o">-</span><span class="n">y</span> <span class="o">+=</span> <span class="n">hello</span>
</span></span><span class="line"><span class="cl"><span class="n">hello</span><span class="o">-</span><span class="nl">objs</span> <span class="p">:</span><span class="o">=</span> <span class="n">bpf_load</span><span class="p">.</span><span class="n">o</span> <span class="n">hello_user</span><span class="p">.</span><span class="n">o</span>
</span></span><span class="line"><span class="cl"><span class="n">always</span> <span class="o">+=</span> <span class="n">hello_kern</span><span class="p">.</span><span class="n">o</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Recompile and you can see the compiled file successfully.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ make M=samples/bpf
</span></span><span class="line"><span class="cl">$ ls -hl samples/bpf/hello*
</span></span><span class="line"><span class="cl">-rwxrwxr-x 1 ubuntu ubuntu 404K Mar 30 17:48 samples/bpf/hello
</span></span><span class="line"><span class="cl">-rw-rw-r-- 1 ubuntu ubuntu  317 Mar 30 17:47 samples/bpf/hello_kern.c
</span></span><span class="line"><span class="cl">-rw-rw-r-- 1 ubuntu ubuntu 3.8K Mar 30 17:48 samples/bpf/hello_kern.o
</span></span><span class="line"><span class="cl">-rw-rw-r-- 1 ubuntu ubuntu  246 Mar 30 17:47 samples/bpf/hello_user.c
</span></span><span class="line"><span class="cl">-rw-rw-r-- 1 ubuntu ubuntu 2.2K Mar 30 17:48 samples/bpf/hello_user.o
</span></span></code></pre></td></tr></table>
</div>
</div><p>Go to the corresponding directory and run the <code>hello</code> program, you can see the following output.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sudo ./hello
</span></span><span class="line"><span class="cl">           &lt;...&gt;-102735 <span class="o">[</span>001<span class="o">]</span> ....  6733.481740: 0: Hello BPF from houmin!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">           &lt;...&gt;-102736 <span class="o">[</span>000<span class="o">]</span> ....  6733.482884: 0: Hello BPF from houmin!
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">           &lt;...&gt;-102737 <span class="o">[</span>002<span class="o">]</span> ....  6733.483074: 0: Hello BPF from houmin!
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="code-explanation">Code Explanation</h3>
<p>As mentioned earlier, the <code>load_bpf_file</code> function loads the eBPF bytecode compiled by LLVM into the kernel, how exactly is this done?</p>
<ul>
<li>After searching, we can see that <code>load_bpf_file</code> is also implemented in the <code>samples/bpf</code> directory, see <a href="https://elixir.bootlin.com/linux/v5.4/source/samples/bpf/bpf_load.c#L659"><code>bpf_load.c</code></a>.</li>
<li>Read the <code>load_bpf_file</code> code to see that it mainly parses the ELF formatted eBPF bytecode and then calls <a href="https://elixir.bootlin.com/linux/v5.4/source/samples/bpf/bpf_load.c#L76"><code>load_and_attach</code></a> function.</li>
<li>In the <code>load_and_attach</code> function, we can see that it calls . <code>bpf_load_program</code> function, which is a function provided by libbpf.</li>
<li>The arguments <code>license</code> and <code>kern_version</code> in the called <code>bpf_load_program</code> come from parsing the eBPF ELF file, and the prog_type comes from the type specified in the SEC field inside the bpf code.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">load_and_attach</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="n">prog</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">is_socket</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;socket&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_kprobe</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;kprobe/&#34;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_kretprobe</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;kretprobe/&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_tracepoint</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;tracepoint/&#34;</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_raw_tracepoint</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;raw_tracepoint/&#34;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_xdp</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;xdp&#34;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_perf_event</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;perf_event&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_cgroup_skb</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;cgroup/skb&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_cgroup_sk</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;cgroup/sock&#34;</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_sockops</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;sockops&#34;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_sk_skb</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;sk_skb&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">is_sk_msg</span> <span class="o">=</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="s">&#34;sk_msg&#34;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">fd</span> <span class="o">=</span> <span class="n">bpf_load_program</span><span class="p">(</span><span class="n">prog_type</span><span class="p">,</span> <span class="n">prog</span><span class="p">,</span> <span class="n">insns_cnt</span><span class="p">,</span> <span class="n">license</span><span class="p">,</span> <span class="n">kern_version</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">bpf_log_buf</span><span class="p">,</span> <span class="n">BPF_LOG_BUF_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;bpf_load_program() err=%d</span><span class="se">\n</span><span class="s">%s&#34;</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">bpf_log_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="ebpf-features">eBPF Features</h2>
<h3 id="hook-overview">Hook Overview</h3>
<p>eBPF programs are event-driven, they run when the kernel or application passes through a defined Hook point. These Hook points are defined in advance and include system calls, function entry/exit, kernel <code>tracepoints</code>, network events, etc.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/3d9bee19aba54b82ae25073a23ea41a6.png" alt="eBPF Hook"></p>
<p>If a Hook point for a specific requirement does not exist, you can mount the eBPF program almost anywhere in the kernel or user program by using <code>kprobe</code> or <code>uprobe</code>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/51a9484a98214978afa93f8355b35de2.png" alt="kprobe/uprobe"></p>
<h3 id="verification">Verification</h3>
<blockquote>
<p>With great power there must also come great responsibility.</p>
</blockquote>
<p>Every eBPF program loaded into the kernel is subject to <code>Verification</code>, which is used to ensure the security of eBPF programs, mainly by.</p>
<ul>
<li>
<p>the process that loads the eBPF program has the necessary privilege level, unless the node has the <code>unpriviledged</code> feature enabled, so that only privileged programs can load eBPF programs</p>
<ul>
<li>
<p>The kernel provides a configuration item <code>/proc/sys/kernel/unprivileged_bpf_disabled</code> to disable the use of the <code>bpf(2)</code> system call by unprivileged users, which can be changed with the <code>sysctl</code> command</p>
</li>
<li>
<p>A special feature is that this configuration item is designed as a <strong>one-time kill switch</strong>, which means that once it is set to <code>1</code>, there is no way to change it to <code>0</code> unless you restart the kernel</p>
</li>
<li>
<p>Once set to <code>1</code>, only processes with the <code>CAP_SYS_ADMIN</code> privilege in their initial namespace can call the <code>bpf(2)</code> system call. Cilium will also set this configuration item to 1 when it starts.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="err">$</span> <span class="n">echo</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">kernel</span><span class="o">/</span><span class="n">unprivileged_bpf_disabled</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
<li>
<p>To ensure that eBPF programs do not crash or make the system malfunction.</p>
</li>
<li>
<p>Make sure that eBPF programs cannot get stuck in a dead loop and can <code>runs to completion</code>.</p>
</li>
<li>
<p>Ensure that eBPF programs must meet system requirements for size, and that oversized eBPF programs are not allowed to be loaded into the kernel.</p>
</li>
<li>
<p>To ensure that eBPF programs are of limited complexity, <code>Verifier</code> will evaluate all possible execution paths of eBPF programs and must be able to complete the eBPF program complexity analysis in a limited time.</p>
</li>
</ul>
<h3 id="jit-compilation">JIT Compilation</h3>
<p><code>Just-In-Time(JIT)</code> compilations are used to translate generic eBPF bytecode into machine-relevant instruction sets, thereby greatly accelerating the execution of BPF programs.</p>
<ul>
<li>They reduce the per-instruction overhead compared to interpreters. Typically, instructions can be mapped 1:1 to the underlying architecture&rsquo;s native instructions.</li>
<li>This also reduces the size of the generated executable image and is therefore more friendly to the CPU&rsquo;s instruction cache.</li>
<li>In particular, for the CISC instruction set (e.g. <code>x86</code>), JIT makes a number of special optimizations aimed at generating the shortest possible opcode for a given instruction, in order to reduce the space required for the program translation process.</li>
</ul>
<p>The 64-bit <code>x86_64</code>, <code>arm64</code>, <code>ppc64</code>, <code>s390x</code>, <code>mips64</code>, <code>sparc64</code> and 32-bit <code>arm</code>, <code>x86_32</code> architectures all have built-in in-kernel eBPF JIT compilers, which are all functionally identical and can be opened in the following way.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="m">1</span> &gt; /proc/sys/net/core/bpf_jit_enable
</span></span></code></pre></td></tr></table>
</div>
</div><p>The 32-bit <code>mips</code>, <code>ppc</code>, and <code>sparc</code> architectures currently have a built-in cBPF JIT compiler. These architectures that only have a cBPF JIT compiler, and those that do not even have a BPF JIT compiler at all, require an <strong>in-kernel interpreter</strong> to execute eBPF programs.</p>
<p>To determine which platforms support the eBPF JIT, grep <code>HAVE_EBPF_JIT</code> in the kernel source file.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ git grep HAVE_EBPF_JIT arch/
</span></span><span class="line"><span class="cl">arch/arm/Kconfig:       <span class="k">select</span> HAVE_EBPF_JIT   <span class="k">if</span> !CPU_ENDIAN_BE32
</span></span><span class="line"><span class="cl">arch/arm64/Kconfig:     <span class="k">select</span> HAVE_EBPF_JIT
</span></span><span class="line"><span class="cl">arch/powerpc/Kconfig:   <span class="k">select</span> HAVE_EBPF_JIT   <span class="k">if</span> PPC64
</span></span><span class="line"><span class="cl">arch/mips/Kconfig:      <span class="k">select</span> HAVE_EBPF_JIT   <span class="k">if</span> <span class="o">(</span>64BIT <span class="o">&amp;&amp;</span> !CPU_MICROMIPS<span class="o">)</span>
</span></span><span class="line"><span class="cl">arch/s390/Kconfig:      <span class="k">select</span> HAVE_EBPF_JIT   <span class="k">if</span> PACK_STACK <span class="o">&amp;&amp;</span> HAVE_MARCH_Z196_FEATURES
</span></span><span class="line"><span class="cl">arch/sparc/Kconfig:     <span class="k">select</span> HAVE_EBPF_JIT   <span class="k">if</span> SPARC64
</span></span><span class="line"><span class="cl">arch/x86/Kconfig:       <span class="k">select</span> HAVE_EBPF_JIT   <span class="k">if</span> X86_64
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/a77d393c49ab41218486557afec0c83b.png" alt="bpf program"></p>
<h3 id="maps">Maps</h3>
<p>BPF Maps are efficient <code>Key/Value stores</code> that reside in kernel space** and contain multiple types of maps that are implemented by the kernel.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/1f57f7ceb27d4fc6991a4dc9182c1175.png" alt="BPF Maps"></p>
<p>The interaction scenarios of BPF Map are as follows.</p>
<ul>
<li>Interaction between a BPF program and a user-state program: After the BPF program is run, the results obtained are stored in the map for the user-state program to access via file descriptors.</li>
<li>Interaction between BPF programs and kernel programs: Interaction with kernel programs other than BPF programs can also use map as an intermediary.</li>
<li>Interaction between BPF programs: If a BPF program needs to interact with global variables internally, but for security reasons BPF programs are not allowed to access global variables, you can use map to act as a global variable.</li>
<li>BPF Tail call: Tail call is a jump from one BPF program to another BPF program. The BPF program first knows the pointer to the other BPF program by using a map of type <code>BPF_MAP_TYPE_PROG_ARRAY</code>, and then calls the helper function of <code>tail_call()</code> to execute Tail call.</li>
</ul>
<p>BPF programs that share maps are not required to be of the same program type; for example, tracing programs can share maps with network programs, and <strong>a single BPF program can currently directly access up to 64 different maps</strong>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/62b0e67e5824421da1d0c3bc874af337.png" alt="BPF Maps"></p>
<p>The currently available <strong>generic maps</strong> are.</p>
<ul>
<li><code>BPF_MAP_TYPE_HASH</code></li>
<li><code>BPF_MAP_TYPE_ARRAY</code></li>
<li><code>BPF_MAP_TYPE_PERCPU_HASH</code></li>
<li><code>BPF_MAP_TYPE_PERCPU_ARRAY</code></li>
<li><code>BPF_MAP_TYPE_LRU_HASH</code></li>
<li><code>BPF_MAP_TYPE_LRU_PERCPU_HASH</code></li>
<li><code>BPF_MAP_TYPE_LPM_TRIE</code></li>
</ul>
<p>The above maps all use the same set of BPF helper functions to perform lookup, update, or delete operations, but each implements a different backend, each with different semantics and performance characteristics. As multi-CPU architectures matured, BPF Map also introduced <strong>per-cpu</strong> types such as <code>BPF_MAP_TYPE_PERCPU_HASH</code>, <code>BPF_MAP_TYPE_PERCPU_ARRAY</code>, etc. When you use this type of BPF Map, each CPU stores and sees its own Map data, and the data belonging to different CPUs are isolated from each other. This has the advantage of being more efficient and better performance when performing lookup and aggregation operations. This is especially true if your BPF program is primarily doing collection of time series type data such as traffic data or metrics, etc.</p>
<p>The current <strong>non-generic maps</strong> in the kernel are.</p>
<ul>
<li><code>BPF_MAP_TYPE_PROG_ARRAY</code> : an array map to hold other BPF programs.</li>
<li><code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>.</li>
<li><code>BPF_MAP_TYPE_CGROUP_ARRAY</code> : an array to check the cgroup2 member information in skb.</li>
<li><code>BPF_MAP_TYPE_STACK_TRACE</code> : used to store the MAP of the stack trace.</li>
<li><code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code> : holds (holds) pointers to other maps so that the whole map can be replaced atomically at runtime.</li>
<li><code>BPF_MAP_TYPE_HASH_OF_MAPS</code>: holds pointers to other maps so that the entire map can be replaced atomically at runtime.</li>
</ul>
<h3 id="helper-calls">Helper Calls</h3>
<p>eBPF programs cannot call kernel functions at will; to do so would cause the eBPF program to be bound to a specific kernel version, instead it has a set of kernel-defined <code>Helper functions</code>. <code>Helper functions</code> enable BPF to query data from the kernel or push data to the kernel through a set of kernel-defined stable function calls. <strong>All BPF helper functions are part of the core kernel and cannot be extended or added to via kernel modules</strong> . <strong>There are currently dozens of BPF helper functions available, and the number is growing</strong>. You can see the current Linux support for <code>Helper functions</code> at <a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">Linux Manual Page: bpf-helpers</a>.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/252f751ebc4841d4b66f410a12f26e68.png" alt="Helper functions"></p>
<p><strong>The helper functions that can be used by different types of BPF programs may be different</strong> , e.g:</p>
<ul>
<li>A BPF program that attaches to a socket can call only a subset of the helper functions that the former can call, compared to a BPF program that attaches to the tc layer.</li>
<li>The wrapped and unwrapped helper functions used by <code>lightweight tunneling</code> can only be used by the lower tc layer, while the event output helper functions used by push notifications to the user state can be used by both tc and XDP programs.</li>
</ul>
<p><strong>All helper functions share the same generic, system call-like function method</strong>, which is defined as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">u64</span> <span class="n">fn</span><span class="p">(</span><span class="n">u64</span> <span class="n">r1</span><span class="p">,</span> <span class="n">u64</span> <span class="n">r2</span><span class="p">,</span> <span class="n">u64</span> <span class="n">r3</span><span class="p">,</span> <span class="n">u64</span> <span class="n">r4</span><span class="p">,</span> <span class="n">u64</span> <span class="n">r5</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The kernel abstracts the helper functions into <code>BPF_CALL_0()</code> to <code>BPF_CALL_5()</code> macros, similar in form to the corresponding type of system calls. The definition of these macros can be found in <a href="https://elixir.bootlin.com/linux/v5.4/source/include/linux/filter.h#L479">include/linux/filter.h</a>. Take <a href="https://elixir.bootlin.com/linux/v5.4/source/kernel/bpf/helpers.c#L41"><code>bpf_map_update_elem</code></a> for example, you can see that it updates the map element by calling the callback function of the corresponding map.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">BPF_CALL_4</span><span class="p">(</span><span class="n">bpf_map_update_elem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bpf_map</span> <span class="o">*</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">           <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">rcu_read_lock_held</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">map_update_elem</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_func_proto</span> <span class="n">bpf_map_update_elem_proto</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">func</span>           <span class="o">=</span> <span class="n">bpf_map_update_elem</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">gpl_only</span>       <span class="o">=</span> <span class="nb">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">ret_type</span>       <span class="o">=</span> <span class="n">RET_INTEGER</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">arg1_type</span>      <span class="o">=</span> <span class="n">ARG_CONST_MAP_PTR</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">arg2_type</span>      <span class="o">=</span> <span class="n">ARG_PTR_TO_MAP_KEY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">arg3_type</span>      <span class="o">=</span> <span class="n">ARG_PTR_TO_MAP_VALUE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">arg4_type</span>      <span class="o">=</span> <span class="n">ARG_ANYTHING</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This approach has a number of advantages.</p>
<blockquote>
<p>Although cBPF allows its load instructions to perform out-of-scope accesses (overload) in order to fetch data from a seemingly impossible packet offset to wake up a multifunction helper function, each cBPF JIT still needs to implement the corresponding support for this cBPF extension. In eBPF, however, the JIT compiler compiles the newly added helper functions in a transparent and efficient manner, meaning that the JIT compiler only needs to emit a call instruction because the register mapping is such that the BPF assignments already match the underlying architecture&rsquo;s calling conventions. matches the underlying architecture&rsquo;s calling conventions. This makes it very easy to extend the core kernel with helper functions. <strong>All BPF helper functions are part of the core kernel and cannot be extended or added via the kernel module</strong> .</p>
<p>The function signatures mentioned above also allow the verifier to perform type check. The <code>struct bpf_func_proto</code> above holds all the information that the <strong>checker needs to know about the helper function</strong> so that the checker can ensure that the expected type of the helper function matches the current contents of the BPF program registers.</p>
<p>The parameter types range from arbitrary values to restrictions to specific types, such as the <code>pointer/size</code> parameter pair of the BPF stack buffer, from which the helper function can read data or write data to. For this case, the verifier can also perform additional checks, for example, whether the buffer has been initialized.</p>
</blockquote>
<h3 id="tail-calls">Tail Calls</h3>
<p>Tail calls are a mechanism by which a BPF program can call another BPF program and not return to the original program when the call is complete.</p>
<ul>
<li>This call has minimal overhead compared to a normal function call, because it is <strong>implemented with a long jump, reusing the original stack frame</strong>.</li>
<li>BPF programs are independently verified, so to pass state, either use the per-CPU map as a scratch buffer or, in the case of tc programs, some fields of <code>skb</code> (e.g. <code>cb[]</code>).</li>
<li>Only programs of <strong>the same type can tail-call</strong> and they have to match the JIT compiler, so either the JIT compiler executes or the interpreted programs, but not both.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/3da18a4e84a94492a96709e4ba61ef57.png" alt="Tail Calls"></p>
<h3 id="bpf-to-bpf-calls">BPF to BPF Calls</h3>
<p>In addition to BPF helper functions and BPF tail calls, a new feature has recently been added to the BPF core infrastructure: <code>BPF to BPF calls</code>. <strong>Before this feature was introduced to the kernel, a typical BPF C program had to take special care of all code that needed to be reused. For example, it was declared as <code>always_inline</code> in the header file</strong> . When LLVM compiles and generates the BPF object file, all of these functions will be inlined, and therefore repeated multiple times in the generated object file, resulting in code size bloat.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef __section
</span></span></span><span class="line"><span class="cl"><span class="cp"># define __section(NAME)                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">   __attribute__((section(NAME), used))
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef __inline
</span></span></span><span class="line"><span class="cl"><span class="cp"># define __inline                         \
</span></span></span><span class="line"><span class="cl"><span class="cp">   inline __attribute__((always_inline))
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">__inline</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__section</span><span class="p">(</span><span class="s">&#34;prog&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">xdp_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdp_md</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">__license</span><span class="p">[]</span> <span class="n">__section</span><span class="p">(</span><span class="s">&#34;license&#34;</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;GPL&#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This is necessary because of the lack of support for function calls in the <strong>BPF program loader, verifier, interpreter and JIT</strong>. Starting with <code>Linux 4.16</code> and <code>LLVM 6.0</code>, this limitation has been addressed and BPF programs no longer need to use the <code>always_inline</code> declaration everywhere. As a result, the above code can be more naturally rewritten as:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef __section
</span></span></span><span class="line"><span class="cl"><span class="cp"># define __section(NAME)                  \
</span></span></span><span class="line"><span class="cl"><span class="cp">   __attribute__((section(NAME), used))
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">XDP_DROP</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">__section</span><span class="p">(</span><span class="s">&#34;prog&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">xdp_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdp_md</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="n">__license</span><span class="p">[]</span> <span class="n">__section</span><span class="p">(</span><span class="s">&#34;license&#34;</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;GPL&#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The BPF-to-BPF call is an important performance optimization that greatly reduces the size of the generated BPF code and is therefore <strong>more friendly to the CPU instruction cache (i-cache)</strong> .</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/b47a0c99c34549b398d33f95b89ad66f.png" alt="BPF-to-BPF call"></p>
<p>The BPF helper function calling convention also applies to BPF inter-function calls: * <code>r1</code> - <code>r5</code> is used to pass parameters.</p>
<ul>
<li>
<p><code>r1</code> - <code>r5</code> are used to pass arguments and return results to <code>r0</code>.</p>
</li>
<li>
<p><code>r1</code> - <code>r5</code> are scratch registers, <code>r6</code> - <code>r9</code> are reserved registers as usual.</p>
</li>
<li>
<p>The maximum nested call depth is <code>8</code>.</p>
</li>
<li>
<p>The caller can pass a pointer (e.g., a pointer to the caller&rsquo;s stack frame) to the callee, but not vice versa.</p>
</li>
<li>
<p>Currently, BPF inter-function calls and BPF tail calls are incompatible** because the latter require reusing the current stack setup, while the former add an extra stack frame and thus do not conform to the desired layout of tail calls.</p>
</li>
</ul>
<p>The BPF JIT compiler emits separate images for each function body, and later modifies the address of the function call in the image in the final JIT pass. It has been shown that this approach requires minimal modification to the various JITs because they can be implemented to treat BPF inter-function calls as regular BPF helper function calls.</p>
<h3 id="object-pinning">Object Pinning</h3>
<p><strong>BPF maps and programs can only be accessed as kernel resources via file descriptors behind anonymous inodes in the kernel.</strong> This brings a number of advantages.</p>
<ul>
<li>User-space applications can use most of the file descriptor-related APIs.</li>
<li>File descriptors passed to Unix sockets work transparently, etc.</li>
</ul>
<p>But at the same time, <strong>file descriptors are limited by the process lifecycle, making operations like map sharing very unwieldy</strong>, which introduces a lot of complexity in some specific scenarios.</p>
<blockquote>
<p>For example, iproute2, where the tc or XDP eventually exits after preparing the environment and loading the program into the kernel. In this case, the maps are also not accessible from user space, when they would be useful. For example, the maps shared in the ingress and egress locations of the data path (which can count packets, bytes, PPS, etc.). In addition, third-party applications may want to monitor or update maps while the BPF program is running.</p>
</blockquote>
<p><strong>To solve this problem, the kernel implements a minimum kernel space BPF file system into which BPF maps and BPF programs can be pinned</strong>, a process called <code>object pinning</code>. The BPF-related file system <strong>is not singleton</strong>, it supports multiple mounted instances, hard links, soft It supports multiple mounted instances, hard links, soft links, and so on.</p>
<p>Accordingly, the BPF system call is extended with two new commands, as shown below.</p>
<ul>
<li><code>BPF_OBJ_PIN</code> : pin an object.</li>
<li><code>BPF_OBJ_GET</code> : Get a pinned object.</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/4b3eb82c58e9490e83c272b760aa35d4.png" alt="object pinning"></p>
<h3 id="hardening">Hardening</h3>
<h4 id="protection-execution-protection">Protection Execution Protection</h4>
<p>To avoid code corruption, BPF locks the entire image after interpretation by the BPF interpreter (struct bpf_prog) and the image after JIT compilation (struct bpf_binary_header) as read-only in the kernel for the lifetime of the program. Any data corruption in these locations (e.g., due to some kernel bug) triggers the generic protection mechanism and therefore causes the kernel to crash rather than allowing the corruption to occur silently.</p>
<p>To see which platforms support setting image memory to read-only, you can use the following search.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ git grep ARCH_HAS_SET_MEMORY <span class="p">|</span> grep <span class="k">select</span>
</span></span><span class="line"><span class="cl">arch/arm/Kconfig:    <span class="k">select</span> ARCH_HAS_SET_MEMORY
</span></span><span class="line"><span class="cl">arch/arm64/Kconfig:  <span class="k">select</span> ARCH_HAS_SET_MEMORY
</span></span><span class="line"><span class="cl">arch/s390/Kconfig:   <span class="k">select</span> ARCH_HAS_SET_MEMORY
</span></span><span class="line"><span class="cl">arch/x86/Kconfig:    <span class="k">select</span> ARCH_HAS_SET_MEMORY
</span></span></code></pre></td></tr></table>
</div>
</div><p>The <code>CONFIG_ARCH_HAS_SET_MEMORY</code> option is not configurable, so platforms either have built-in support or they don&rsquo;t, and those architectures that don&rsquo;t currently support it may do so in the future.</p>
<h4 id="mitigation-against-spectre">Mitigation Against Spectre</h4>
<p>To defend against the <a href="https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)">Spectre v2</a> attack, the Linux kernel provides the <code>CONFIG_BPF_JIT_ALWAYS_ON</code> option, which, when turned on BPF interpreter will be completely removed from the kernel and the JIT compiler will be enabled forever.</p>
<ul>
<li>If applied in a VM-based environment, the client kernel will not reuse the kernel&rsquo;s BPF interpreter, thus avoiding certain related attacks.</li>
<li>In the case of a container-based environment, this configuration is optional, and if the JIT feature is turned on, the interpreter may still be removed at compile time to reduce the complexity of the kernel.</li>
<li>For JIT on mainstream architectures (e.g. <code>x86_64</code> and <code>arm64</code>) it is usually recommended to turn this switch on.</li>
</ul>
<p>Setting <code>/proc/sys/net/core/bpf_jit_harden</code> to <code>1</code> will do some additional hardening for unprivileged user JIT compilations. These additional hardenings will slightly degrade the performance of the program, but are effective in reducing the potential attack surface in the event that a non-trusted user is operating on the system. Still, these performance losses are relatively small compared to switching to an interpreter altogether. For the <code>x86_64</code> JIT compiler, if <code>CONFIG_RETPOLINE</code> is set, indirect jumps for tail calls are implemented with <code>retpoline</code>. At the time of writing this article, this configuration is turned on in most modern Linux distributions.</p>
<h4 id="constant-blinding">Constant Blinding</h4>
<p>Currently, enabling hardening <strong>blind</strong> all user-supplied 32- and 64-bit constants in BPF programs at JIT compile time to defend against <strong>JIT spraying attacks</strong> that inject native opcodes into the kernel as immediate numbers. This attack is effective because: <strong>immediate numbers reside in executable kernel memory</strong>, so some kernel bugs may trigger a jump action that, if it jumps to the start of immediate numbers, will start executing them as native instructions.</p>
<p>Blinded JIT constants are implemented by randomizing the actual instruction. In this approach, the original <strong>immediate-based operation</strong> is converted to a <strong>register-based operation</strong> by rewriting the instruction. Instruction rewriting breaks down the process of loading a value into two parts.</p>
<ol>
<li>load a blinded (immediate) number <code>rnd ^ imm</code> into a register</li>
<li>perform an iso-or operation (xor) on the register and <code>rnd</code>.</li>
</ol>
<p>This way the original <code>imm</code> immediate resides in the register and can be used for real operations. What is described here is only the blinded process of the load operation, in fact all general-purpose operations are blinded. The following is the result of a JIT compilation of a program with reinforcement turned off.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ echo 0 &gt; /proc/sys/net/core/bpf_jit_harden
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ffffffffa034f5e9 + &lt;x&gt;:
</span></span><span class="line"><span class="cl">  [...]
</span></span><span class="line"><span class="cl">  39:   mov    $0xa8909090,%eax
</span></span><span class="line"><span class="cl">  3e:   mov    $0xa8909090,%eax
</span></span><span class="line"><span class="cl">  43:   mov    $0xa8ff3148,%eax
</span></span><span class="line"><span class="cl">  48:   mov    $0xa89081b4,%eax
</span></span><span class="line"><span class="cl">  4d:   mov    $0xa8900bb0,%eax
</span></span><span class="line"><span class="cl">  52:   mov    $0xa810e0c1,%eax
</span></span><span class="line"><span class="cl">  57:   mov    $0xa8908eb4,%eax
</span></span><span class="line"><span class="cl">  5c:   mov    $0xa89020b0,%eax
</span></span><span class="line"><span class="cl">  [...]
</span></span></code></pre></td></tr></table>
</div>
</div><p>The result of the above program being loaded by a non-privileged user via BPF after the hardening has been opened (constant blinding has been performed here).</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ echo 1 &gt; /proc/sys/net/core/bpf_jit_harden
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  ffffffffa034f1e5 + &lt;x&gt;:
</span></span><span class="line"><span class="cl">  [...]
</span></span><span class="line"><span class="cl">  39:   mov    $0xe1192563,%r10d
</span></span><span class="line"><span class="cl">  3f:   xor    $0x4989b5f3,%r10d
</span></span><span class="line"><span class="cl">  46:   mov    %r10d,%eax
</span></span><span class="line"><span class="cl">  49:   mov    $0xb8296d93,%r10d
</span></span><span class="line"><span class="cl">  4f:   xor    $0x10b9fd03,%r10d
</span></span><span class="line"><span class="cl">  56:   mov    %r10d,%eax
</span></span><span class="line"><span class="cl">  59:   mov    $0x8c381146,%r10d
</span></span><span class="line"><span class="cl">  5f:   xor    $0x24c7200e,%r10d
</span></span><span class="line"><span class="cl">  66:   mov    %r10d,%eax
</span></span><span class="line"><span class="cl">  69:   mov    $0xeb2a830e,%r10d
</span></span><span class="line"><span class="cl">  6f:   xor    $0x43ba02ba,%r10d
</span></span><span class="line"><span class="cl">  76:   mov    %r10d,%eax
</span></span><span class="line"><span class="cl">  79:   mov    $0xd9730af,%r10d
</span></span><span class="line"><span class="cl">  7f:   xor    $0xa5073b1f,%r10d
</span></span><span class="line"><span class="cl">  86:   mov    %r10d,%eax
</span></span><span class="line"><span class="cl">  89:   mov    $0x9a45662b,%r10d
</span></span><span class="line"><span class="cl">  8f:   xor    $0x325586ea,%r10d
</span></span><span class="line"><span class="cl">  96:   mov    %r10d,%eax
</span></span><span class="line"><span class="cl">  [...]
</span></span></code></pre></td></tr></table>
</div>
</div><p>The two programs are semantically identical, but in the second way, the original immediate count is no longer visible in the program after disassembly. Also, the hardening disables any JIT kernel compliance (kallsyms) from being exposed to privileged users, and the JIT image address no longer appears in <code>/proc/kallsyms</code>.</p>
<h3 id="offloads">Offloads</h3>
<p>BPF network programs, especially tc and XDP BPF programs, have an offload to hardware interface in the kernel so that BPF programs can be executed directly on the NIC.</p>
<p>Currently, Netronome&rsquo;s <code>nfp</code> driver supports offload BPF via the JIT compiler, which translates BPF instructions into the instruction set implemented by the NIC. In addition, it also supports offloading BPF maps to the NIC, so offloaded BPF programs can perform map lookup, update, and delete operations.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/feb0737ba4a041658f2a6ceca0bf4a74.png" alt="Offloads"></p>
<h2 id="ebpf-interface">eBPF interface</h2>
<h3 id="bpf-system-call">BPF System Call</h3>
<p>eBPF provides the <a href="https://man7.org/linux/man-pages/man2/bpf.2.html"><code>bpf()</code></a> system call to operate on BPF Map or program with the following function prototype.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;linux/bpf.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">bpf</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">union</span> <span class="n">bpf_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>function has three arguments, of which.</p>
<ul>
<li><code>cmd</code> specifies the type of command to be executed by the bpf system call, and each cmd is accompanied by a parameter <code>attr</code></li>
<li><code>bpf_attr union</code> allows data to be passed between kernel and user space, the exact format depends on the <code>cmd</code> parameter</li>
<li>The <code>size</code> parameter indicates the size of the <code>bpf_attr union</code> object in bytes</li>
</ul>
<p>The <code>cmd</code> can be of the following types, which can be basically divided into two types: manipulating an eBPF Map and manipulating an eBPF program.</p>
<ul>
<li><code>BPF_MAP_CREATE</code>: creates an <code>eBPF Map</code> and returns a file descriptor pointing to the Map</li>
<li><code>BPF_MAP_LOOKUP_ELEM</code>: finds an element in a Map by its key and returns its value</li>
<li><code>BPF_MAP_UPDATE_ELEM</code>: creates or updates an element key/value pair in a Map</li>
<li><code>BPF_MAP_DELETE_ELEM</code> : Deletes an element in a Map based on key</li>
<li><code>BPF_MAP_GET_NEXT_KEY</code>: Find an element in a Map based on key and return the key of the next element</li>
<li><code>BPF_PROG_LOAD</code> : checks and loads an eBPF program, returning the file descriptor associated with the program</li>
<li>&hellip;</li>
</ul>
<p>The structure of the <code>bpf_attr union</code> is shown below, which can be populated with different information depending on the <code>cmd</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">union</span> <span class="n">bpf_attr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="p">{</span>    <span class="cm">/* Used by BPF_MAP_CREATE */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">map_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">key_size</span><span class="p">;</span>    <span class="cm">/* size of key in bytes */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">value_size</span><span class="p">;</span>  <span class="cm">/* size of value in bytes */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">max_entries</span><span class="p">;</span> <span class="cm">/* maximum number of entries in a map */</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="p">{</span>    <span class="cm">/* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY commands */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">map_fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__aligned_u64</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">__aligned_u64</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">__aligned_u64</span> <span class="n">next_key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u64</span>         <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="p">{</span>    <span class="cm">/* Used by BPF_PROG_LOAD */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">prog_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">insn_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__aligned_u64</span> <span class="n">insns</span><span class="p">;</span>      <span class="cm">/* &#39;const struct bpf_insn *&#39; */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__aligned_u64</span> <span class="n">license</span><span class="p">;</span>    <span class="cm">/* &#39;const char *&#39; */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">log_level</span><span class="p">;</span>  <span class="cm">/* verbosity level of verifier */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">log_size</span><span class="p">;</span>   <span class="cm">/* size of user buffer */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__aligned_u64</span> <span class="n">log_buf</span><span class="p">;</span>    <span class="cm">/* user supplied &#39;char *&#39; buffer */</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u32</span>         <span class="n">kern_version</span><span class="p">;</span> <span class="cm">/* checked when prog_type=kprobe (since Linux 4.1) */</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="commands-for-using-ebpf-programs">Commands for using eBPF programs</h4>
<p>The <code>BPF_PROG_LOAD</code> command is used to verify and load the eBPF program with the filled parameter <code>bpf_xattr</code>, which is shown below in <code>libbpf</code> <a href="https://elixir.bootlin.com/linux/v5.4/source/tools/lib/bpf/bpf.c#L316"><code>bpf_load_program</code></a> in <code>libbpf</code>, you can see that the <code>bpf</code> system call is eventually called.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bpf_load_program</span><span class="p">(</span><span class="k">enum</span> <span class="n">bpf_prog_type</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_insn</span> <span class="o">*</span><span class="n">insns</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">size_t</span> <span class="n">insns_cnt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">license</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">__u32</span> <span class="n">kern_version</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">log_buf</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">size_t</span> <span class="n">log_buf_sz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">bpf_load_program_attr</span> <span class="n">load_attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">load_attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_load_program_attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">load_attr</span><span class="p">.</span><span class="n">prog_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">load_attr</span><span class="p">.</span><span class="n">expected_attach_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">load_attr</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">load_attr</span><span class="p">.</span><span class="n">insns</span> <span class="o">=</span> <span class="n">insns</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">load_attr</span><span class="p">.</span><span class="n">insns_cnt</span> <span class="o">=</span> <span class="n">insns_cnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">load_attr</span><span class="p">.</span><span class="n">license</span> <span class="o">=</span> <span class="n">license</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">load_attr</span><span class="p">.</span><span class="n">kern_version</span> <span class="o">=</span> <span class="n">kern_version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bpf_load_program_xattr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">load_attr</span><span class="p">,</span> <span class="n">log_buf</span><span class="p">,</span> <span class="n">log_buf_sz</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bpf_load_program_xattr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_load_program_attr</span> <span class="o">*</span><span class="n">load_attr</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="kt">char</span> <span class="o">*</span><span class="n">log_buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">log_buf_sz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">fd</span> <span class="o">=</span> <span class="n">sys_bpf_prog_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sys_bpf_prog_load</span><span class="p">(</span><span class="k">union</span> <span class="n">bpf_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">fd</span> <span class="o">=</span> <span class="n">sys_bpf</span><span class="p">(</span><span class="n">BPF_PROG_LOAD</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Implementation of <a href="https://elixir.bootlin.com/linux/v5.4/source/tools/lib/bpf/bpf.c#L371"><code>bpf_map_lookup_elem</code></a> in <code>libbpf</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bpf_map_lookup_elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="n">bpf_attr</span> <span class="n">attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">map_fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">ptr_to_u64</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">ptr_to_u64</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sys_bpf</span><span class="p">(</span><span class="n">BPF_MAP_LOOKUP_ELEM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Implementation of <a href="https://elixir.bootlin.com/linux/v5.4/source/tools/lib/bpf/bpf.c#L357"><code>bpf_map_update_elem</code></a> in <code>libbpf</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bpf_map_update_elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">__u64</span> <span class="n">flags</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="n">bpf_attr</span> <span class="n">attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">map_fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">ptr_to_u64</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">ptr_to_u64</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sys_bpf</span><span class="p">(</span><span class="n">BPF_MAP_UPDATE_ELEM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Implementation of <a href="https://elixir.bootlin.com/linux/v5.4/source/tools/lib/bpf/bpf.c#L408"><code>bpf_map_delete_elem</code></a> in <code>libbpf</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bpf_map_delete_elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="n">bpf_attr</span> <span class="n">attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">map_fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">ptr_to_u64</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sys_bpf</span><span class="p">(</span><span class="n">BPF_MAP_DELETE_ELEM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Implementation of <a href="https://elixir.bootlin.com/linux/v5.4/source/tools/lib/bpf/bpf.c#L419"><code>bpf_map_get_next_key</code></a> in <code>libbpf</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">bpf_map_get_next_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">next_key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">union</span> <span class="n">bpf_attr</span> <span class="n">attr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">map_fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">ptr_to_u64</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">attr</span><span class="p">.</span><span class="n">next_key</span> <span class="o">=</span> <span class="n">ptr_to_u64</span><span class="p">(</span><span class="n">next_key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sys_bpf</span><span class="p">(</span><span class="n">BPF_MAP_GET_NEXT_KEY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">attr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Note that the <code>libbpf</code> functions here are not quite the same as the <code>helper functions</code> mentioned before, you can see the current Linux supported <code>Helper functions</code> at <a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">Linux Manual Page: bpf-helpers</a> to see the current <code>Helper functions</code> supported by Linux. Take <code>bpf_map_update_elem</code> as an example, the eBPF program calls the <code>helper function</code> with the following parameters.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">msg</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">__s32</span> <span class="n">seq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u64</span> <span class="n">cts</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__u8</span> <span class="n">comm</span><span class="p">[</span><span class="n">MAX_LENGTH</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">bpf_map_def</span> <span class="nf">SEC</span><span class="p">(</span><span class="s">&#34;maps&#34;</span><span class="p">)</span> <span class="n">map</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BPF_MAP_TYPE_PERF_EVENT_ARRAY</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">key_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">value_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__u32</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">max_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="n">bpf_map_lookup_elem</span><span class="p">(</span><span class="k">struct</span> <span class="n">bpf_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>The first argument here comes from the <code>bpf_map</code> created by the <code>SEC(&quot;.maps&quot;)</code> syntactic sugar.</p>
<p>For a user-state program, the function prototype is as follows, where the eBPF map is accessed via fd.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">bpf_map_lookup_elem</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="bpf-program-types">BPF Program Types</h3>
<p>The program type loaded by the function <code>BPF_PROG_LOAD</code> specifies four things.</p>
<ul>
<li>Where the program can be attached.</li>
<li>Which helper functions in the kernel are allowed to be called by the validator.</li>
<li>Whether data from network packets can be accessed directly.</li>
<li>The type of object passed to the program as the first argument.</li>
</ul>
<p>In fact, the program type essentially defines an API. even new program types are created to distinguish between the different lists of functions allowed to be called (e.g. <code>BPF_PROG_TYPE_CGROUP_SKB</code> versus <code>BPF_PROG_TYPE_SOCKET_FILTER</code>).</p>
<p>The bpf program is hooked to different hook points in the kernel. Different hook points have different entry parameters and different capabilities. Different prog types are defined, and the set of kernel functions that can be called by bpf programs with different prog types is also different. When a bpf program is loaded into the kernel, the kernel verifier program checks which helper functions are called based on the entry parameters of the program according to the bpf prog type.</p>
<p>The list of eBPF program types currently supported by the kernel is shown below.</p>
<ul>
<li><code>BPF_PROG_TYPE_SOCKET_FILTER</code> : a network packet filter</li>
<li><code>BPF_PROG_TYPE_KPROBE</code> : Determines whether kprobe should be triggered</li>
<li><code>BPF_PROG_TYPE_SCHED_CLS</code> : a network traffic control classifier</li>
<li><code>BPF_PROG_TYPE_SCHED_ACT</code> : a network traffic control action</li>
<li><code>BPF_PROG_TYPE_TRACEPOINT</code> : Determines whether a tracepoint should be triggered</li>
<li><code>BPF_PROG_TYPE_XDP</code> : a network packet filter that runs in the receive path from the device driver</li>
<li><code>BPF_PROG_TYPE_PERF_EVENT</code> : Determines if the perf event handler should be triggered</li>
<li><code>BPF_PROG_TYPE_CGROUP_SKB</code> : a network packet filter for control groups</li>
<li><code>BPF_PROG_TYPE_CGROUP_SOCK</code> : a network packet filter for control groups that is allowed to modify socket options</li>
<li><code>BPF_PROG_TYPE_LWT_*</code> : a network packet filter for lightweight tunnels</li>
<li><code>BPF_PROG_TYPE_SOCK_OPS</code> : a program for setting socket parameters</li>
<li><code>BPF_PROG_TYPE_SK_SKB</code> : a network packet filter for forwarding packets between sockets</li>
<li><code>BPF_PROG_CGROUP_DEVICE</code> : Determines whether device operations are allowed</li>
</ul>
<p>As new program types are added, kernel developers also find the need to add new data structures.</p>
<p>For example, which bpf helper function can be accessed by the BPF_PROG_TYPE_SCHED_CLS bpf prog? Let&rsquo;s see how the source code implements this.</p>
<p>Each prog type defines a <code>struct bpf_verifier_ops</code> structure. When a prog is loaded into the kernel, the kernel calls the get_func_proto function of the corresponding structure, depending on its type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">const</span> <span class="k">struct</span> <span class="n">bpf_verifier_ops</span> <span class="n">tc_cls_act_verifier_ops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">get_func_proto</span>         <span class="o">=</span> <span class="n">tc_cls_act_func_proto</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">convert_ctx_access</span>     <span class="o">=</span> <span class="n">tc_cls_act_convert_ctx_access</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>For BPF codes of type BPF_PROG_TYPE_SCHED_CLS, the verifier calls <code>tc_cls_act_func_proto</code> to check if all the helper functions called by the program are legitimate.</p>
<h3 id="bpf-code-call-timing">BPF code call timing</h3>
<p>Each prog type has a different timing.</p>
<h4 id="bpf_prog_type_sched_cls">BPF_PROG_TYPE_SCHED_CLS</h4>
<p>BPF_PROG_TYPE_SCHED_CLS is called as follows.</p>
<h5 id="egress-direction">Egress direction</h5>
<p>In the egress direction, after the tcp/ip stack is running, there is a hook point. This hook point can attach the BPF_PROG_TYPE_SCHED_CLS type of bpf prog in the egress direction. After this bpf code is executed, the qos, tcpdump, and xmit to NIC driver code will be run. In this bpf code you can modify the contents of the message, the address, etc. After the changes are made, you can see them through tcpdump, because the tcpdump code is executed after that.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">__dev_queue_xmit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">sb_dev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">skb</span> <span class="o">=</span> <span class="n">sch_handle_egress</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rc</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// enqueue tc qos
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// dequeue tc qos
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// dev_hard_start_xmit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// tcpdump works here! dev_queue_xmit_nit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// nic driver-&gt;ndo_start_xmit 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="ingress-direction">Ingress direction</h5>
<p>There is a hook point in the ingress direction, before deliver to the tcp/ip stack and after tcpdump. This hook point can attach BPF_PROG_TYPE_SCHED_CLS type of bpf prog in ingress direction. Here you can also modify the message. But the result of the modification is not visible in tcpdump.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">__netif_receive_skb_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">**</span><span class="n">pskb</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">pfmemalloc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                    <span class="k">struct</span> <span class="n">packet_type</span> <span class="o">**</span><span class="n">ppt_prev</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// generic xdp bpf hook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// tcpdump 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// tc ingress hook
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">skb</span> <span class="o">=</span> <span class="n">sch_handle_ingress</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pt_prev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span> <span class="n">orig_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">another</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// deliver to tcp/ip stack or bridge/ipvlan device
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="execution-portal-cls_bpf_classify">execution portal cls_bpf_classify</h5>
<p>The real entry point for executing the bpf instruction, regardless of egress or ingress direction, is cls_bpf_classify. It traverses the bpf prog link list in tcf_proto and executes BPF_PROG_RUN(prog-&gt;filter, skb) for each bpf prog.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">cls_bpf_classify</span><span class="p">(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">tcf_proto</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="k">struct</span> <span class="n">tcf_result</span> <span class="o">*</span><span class="n">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">cls_bpf_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">rcu_dereference_bh</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">cls_bpf_prog</span> <span class="o">*</span><span class="n">prog</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">plist</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="kt">int</span> <span class="n">filter_res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                                <span class="k">if</span> <span class="p">(</span><span class="n">tc_skip_sw</span><span class="p">(</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">gen_flags</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">filter_res</span> <span class="o">=</span> <span class="n">prog</span><span class="o">-&gt;</span><span class="n">exts_integrated</span> <span class="o">?</span> <span class="nl">TC_ACT_UNSPEC</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">at_ingress</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="cm">/* It is safe to push/pull even if skb_shared() */</span>
</span></span><span class="line"><span class="cl">                        <span class="n">__skb_push</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">bpf_compute_data_pointers</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">filter_res</span> <span class="o">=</span> <span class="n">BPF_PROG_RUN</span><span class="p">(</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">__skb_pull</span><span class="p">(</span><span class="n">skb</span><span class="p">,</span> <span class="n">skb</span><span class="o">-&gt;</span><span class="n">mac_len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">bpf_compute_data_pointers</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="n">filter_res</span> <span class="o">=</span> <span class="n">BPF_PROG_RUN</span><span class="p">(</span><span class="n">prog</span><span class="o">-&gt;</span><span class="n">filter</span><span class="p">,</span> <span class="n">skb</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>BPF_PROG_RUN executes the bpf instruction for JIT compile, or if the kernel does not support JIT, it calls the interpreter to execute the byte code for bpf.</p>
<p>The entry parameter that BPF_PROG_RUN passes to bpf prog is skb, whose type is <code>struct sk_buff</code> , defined in the file include/linux/skbuff.h.</p>
<p>But in the bpf code, you cannot access <code>sk_buff</code> directly for security reasons. bpf accesses struct sk_buff by accessing <code>struct __sk_buff</code>. <code>__sk_buff</code> is a subset of <code>sk_buff</code> and is the interface to the sk_buff-oriented bpf program. accesses to <code>__sk_buff</code> in bpf code are translated in the verifier program into accesses to the corresponding fileds of sk_buff.</p>
<p>When loading the bpf prog, the verifier calls the hook of tc_cls_act_convert_ctx_access inside the <code>tc_cls_act_verifier_ops</code> structure above. It will eventually call the following function to modify the ebpf directive so that the access to <code>__sk_buff</code> becomes an access to <code>struct sk_buff</code>.</p>
<h3 id="bpf-attach-type">BPF Attach type</h3>
<p>A type of bpf prog can be attached to different hooks in the kernel, and these different hooks are different attach types.</p>
<p>The correspondence is defined in <a href="https://elixir.bootlin.com/linux/v5.17-rc8/source/kernel/bpf/syscall.c#L3137">the following function</a>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">attach_type_to_prog_type</span><span class="p">(</span><span class="k">enum</span> <span class="n">bpf_attach_type</span> <span class="n">attach_type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">switch</span> <span class="p">(</span><span class="n">attach_type</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BPF_CGROUP_INET_INGRESS</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BPF_CGROUP_INET_EGRESS</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">BPF_PROG_TYPE_CGROUP_SKB</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BPF_CGROUP_INET_SOCK_CREATE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BPF_CGROUP_INET_SOCK_RELEASE</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BPF_CGROUP_INET4_POST_BIND</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">BPF_CGROUP_INET6_POST_BIND</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">BPF_PROG_TYPE_CGROUP_SOCK</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">.....</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When a bpf prog attaches to a specific hook point via the bpf() system call, the attach type needs to be specified in its entry parameter.</p>
<p>Interestingly, bpf prog of type BPF_PROG_TYPE_SCHED_CLS cannot attach via the bpf system call because it does not have a corresponding attach type defined, so its attachment requires an additional implementation via the netlink interface, which is still very complicated.</p>
<h3 id="introduction-to-common-prog-types">Introduction to common prog types</h3>
<p>There are currently 30 types of prog types in the kernel. Each type can do different things, so I will only talk about the ones I usually use for work.</p>
<p>The best way to understand a prog type is to</p>
<ul>
<li>look up the attach_type_to_prog_type table and get its attach type.</li>
<li>then search the kernel code to see where these attach types are called in the kernel.</li>
<li>Finally, look at its entry parameters and return value handling to basically understand what it does.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">include</span><span class="o">/</span><span class="n">uapi</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">bpf</span><span class="p">.</span><span class="n">h</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">enum</span> <span class="n">bpf_prog_type</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="bpf_prog_type_socket_filter">BPF_PROG_TYPE_SOCKET_FILTER</h4>
<p>is the first program type to be added to the kernel. When you attach a bpf program to a socket, you get access to all packets that are processed by the socket. socket filtering does not allow you to modify these packets and their destinations. It only provides you with the ability to observe these packets. In your program you can get things like the protocol type.</p>
<p>In tcp for example, the call is made from tcp_v4_rcv-&gt;tcp_filter-&gt;sk_filter_trim_cap to filter packets, or trim packets. udp, icmp also have related calls.</p>
<h4 id="bpf_prog_type_sock_ops">BPF_PROG_TYPE_SOCK_OPS</h4>
<p>The bpf hook, called when a tcp protocol event occurs, defines 15 types of events. The attach type of these events is BPF_CGROUP_SOCK_OPS. Different enum is passed in at different call points, for example</p>
<ul>
<li>BPF_SOCK_OPS_TCP_CONNECT_CB is for the active tcp connect call.</li>
<li>BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB is called on passive connect success.</li>
</ul>
<p>Main functions: tcp tuning, event statistics, etc.</p>
<p>BPF_PROG_TYPE_SOCK_OPS This program type allows you to modify the link options of a socket when packets are transmitted at various stages of the kernel network stack. They attach to cgroups much like BPF_PROG_TYPE_CGROUP_SOCK and BPF_PROG_TYPE_CGROUP_SKB, but the difference is that they can be called several times throughout the life of the connection. Your bpf program receives an op argument that represents the operation that the kernel will perform over the socket link. Therefore, you know when to call the program during the lifetime of the link. On the other hand, you can get the ip address, port, etc. You can also modify the link&rsquo;s link options to set the timeout and change the packet round-trip delay time.</p>
<p>As an example, Facebook uses it to set a short recovery time objective (RTO) for connections within the same data center.RTO is a time that refers to the recovery time of the network after a failure, a metric that also indicates how long the network is unavailable in case of unacceptable conditions.Facebook believes that there should be a very short RTO, Facebook modified this time to use the bpf procedure.</p>
<h4 id="bpf_prog_type_cgroup_sock_addr">BPF_PROG_TYPE_CGROUP_SOCK_ADDR</h4>
<p>It corresponds to many attachment types, usually called when bind, connect, pass in the address of the sock.</p>
<p>The main role: for example, the implementation of clusterip in cilium, in the active connect, modified the destination ip address, is to use this.</p>
<p>BPF_PROG_TYPE_CGROUP_SOCK_ADDR, this type of program allows you to manipulate IP addresses and port numbers in userspace programs controlled by a specific cgroup. In some cases, the system will use multiple IP addresses when you want to ensure that a specific set of userspace programs use the same IP address and port. These BPF programs give you the flexibility to manipulate these bindings when you place these userspace programs in the same cgroup. This ensures that all incoming and outgoing connections to these applications use the IP and port provided by the BPF program.</p>
<h4 id="bpf_prog_type_sk_msg">BPF_PROG_TYPE_SK_MSG</h4>
<p>BPF_PROG_TYPE_SK_MSG, These types of programs let you control whether a message sent to a socket should be delivered. When the kernel creates a socket, it is stored in the map mentioned earlier . When you attach a program to this socket map, all messages sent to those sockets are filtered. Before filtering the message, the kernel copies the data, so you can read the messages and give your decision: for example, SK_PASS and SK_DROP.</p>
<h4 id="bpf_prog_type_sk_skb">BPF_PROG_TYPE_SK_SKB</h4>
<p>Call point: called when tcp sendmsg.</p>
<p>Main purpose: for sock redir.</p>
<p>BPF_PROG_TYPE_SK_SKB, this kind of program allows you to get socket maps and socket redirects. socket maps allows you to get some references to sockets. When you have these references, you can use the associated helpers to redirect an incoming packet from one socket to another scoket. You can forward network packets between sockets without leaving the kernel space, and Cillium and Facebook&rsquo;s Katran use this type of program extensively for traffic control.</p>
<h4 id="bpf_prog_type_cgroup_sockopt">BPF_PROG_TYPE_CGROUP_SOCKOPT</h4>
<p>Call points: getsockopt, setsockopt.</p>
<h4 id="bpf_prog_type_kprobe">BPF_PROG_TYPE_KPROBE</h4>
<p>Similar to ftrace&rsquo;s kprobe, at the hook point of the function entry/exit, used for debug.</p>
<h4 id="bpf_prog_type_tracepoint">BPF_PROG_TYPE_TRACEPOINT</h4>
<p>Similar to ftrace&rsquo;s tracepoint.</p>
<h4 id="bpf_prog_type_sched_cls-1">BPF_PROG_TYPE_SCHED_CLS</h4>
<p>As in the example above.</p>
<h4 id="bpf_prog_type_xdp">BPF_PROG_TYPE_XDP</h4>
<p>A hook point before the sk_buff data structure is generated when the NIC driver receives the packet.</p>
<p>BPF_PROG_TYPE_XDP allows your bpf program to do this very early in the network packet&rsquo;s arrival at the kernel. In such a bpf program, you may get just a little bit of information because the kernel has not had enough time to process it. Because it&rsquo;s early enough, you can process these packets at a very high level of the network.</p>
<p>XDP defines a number of ways to handle this, for example</p>
<ul>
<li>XDP_PASS means that you will pass the packet to another subsystem of the kernel to handle.</li>
<li>XDP_DROP means that the kernel should discard the packet.</li>
<li>XDP_TX means that you can forward this packet to the network interface card (NIC) the first time it receives it.</li>
</ul>
<h4 id="bpf_prog_type_cgroup_skb">BPF_PROG_TYPE_CGROUP_SKB</h4>
<p>BPF_PROG_TYPE_CGROUP_SKB allows you to filter the network traffic for the entire cgroup. In this program type, you can do some control over the network traffic before it reaches the programs in this cgoup. Any packet that the kernel tries to pass to any process in the same cgroup will pass through one of these filters. Also, you can decide what processes in the cgroup should do when sending network packets through this interface. In fact, you can find it very similar in type to BPF_PROG_TYPE_SOCKET_FILTER. The biggest difference is that cgroup_skb is attaching to all processes in this cgroup, not a special process. In a container environment, bpf is very useful.</p>
<ul>
<li>ingress direction, tcp calls this bpf to do filtering when it receives a message (tcp_v4_rcv).</li>
<li>In the egress direction, ip calls it to do packet loss filtering on outgoing packets (ip_finish_output) The input parameter is skb.</li>
</ul>
<h4 id="bpf_prog_type_cgroup_sock">BPF_PROG_TYPE_CGROUP_SOCK</h4>
<p>Called on sock create, release, post_bind. It is mainly used to do some permission checking.</p>
<p>BPF_PROG_TYPE_CGROUP_SOCK, this type of bpf program allows you to execute your bpf program when any process in a cgroup opens a socket. This behavior is similar to the behavior of CGROUP_SKB, but it is provided to you when a process in a cgoup opens a new socket, rather than giving you permission control for network packets to pass through. This is useful for providing security and access control for groups of programs that can open sockets without having to restrict the functionality of each process separately.</p>
<h2 id="ebpf-tool-chain">eBPF tool chain</h2>
<h3 id="bcc">bcc</h3>
<p>BCC is a collection of compilation tools for BPF, providing a Python/Lua API on the front-end, implemented in C/C++ itself, and integrated with LLVM/Clang to rewrite, compile and load BPF programs, providing some more user-friendly functions for users to use.</p>
<p>While BCC does its best to simplify the work of BPF program developers, its &ldquo;black magic&rdquo; (using the Clang front-end to modify user-written BPF programs) makes it difficult to find problems and solutions when they occur. Naming conventions and automatically generated trace point structures must be remembered. The libbcc library has a large LLVM/Clang library integrated into it, which makes it problematic to use.</p>
<ol>
<li>using high CPU and memory resources to compile BPF programs at the start of each tool, which may cause problems when running on a server that is already short of system resources.</li>
<li>relying on kernel header packages that must be installed on each target host. Even so, if something not exported in the kernel is required, the type definition needs to be manually copied/pasted into the BPF code.</li>
<li>Since BPF programs are compiled at runtime, many simple compilation errors can only be detected at runtime, which affects the development experience.</li>
</ol>
<p>With the implementation of BPF CO-RE, we can use the libbpf library provided by kernel developers to develop BPF programs directly, in the same way as writing ordinary C user-state programs: compile once to generate small binaries. libbpf, as the BPF program loader, takes over the functions of redirection, loading, validation, etc., and BPF program developers only need to focus on the correctness and performance of BPF programs. program developer only needs to focus on the correctness and performance of the BPF program. This approach minimizes overhead and removes large dependencies, making the overall development process much smoother.</p>
<p>Brendan Gregg, a performance optimization guru, gives comparative performance data after converting a BCC tool with libbpf + BPF CO-RE.</p>
<blockquote>
<p>As my colleague Jason pointed out, the memory footprint of opensnoop as CO-RE is much lower than opensnoop.py. 9 Mbytes for CO-RE vs 80 Mbytes for Python.</p>
</blockquote>
<p>We can see that the libbpf + BPF CO-RE version saves nearly 9 times the memory overhead at runtime compared to the BCC version, which is more friendly to servers that are already strapped for physical memory resources.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/7a0ca364963e4f848a4908d8df79dc06.png" alt="bbc"></p>
<h3 id="bpftrace">bpftrace</h3>
<blockquote>
<p>bpftrace is a high-level tracing language for Linux eBPF and available in recent Linux kernels (4.x). bpftrace uses LLVM as a backend to compile scripts to eBPF bytecode and makes use of BCC for interacting with the Linux eBPF subsystem as well as existing Linux tracing capabilities: kernel dynamic tracing (kprobes), user-level dynamic tracing (uprobes), and tracepoints. The bpftrace language is inspired by awk, C and predecessor tracers such as DTrace and SystemTap.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/afb19fe26f0946c5a0bd720179137e14.png" alt="bpftrace"></p>
<h3 id="ebpf-go-library">eBPF Go Library</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/0abdc7118c984930805e4fc528a6a7f6.png" alt="eBPF Go Library"></p>
<h3 id="libbpf">libbpf</h3>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/13/68a25ac548db44c0b141074d667f7153.png" alt="libbpf"></p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-04/go-ebfp/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Develop eBPF programs using Go language</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-04/linux-nohup-setsid-disown/">
            <span class="next-text nav-default">The difference between nohup, setsid and disown</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
