<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Cache coherence protocol analysis - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Explore common cache coherence protocols." /><meta name="keywords" content="Cache Coherence Protocol" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/cache-coherence-protocol/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Cache coherence protocol analysis" />
<meta property="og:description" content="Explore common cache coherence protocols." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/cache-coherence-protocol/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-10T10:22:20+08:00" />
<meta property="article:modified_time" content="2022-04-10T10:22:20+08:00" />

<meta itemprop="name" content="Cache coherence protocol analysis">
<meta itemprop="description" content="Explore common cache coherence protocols."><meta itemprop="datePublished" content="2022-04-10T10:22:20+08:00" />
<meta itemprop="dateModified" content="2022-04-10T10:22:20+08:00" />
<meta itemprop="wordCount" content="2441">
<meta itemprop="keywords" content="cache," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Cache coherence protocol analysis"/>
<meta name="twitter:description" content="Explore common cache coherence protocols."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Cache coherence protocol analysis</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-10 10:22:20 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 2441 words </span>
          <span class="more-meta"> 12 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#write-invalidate-and-write-update">Write-invalidate and Write-update</a></li>
        <li><a href="#write-once-protocol">Write-once protocol</a></li>
        <li><a href="#msi-protocol">MSI Protocol</a></li>
        <li><a href="#mesi-protocol">MESI Protocol</a></li>
        <li><a href="#moesi-protocol">MOESI Protocol</a></li>
        <li><a href="#dragon-protocol">Dragon Protocol</a></li>
        <li><a href="#ace-protocol">ACE protocol</a></li>
        <li><a href="#directory-based-cache-consistency">Directory-based cache consistency</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="write-invalidate-and-write-update">Write-invalidate and Write-update</h2>
<p>There are two basic cache coherence ideas.</p>
<ol>
<li>write-invalidate: when writing data, set this Cache Line in other Cache to Invalid</li>
<li>write-update: when writing data, write the new result to other Cache that has this Cache Line</li>
</ol>
<h2 id="write-once-protocol">Write-once protocol</h2>
<p>The write-once protocol defines four states.</p>
<ol>
<li>Invalid: indicates that the block is not legal</li>
<li>Valid: indicates that the block is legal and may be shared, and that the data has not been modified</li>
<li>Reserved: indicates that the block is legal, not shared, and that the data has not been changed</li>
<li>Dirty: means the block is legal, not shared, and the data has been modified, which is different from the memory.</li>
</ol>
<p>As you can see, when one cache state is R or D, the other caches can only be I. When the cache state is V, there can be multiple caches in V state.</p>
<p>The characteristic of the write-once protocol is that the first write is written to memory (similar to write-through) and successive writes are written to cache only, similar to write-back.</p>
<p>When a Read hit occurs, the state is unchanged.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Read hit: The information is supplied by the current cache. No state change.
</span></span></code></pre></td></tr></table>
</div>
</div><p>When a Read miss occurs, it looks at all caches and if there are other caches in the Valid/Reserved/Dirty state, it reads the data from the other caches and sets it to Valid and the other caches to Valid. If the other caches are in the Dirty state, it also writes the data to memory.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Read miss: The data is read from main memory. The read is snooped by other caches; if any of them have the line in the Dirty state, the read is interrupted long enough to write the data back to memory before it is allowed to continue. Any copies in the Dirty or Reserved states are set to the Valid state.
</span></span></code></pre></td></tr></table>
</div>
</div><p>When a Write hit occurs, if it is in the Valid state, the memory is written to first, setting all other Caches to Invalid and entering the Reserved state, which means the first write is Write-through. This means that all subsequent writes are Write-back.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Write hit: If the information in the cache is in Dirty or Reserved state, the cache line is updated in place and its state is set to Dirty without updating memory. If the information is in Valid state, a write-through operation is executed updating the block and the memory and the block state is changed to Reserved. Other caches snoop the write and set their copies to Invalid.
</span></span></code></pre></td></tr></table>
</div>
</div><p>When a Write miss occurs, the behavior is different from what Wikipedia tells us in class. According to Wikipedia, it is first handled as a Read miss and then as a Write hit, similar to the idea of a Write Allocate. If this is the case, then the data is first read from other caches or memory, then all other caches are set to Invalid, and the updated data is written to memory and enters the Reserved state. This is equivalent to Write miss, which is also implemented as a write-through.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">Write miss: A partial cache line write is handled as a read miss (if necessary to fetch the unwritten portion of the cache line) followed by a write hit. This leaves all other caches in the Invalid state, and the current cache in the Reserved state.
</span></span></code></pre></td></tr></table>
</div>
</div><p>The textbook says that a write-miss is treated as a write-back. If all the other caches are Invalid, read the data from memory and write it to the cache to enter the Dirty state. If the other caches are Valid/Reserved/Dirty, read the data from the other caches, put all the other caches into Invalid state, and then update your own data and enter Dirty state.</p>
<h2 id="msi-protocol">MSI Protocol</h2>
<p>The MSI protocol is relatively simple, it defines three states.</p>
<ol>
<li>Modified: indicates that the data has been modified and is not the same as in memory</li>
<li>Shared: the data is consistent with the memory, there can be one or more caches in Shared state at the same time</li>
<li>Invalid: not in the cache</li>
</ol>
<p>When Read hit, the state is unchanged.</p>
<p>When Read miss, check the status of other caches, if they are all Invalid, read from memory and enter Shared state. If there is Shared, read from other caches. If there is Dirty, then write the data from other caches to memory and local cache, and then go to Shared state.</p>
<p>When a Write hit occurs, if it is now in Shared state, put the other Shared cache into Invalid state, then update the data and enter Modified state. If the state is Modified, the data is modified and the state remains unchanged.</p>
<p>When a Write miss occurs, if there is another cache in the Modified/Shared state, then read the data from the other cache and put the other cache into the Invalid state, then modify the local data and go to the Modified state. If all caches are in Invalid state, then read from memory and modify the cache data to go to Modified state.</p>
<h2 id="mesi-protocol">MESI Protocol</h2>
<p>The MESI protocol defines four states.</p>
<ol>
<li>Modified: data is inconsistent with memory and only one cache has data</li>
<li>Exclusive: data is consistent with memory and only one cache has data</li>
<li>Shared: data is consistent with memory, and there can be multiple caches with data at the same time</li>
<li>Invalid: not in the cache</li>
</ol>
<p>When Read hit, the status is unchanged.</p>
<p>When Read miss, first check the status of other cache, if there is data, read data from other cache, and all will enter Shared state. If the other caches are in Modified state, the data will be written to memory; if there is no data in the other caches, it will be read from memory, and then it will enter Exclusive state.</p>
<p>When a Write hit occurs, it enters the Modified state and the other caches enter the Invalid state.</p>
<p>When a Write miss occurs, the state of the other caches is checked, and if there is data, it is read from the other caches, otherwise it is read from memory. Then, all other caches enter the Invalid state, and the local cache updates its data and enters the Modified state.</p>
<p>It is worth mentioning that Shared state does not necessarily mean that only one cache has data: for example, if there are two caches in Shared state and one of them becomes Invalid due to a cache replacement, the other one will not be notified of the change to Exclusive. For example, when there is only one core accessing the data, only the first Read miss will send a bus request, after that it will be in Exclusive/Modified state and no bus request will be sent.</p>
<h2 id="moesi-protocol">MOESI Protocol</h2>
<p>MOESI defines five states.</p>
<ol>
<li>Modified: the data has been modified and only one cache has this data</li>
<li>Owned: Multiple caches have the data at the same time, but only this cache can modify the data</li>
<li>Exclusive: the data is not modified and only one cache has the data</li>
<li>Shared: Multiple caches have the data at the same time, but the data cannot be modified</li>
<li>Invalid: not in the cache</li>
</ol>
<p>In the state, M and E are exclusive and there can be only one in all caches. In addition, there can be multiple S&rsquo;s at the same time, or multiple S&rsquo;s plus one O, but not multiple O&rsquo;s at the same time.</p>
<p>Its state transfer is similar to MESI, except that when the core writes to a cache in the Owned state, there are two ways: 1) notify the other Shared cache to update the data; 2) set the other Shared cache to Invalid, and then the local cache enters the Modified state. In the case of a Read miss, the data can be read from the Owned cache and enter the Shared state without writing to memory. The advantage of this over MESI is that it reduces the number of writes back to memory.</p>
<p>The AMD64 documentation uses the MOESI protocol, and the AMBA ACE protocol is actually the MOESI protocol, but with a few name changes to indicate compatibility with one of the MEI/MESI/MOESI protocols.</p>
<ol>
<li>UniqueDirty: Modified</li>
<li>SharedDirty: Owned</li>
<li>UniqueClean: Exclusive</li>
<li>SharedClean: Shared</li>
<li>Invalid: Invalid</li>
</ol>
<p>Note that SharedClean does not mean that its data is consistent with memory, for example, with the SharedDirty cache, it just means that when the cache is replaced, it does not need to be written back to memory.</p>
<h2 id="dragon-protocol">Dragon Protocol</h2>
<p>The Dragon protocol is an update based protocol, meaning that when a cache is written, the updated data is synchronized to the other cores that own this cache line. It defines four states.</p>
<ol>
<li>Exclusive clean(E): exclusive, and data is consistent with memory</li>
<li>Shared clean(Sc): data exists in multiple caches at the same time, and it is not the last to write to the cache data</li>
<li>Shared modified(Sm): data exists in multiple caches at the same time, and it is the last one to write data to the cache, similar to the owner state of the MOESI protocol.</li>
<li>Modify(M): exclusive, and the data is not consistent with the memory</li>
</ol>
<p>As you can see, both E and M are exclusive, and if there are multiple caches with the same cache line, there are several Sc and one Sm.</p>
<p>When a Read miss occurs, it checks on the bus if any cache already has the data of this cache line, if not, it reads from memory and moves to the Exclusive clean state; if it is already in another cache, it reads from the other cache, moves the other cache to the Shared clean/Shared modified state, and then the cache then the cache is moved to Shared clean state.</p>
<p>When a Write miss occurs, the state of the other cache is also checked, and if it is the first one accessed, it is read from memory, updated, and moved to the Modify state; if it is not the first one accessed, it goes to the Shared modified state, and the original Shared modified cache goes to the Shared clean state.</p>
<p>When a Write hit occurs, if the state is Shared modified, you need to notify the other caches to update the data; if the state is Shared clean, you need to notify the other caches to update the data and let the original Shared modified cache enter the Shared clean state at the same time; if the state is If the status is Shared clean, then the cache that was Shared modified will enter the Shared clean state.</p>
<p>Here, the Shared modified cache is responsible for writing the data to memory when swapping out.</p>
<h2 id="ace-protocol">ACE protocol</h2>
<p>The ACE protocol adds three channels to the AXI:</p>
<ol>
<li>AC: Coherent address channel, Input to master: ACADDR, ACSNOOP, ACPROT</li>
<li>CR: Coherent response channel, Output from master: CRRESP</li>
<li>CD: Coherent data channel, Output from master: CDDATA, CDLAST</li>
</ol>
<p>In addition, the following signals have been added to the existing channels:</p>
<ol>
<li>ARSNOOP[3:0]/ARBAR[1:0]/ARDOMAIN[1:0]</li>
<li>awsnoop[3:0]/awbar[1:0]/awdomain[1:0]/awunique</li>
<li>rresp[3:2]</li>
<li>RACK/WACK</li>
</ol>
<p>ACE-lite only adds a new signal to an existing channel, not a new channel, so it cannot have a Cache internally, but it can access consistent cache contents.</p>
<p>When a read miss occurs, first the AXI master sends a read transaction to Interconnect, which sends an AC request to the cache where the cache line is stored, and if another master provides data, it returns the data to the requesting master; if no other If no other master provides data, the read request is made to memory and the result is returned to the master, and finally the master provides the RACK signal.</p>
<p>When a Write miss occurs, similarly, the AXI master sends a MakeUnique request to Interconnect, which sends a request to the cache where the cache line is stored, asking the other masters to change their status to Invalid; when all masters have invalidated has been invalidated, the result is returned to the original AXI master.</p>
<h2 id="directory-based-cache-consistency">Directory-based cache consistency</h2>
<p>The cache coherence protocol above often has this operation: send/receive messages to all caches that have this cache line. The simple way is to broadcast it directly, and then the receiver side determines for itself whether to process it or not. But this method causes too much broadcast traffic when there are a lot of cores, so you need to save the information about which caches will have this cache first, and then send it peer-to-peer for those caches. This will save some network traffic.</p>
<p>So, how to record this information? A simple solution (Full bit vector format) is to have a global table that records a bit vector of size N (N is the number of cores) for each cache line, with 1 indicating that the corresponding core has the cache line. However, this approach is too large: the number of cache lines is proportional to N, which is multiplied by N again, for a total capacity of O(N^2).</p>
<p>A slightly better approach (Coarse bit vector format) is to group the cores, say by NUMA nodes, where each cache line holds a bit vector of size M (M is the number of NUMAs), and as long as the cache line is present in that NUMA node, the corresponding bit is taken as 1. This is equivalent to sacrificing some traffic ï¼ˆThis is equivalent to saving some directory storage space at the expense of some traffic (broadcast within the NUMA node).</p>
<p>In practice, however, a cache line is usually only kept in a small number of cores, so there is a lot of room for optimization here. For example, one can set an upper limit on the number of simultaneous cache lines (Limited pointer format) and save the subscripts of the cores instead of the bit vectors, so that the storage space is O(Nlog2N). However, this limits the number of simultaneous occurrences of cache lines, and if the limit is exceeded, the existing cache needs to be replaced, which may degrade performance in some scenarios.</p>
<p>There is another way, which is the chained directory format. The directory saves the core number of the last accessed core, and then the cache of each core holds the number of the next core that holds this cache line, or indicates that the chain is terminated. The storage space is also O(Nlog2N), but the delay in sending messages is longer because they have to be traversed serially instead of being sent simultaneously. Similarly, a number-balanced binary tree format can be used: each cache holds two pointers to the left and right subtrees, which are then traversed separately, again with the goal of speeding up the traversal and allowing messages to be sent to multiple cores simultaneously.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/cache/">cache</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-04/k8s-networks/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Researching how k8s networks work</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-04/rust-io-uring/">
            <span class="next-text nav-default">Implementing io_uring based asynchronous random file reading in Rust</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
