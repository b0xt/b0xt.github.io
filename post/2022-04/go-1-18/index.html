<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>A few notable changes in Go 1.18 - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Learn about some of the new changes in Go 1.18, including generics, compilers, module, the new net/netip package, and security improvements and more." /><meta name="keywords" content="golang, generics, net/netip, Mutex.TryLock, fuzzing" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/go-1-18/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="A few notable changes in Go 1.18" />
<meta property="og:description" content="Learn about some of the new changes in Go 1.18, including generics, compilers, module, the new net/netip package, and security improvements and more." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/go-1-18/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-22T16:08:08+08:00" />
<meta property="article:modified_time" content="2022-04-22T16:08:08+08:00" />

<meta itemprop="name" content="A few notable changes in Go 1.18">
<meta itemprop="description" content="Learn about some of the new changes in Go 1.18, including generics, compilers, module, the new net/netip package, and security improvements and more."><meta itemprop="datePublished" content="2022-04-22T16:08:08+08:00" />
<meta itemprop="dateModified" content="2022-04-22T16:08:08+08:00" />
<meta itemprop="wordCount" content="5407">
<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="A few notable changes in Go 1.18"/>
<meta name="twitter:description" content="Learn about some of the new changes in Go 1.18, including generics, compilers, module, the new net/netip package, and security improvements and more."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">A few notable changes in Go 1.18</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-22 16:08:08 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 5407 words </span>
          <span class="more-meta"> 11 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-go-syntax-changes">1. Go syntax changes</a>
          <ul>
            <li><a href="#1-generics-the-most-complex-go-syntax-feature-ever">1. Generics: the most complex Go syntax feature ever</a></li>
            <li><a href="#2-the-main-syntax-points-of-generics">2. The main syntax points of generics</a></li>
          </ul>
        </li>
        <li><a href="#2-go-compiler-and-go-module-changes">2. Go compiler and Go module changes</a>
          <ul>
            <li><a href="#1-fixed-syntax-bugs">1. Fixed syntax bugs</a></li>
            <li><a href="#2-introducing-architectural-level-on-amd64-platform">2. Introducing architectural level on AMD64 platform</a></li>
            <li><a href="#3-enriched-sbom-information">3. Enriched SBOM information</a></li>
            <li><a href="#4-the-negative-impact-of-go-generics-on-the-compiler">4. The negative impact of Go generics on the compiler</a></li>
            <li><a href="#5-go-module-changes">5. go module changes</a></li>
            <li><a href="#6-introduction-of-go-workspace-workspace">6. Introduction of Go workspace (workspace)</a></li>
          </ul>
        </li>
        <li><a href="#3-go-toolchain-changes">3. Go toolchain changes</a>
          <ul>
            <li><a href="#1-go-fuzzing">1. go fuzzing</a></li>
            <li><a href="#2-go-get">2. go get</a></li>
          </ul>
        </li>
        <li><a href="#4-other-minor-changes">4. Other minor changes</a>
          <ul>
            <li><a href="#1-gofmt-supports-concurrency">1. gofmt supports concurrency</a></li>
            <li><a href="#2-the-built-in-function-append-changes-the-expansion-algorithm-for-slices">2. The built-in function append changes the expansion algorithm for slices</a></li>
            <li><a href="#3-new-netnetip-package">3. New net/netip package</a></li>
            <li><a href="#4-two-important-security-changes">4. Two important security changes</a></li>
            <li><a href="#5-strings-package-and-bytes-package-added-cut-function">5. strings package and bytes package added Cut function</a></li>
            <li><a href="#6-runtimepprof-accuracy-improvement">6. runtime/pprof accuracy improvement</a></li>
            <li><a href="#7-sync-package-adds-mutextrylock-rwmutextrylock-and-rwmutextryrlock">7. sync package adds Mutex.TryLock, RWMutex.TryLock and RWMutex.TryRLock</a></li>
          </ul>
        </li>
        <li><a href="#5-summary">5. Summary</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/22/5ed8e70f915044958a77b31158fc2150.png" alt="golang"></p>
<p>On March 15, 2022, the Go team officially announced the release of Go 1.18 on the official blog. The addition of generics makes Go 1.18 another milestone release after Go 1.0 (the first official release), Go 1.5 (implementation of bootstrap, de-C code, new version of GC), and Go 1.11 (introduction of Go module) versions.</p>
<p>Generics are the <strong>biggest syntax feature change</strong> in the Go language since it was open-sourced, and the changes and impact have been so great that the Go core team has delayed the official release of Go 1.18 by a month despite their efforts. But the good news is that Go 1.18 with the addition of the generic syntax continues to maintain <a href="https://go.dev/doc/go1compat">Go1 compatibility</a>, which in itself is a victory for the Go team and equally a blessing for the Go community.</p>
<p>Compared to previous versions, Go 1.18 has been changed a lot and <a href="https://github.com/golang/go/milestone/254">slightly more bugs</a>. The good thing is that a month after the release, all kinds of noise have returned to quiet. At the time of writing, <a href="https://groups.google.com/g/golang-announce/c/oecdBNLOml8">Go 1.18.1 has been released</a>, fixing many issues, including of course some issues related to Go generics.</p>
<p>Let&rsquo;s take a look at the noteworthy changes in <strong>Go 1.18</strong> , the version I&rsquo;m using here is Go 1.18.1.</p>
<p>We&rsquo;ll start with generics.</p>
<h2 id="1-go-syntax-changes">1. Go syntax changes</h2>
<h3 id="1-generics-the-most-complex-go-syntax-feature-ever">1. Generics: the most complex Go syntax feature ever</h3>
<p>In previous major Go releases, the Go syntax changes column was always sparse, or even passed over because there were no changes.</p>
<p>What&rsquo;s more, from Go 1.0 to Go 1.17, there were only a few syntax changes.</p>
<ul>
<li>Go version 1.1: add &ldquo;method value&rdquo; syntax.</li>
<li>Go 1.2: Full slice expression added: a[low: high: max].</li>
<li>Go 1.4: new for-range syntax of the form for range x {&hellip;}.</li>
<li>Go version 1.5: support for omitting the type of the key in a literal of type map (literal).</li>
<li>Go version 1.9: new syntax for type alias.</li>
<li>Go 1.13: add binary numeric literals starting with 0b or 0B, octal numeric literals starting with &ldquo;0o&rdquo; or &ldquo;0O&rdquo;, hexadecimal floating-point literals starting with 0x or 0X, as well as support for the use of numeric separators in numeric literals with the number separator &ldquo;_&rdquo; to improve readability.</li>
<li>Go version 1.17: support for conversion from slices to array pointers.</li>
</ul>
<p>As we have seen, Go has had only a few of the above changes at the pure syntax level in a decade. The complexity of the generics introduced in Go 1.18 is more than the sum of the syntax changes in the above versions. Even Gopher, with years of experience in Go programming, feels like a &ldquo;second learning curve&rdquo; when faced with the new generic features. This is because Go generics are the most complex and difficult to read and understand syntax feature since the birth of Go. Of course, the complexity of generics is not only effective for Go, but also for other programming languages that have generic syntax features.</p>
<p>Also because of the complexity of generics, the Go team reserves the right in <a href="https://go.dev/doc/go1.18">the release notes for Go 1.18</a> to introduce breaks to programs compiled in Go 1.18 in future releases as a result of fixing Go generic bugs. The Go team is of course committed to minimizing any such breakage, but cannot guarantee that such breakage will be zero.</p>
<p>Also, the Go 1.18 implementation of generics is not a full version and has many usage constraints. It is likely that these constraints will be phased out in subsequent versions of Go. And the implementation in Go 1.18 is consistent with the <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">design document for Type Parameter Proposal</a> has some differences, and Go officially recommends that the <a href="https://go.dev/ref/spec">specification for the Go language</a> prevails.</p>
<h3 id="2-the-main-syntax-points-of-generics">2. The main syntax points of generics</h3>
<p>The last version of the Go generic technical proposal is dozens of pages long, and if we were to go into the details of it, it could be a booklet of its own. In this overview article, I will only briefly explain the main syntax points of Go generics. In future articles, we will dive into the syntactic details of generics and do a detailed analysis one by one.</p>
<p>The main syntax points of Go generics are actually mentioned in the official Go blog <a href="https://go.dev/blog/intro-generics">&ldquo;Introduction to Go Generics&rdquo;</a>.</p>
<p>Generics add three new and important elements to the Go language.</p>
<ul>
<li>New support for <strong>type parameters</strong> in functions and types.</li>
<li>Define interface types as collections of types, including interface types without methods.</li>
<li>Type derivation is supported, and in most cases, type arguments can be omitted when calling generic functions.</li>
</ul>
<p>Let&rsquo;s take a look at each of them.</p>
<h4 id="type-parameter">type parameter</h4>
<p>A type parameter is an (unqualified) type name declared in the receiver section of a function declaration, method declaration, or in the type parameter list of a type definition. The type parameter acts as a placeholder for an unknown type in the declaration, and is replaced by a type argument when a generic function or generic type is instantiated.</p>
<p>To give you a better understanding of how a type argument is declared and what it does, let&rsquo;s compare the arguments of a normal function with the type argument of a generic function, using a function as an example.</p>
<p>We know that the list of arguments of a normal function looks like this.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">aType</span><span class="p">,</span> <span class="nx">z</span> <span class="nx">anotherType</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here, x, y, z are the names of the formal parameters (parameters), that is, variables, and aType, anotherType are the types of the formal parameters, that is, types.</p>
<p>Let&rsquo;s look at the list of type parameters of generic functions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">GenericFoo</span><span class="p">[</span><span class="nx">P</span> <span class="nx">aConstraint</span><span class="p">,</span> <span class="nx">Q</span> <span class="nx">anotherConstraint</span><span class="p">](</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span> <span class="nx">P</span><span class="p">,</span> <span class="nx">z</span> <span class="nx">Q</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here, P, Q are the names of type formal parameters, that is, types. aConstraint, anotherConstraint represent constraints on type parameters (constraint), which we can understand as a qualification of optional values of type parameters.</p>
<p>The constraint is what modifies the type parameter in the type parameter list. So what is a constraint? Let&rsquo;s move on to the next section.</p>
<h4 id="constraint">Constraint</h4>
<p>A constraint specifies the conditions that a type argument must satisfy. If a type satisfies all the conditions specified by a constraint, then it is a legal type argument for the type formal parameter modified by the constraint.</p>
<p>In Go generics, we <strong>use the interface type to define constraints</strong> . For this reason, the definition of Go interface types is also extended so that we can declare both a collection of methods for the interface and a list of types that can be used as type real parameters.</p>
<p>The following is an example of a constraint definition and usage.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">ype</span> <span class="nx">C1</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="err">~</span><span class="kt">int32</span>
</span></span><span class="line"><span class="cl">    <span class="nf">M1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="nf">M1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T1</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">T1</span><span class="p">)</span> <span class="nf">M1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">foo</span><span class="p">[</span><span class="nx">P</span> <span class="nx">C1</span><span class="p">](</span><span class="nx">t</span> <span class="nx">P</span><span class="p">)()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">t1</span> <span class="nx">T1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">foo</span><span class="p">(</span><span class="nx">t1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">t</span> <span class="nx">T</span>
</span></span><span class="line"><span class="cl">    <span class="nf">foo</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="c1">// 编译器报错：T does not implement C1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In this code, C1 is the constraint we defined, which declares a method M1, and two types (~int | ~int32) that can be used as type real parameters. We see that the multiple type real reference types in the type list are separated by &ldquo;|&rdquo;.</p>
<p>In this code, we also define two custom types T and T1, both of which implement the M1 method, but the underlying type of type T is struct{}, while the underlying type of type T1 is int. This leads to the fact that although type T satisfies the set of methods of constraint C1, type T does not satisfy constraint C1 because the underlying type is not int or int32, which also will cause the foo(t) call to report an error at the compile stage. However, I would also like to advise you that it is best to define interface types that do constraints separately from those that do traditional interfaces, unless the constraint type really needs both a collection of methods and a list of types.</p>
<p>To make this extension to interface types better understood, Go introduced type sets to explain it all.</p>
<h4 id="type-inference-and-type-specification">type inference and type specification</h4>
<p>The call to foo(t1) by the main function in the above example takes advantage of both type-instantiation and type-inference.</p>
<p>foo is a generic function with a type reference P bound by C1 in its function declaration, and the process of initializing P with the type reference T1 is type inference. As you may notice, instead of using: foo<a href="t1">T1</a>, we omit the explicit initialization of P and use foo(t1), which is a convenience of Go type derivation. Automatic type derivation allows for a more natural style of writing code that calls generic functions.</p>
<h4 id="generic-type">Generic type</h4>
<p>In addition to functions that can take type parameters and become &ldquo;generic functions&rdquo;, types can also have type parameters and become &ldquo;generic types&rdquo;, for example, the following code defines a vector generic type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Vector</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="p">[]</span><span class="nx">T</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>This is a type definition with type parameters, which are located after the type name, again enclosed in square brackets. The parameter names in the type parameter list (e.g. T) can be referenced in the type definition body. Type parameters also have their own constraints, such as any in the code above.</p>
<p>In Go 1.18, any is an alias for interface{}, which is also a predefined identifier, and using any as a constraint on a type parameter means that there are no constraints.</p>
<p>Here is another definition of a generic type.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Tree</span><span class="p">[</span><span class="nx">T</span> <span class="kd">interface</span><span class="p">{}]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="o">*</span><span class="nx">Tree</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span>       <span class="nx">T</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Tree</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">Lookup</span><span class="p">(</span><span class="nx">x</span> <span class="nx">T</span><span class="p">)</span> <span class="o">*</span><span class="nx">Tree</span><span class="p">[</span><span class="nx">T</span><span class="p">]</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">stringTree</span> <span class="nx">Tree</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>In the above example, the generic type Tree stores the value of the type parameter T. A generic type can also have methods, such as Lookup in this example. Generic types can also have methods, such as Lookup in this example. In order to use a generic type, it must be instantiated, e.g. Tree[string] is an example of instantiating Tree with the type real parameter string.</p>
<h4 id="shortcomings-of-current-generic-implementations">Shortcomings of current generic implementations</h4>
<p>Generics affect Go projects in every way, and it is indeed a bit difficult to implement all the features of generics in one release iteration cycle. As a result, the current implementation of Go generics in Go 1.18 is incomplete and has limitations, including the following according to the Go 1.18 release notes.</p>
<ul>
<li>
<p>The Go compiler cannot handle type declarations in generic functions or methods, and the Go team hopes to provide support for this feature in a future release.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">GenericsFoo</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">s</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">type</span> <span class="nx">bar</span> <span class="kt">int</span> <span class="c1">// type declarations inside generic functions are not currently supported
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">var</span> <span class="nx">a</span> <span class="nx">bar</span>
</span></span><span class="line"><span class="cl">    <span class="nb">println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The Go compiler does not support the predefined functions real, imag and complex for handling generic type real parameters. the Go team hopes to remove this restriction in a future release.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;golang.org/x/exp/constraints&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">GenericsFoo</span><span class="p">[</span><span class="nx">T</span> <span class="nx">constraints</span><span class="p">.</span><span class="nx">Complex</span><span class="p">](</span><span class="nx">s</span> <span class="nx">T</span><span class="p">)</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">n</span> <span class="o">:=</span> <span class="nb">real</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// s (variable of type T constrained by constraints.Complex) not supported as argument to real for go1.18 (see issue #50937
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nb">println</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">i</span> <span class="o">:=</span> <span class="nb">complex</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span> <span class="c1">// invalid argument: arguments have type T, expected floating-point
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">_</span> <span class="p">=</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">i</span> <span class="p">=</span> <span class="nb">complex</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span> <span class="c1">// 1+2i
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">GenericsFoo</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The Go compiler only supports calling method m on a valuex of argument type P, provided that: m is explicitly declared by P&rsquo;s constraint interface. Similarly, method valuex.m and method expression P.m are only supported if m is explicitly declared by P. Even if all types in the set of P types implement m, calling m on x is not supported if m is not declared explicitly. The Go team hopes to remove this restriction in a future release.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">C</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">T</span> <span class="p">|</span> <span class="nx">T1</span> <span class="c1">// T和T1都实现了M1方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">GenericsFoo</span><span class="p">[</span><span class="nx">P</span> <span class="nx">C</span><span class="p">](</span><span class="nx">p</span> <span class="nx">P</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span><span class="p">.</span><span class="nf">M1</span><span class="p">()</span> <span class="c1">// p.M1 undefined (type P has no field or method M1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="nf">M1</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">T1</span><span class="p">)</span> <span class="nf">M1</span><span class="p">()</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">GenericsFoo</span><span class="p">(</span><span class="nx">T</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The Go compiler currently does not support access to a structure field x.f where x is the type parameter type, even if all types in the type set of the type parameter have a field f. The Go team may remove this restriction in a future release.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">C</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">T</span> <span class="p">|</span> <span class="nx">T1</span> <span class="c1">// T和T1的类型定义中都包含名为Name的字段
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nx">GenericsFoo</span><span class="p">[</span><span class="nx">P</span> <span class="nx">C</span><span class="p">](</span><span class="nx">p</span> <span class="nx">P</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span> <span class="c1">// p.Name undefined (type P has no field or method Name)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">T1</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">GenericsFoo</span><span class="p">(</span><span class="nx">T</span><span class="p">{})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The Go compiler currently does not allow type parameters or pointers to type parameters to be embedded in fields as structure types (unnamed fields). Similarly, embedding a type parameter in an interface type is not allowed. The Go team is currently unsure if these restrictions will be relaxed in future versions.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">F</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">,</span> <span class="nx">P</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Name</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="nx">T</span> <span class="c1">//embedded field type cannot be a (pointer to a) type parameter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">P</span> <span class="c1">// embedded field type cannot be a (pointer to a) type parameter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyInterface</span> <span class="kd">interface</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">GenericsInterface</span><span class="p">[</span><span class="nx">I</span> <span class="nx">MyInterface</span><span class="p">]</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">M1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">I</span> <span class="c1">// cannot embed a type parameter
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">f</span> <span class="nx">F</span><span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_</span> <span class="p">=</span> <span class="nx">f</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>The Go compiler does not support including an interface type with a non-empty set of methods in a union type definition that contains more than 1 type element. Whether this will be allowed in a future version, the Go team is currently unsure.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MyInterface</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">M1</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">GenericsInterface</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">~</span><span class="kt">int</span> <span class="p">|</span> <span class="nx">MyInterface</span> <span class="p">|</span> <span class="kt">float64</span> <span class="c1">// cannot use main.MyInterface in union (main.MyInterface contains methods)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>Another widespread concern is that type parameters are not supported in method declarations of ordinary types.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">F</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">F</span><span class="p">)</span> <span class="nx">M1</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">](</span><span class="nx">t</span> <span class="nx">T</span><span class="p">){}</span> <span class="c1">// syntax error: method must have no type parameters
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">f</span> <span class="nx">F</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">.</span><span class="nf">M1</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>However, this is not an implementation-level restriction, but rather the draft Go generalization technology is set up that way. It is uncertain whether the use of type parameters in methods will be supported in the future. However, the above problem can be &ldquo;mitigated&rdquo; by using generic types with type parameters.</p>
<p>A generic type can have its own method, and use the same type parameter as the type declaration in the receiver of the generic type&rsquo;s method declaration, which can also be used in the method&rsquo;s normal parameter list, as in the following example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">F</span><span class="p">[</span><span class="nx">T</span> <span class="nx">any</span><span class="p">]</span> <span class="kd">struct</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">F</span><span class="p">[</span><span class="nx">T</span><span class="p">])</span> <span class="nf">M1</span><span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{}</span> <span class="c1">// ok
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">f</span> <span class="nx">F</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="nx">f</span><span class="p">.</span><span class="nf">M1</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="officially-maintained-generics-package">Officially Maintained Generics Package</h5>
<p>Go 1.18 provides a minimal version of Go generics, with a syntax and two predefined types: comparable and any. The constraints, slices, and maps generics package that was originally intended to be added to the standard library was put on hold due to a <a href="https://github.com/golang/go/issues/48918">comment from Go&rsquo;s old father</a>, Rob Pike. Pike&rsquo;s reasoning is simple: Go generics are the biggest language change since the birth of Go, and Go version 1.18 carries too many changes that are error-prone. And the Go core development team also had no experience with the new generics. He suggested that the Go core development team should wait, observe and learn more, and not take too big a step, and that Go should move steadily at its own pace.</p>
<p>So the three packages mentioned earlier were placed under golang.org/x/exp.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">golang</span><span class="p">.</span><span class="nx">org</span><span class="o">/</span><span class="nx">x</span><span class="o">/</span><span class="nx">exp</span><span class="o">/</span><span class="nx">constraints</span>
</span></span><span class="line"><span class="cl"><span class="nx">golang</span><span class="p">.</span><span class="nx">org</span><span class="o">/</span><span class="nx">x</span><span class="o">/</span><span class="nx">exp</span><span class="o">/</span><span class="nx">slices</span>
</span></span><span class="line"><span class="cl"><span class="nx">golang</span><span class="p">.</span><span class="nx">org</span><span class="o">/</span><span class="nx">x</span><span class="o">/</span><span class="nx">exp</span><span class="o">/</span><span class="nx">maps</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>When the time is right, these packages will go into the Go standard library like the http2 packages did back in the day.</p>
<h4 id="go-toolchain-support-for-generic-syntax">Go Toolchain Support for Generic Syntax</h4>
<p>After the Go generic came out, the tools on the Go toolchain maintained by Go officials all basically settled on a plan to support generic syntax. By the time Go 1.18 was released, gofmt/goimports, go vet, and gopls (supported since v0.8.1) had all implemented support for generics.</p>
<p>But here, except for gofmt which is released with the Go installer, all other tools need to be installed and upgraded to the latest version by themselves. Otherwise your editor will give you all kinds of errors once you use the generic syntax or the new predefined identifiers like any, comparable, etc.</p>
<p>If you are using vim+vim-go+goimports+gopls like me, then for the editor to support go 1.18, you can use the following command to upgrade the tool version to support go 1.18 generics.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="nv">$go</span> install golang.org/x/tools/cmd/goimports@latest
</span></span><span class="line"><span class="cl"><span class="nv">$go</span> install golang.org/x/tools/gopls@latest
</span></span></code></pre></td></tr></table>
</div>
</div><p>Of course there are many tools in the Go community that have not yet caught up with the pace in time, and this should give the Go community some time.</p>
<p>I will gradually explain the details and implementation principles of Go generic syntax in subsequent articles.</p>
<p>After talking about generics, let&rsquo;s take a look at the changes in the Go compiler and Go module.</p>
<h2 id="2-go-compiler-and-go-module-changes">2. Go compiler and Go module changes</h2>
<h3 id="1-fixed-syntax-bugs">1. Fixed syntax bugs</h3>
<p>We know that the Go compiler will report an error if a variable is not used after it is declared inside a Go function. But before Go 1.18, <a href="https://github.com/golang/go/issues/49214">the Go compiler would not report an error for the variable p in the example below</a>, even if it was not used in main.</p>
<p>Go 1.18 fixes this problem, and if you compile the example with Go 1.18, you will get the compiler error in the comment.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">p</span> <span class="o">:=</span> <span class="kc">true</span> <span class="c1">// go 1.18会报错：p declared but not used，但Go 1.18之前的版本不会。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="p">}()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Also, both gopls and go vet will give error messages for the above problem.</p>
<h3 id="2-introducing-architectural-level-on-amd64-platform">2. Introducing architectural level on AMD64 platform</h3>
<p>It is well known that the Go language has a lot of room for improvement in terms of target code optimization. In Go 1.18, Go introduced an optimization measure of sorts, namely <a href="https://github.com/golang/go/wiki/MinimumRequirements#amd64">the concept of architectural level on the AMD64 platform</a>. higher the level, the newer the available instructions, and the performance of the compiled code using the new instructions may be improved.</p>
<p>Go 1.18 uses the GOAMD64 environment variable to indicate the level used by the compiler, and by default uses version v1. This version uses all the instructions that are supported by x86-64 cpu&rsquo;s in the production code. To be clear, it uses the most basic instructions, which are compatible, but also have the worst performance.</p>
<p>The other three candidates for the GOAMD64 environment variable are v2, v3, and v4. The higher the version, the worse the compatibility, but the performance may be improved by using new instructions.</p>
<ul>
<li>GOAMD64=v2: all v1 commands, plus CMPXCHG16B, LAHF, SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3.</li>
<li>GOAMD64=v3: all v2 instructions, plus AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, OSXSAVE.</li>
<li>GOAMD64=v4: all v3 instructions, plus AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL.</li>
</ul>
<p>In the path of optimization, the Go team has been working hard, not that the Go compiler can now also inline functions with a range loop or a loop statement with a label.</p>
<h3 id="3-enriched-sbom-information">3. Enriched SBOM information</h3>
<p>Over the years, security issues about the software supply chain have been frequent, and the software supply chain has become a hot topic in the IT security field.</p>
<p>Go, as the head development language for cloud-native platforms, middleware and services, has become critical to its own security and the security of the software it builds. go is gradually increasing its investment in security, and the means are gradually increasing and enriching.</p>
<p>Go provides support for SBOM (Software Bill of Materials) as an important protection tool to mitigate software supply chain attacks in version 1.13, and in Go version 1.18, Go has enriched the SBOM information provided.</p>
<h3 id="4-the-negative-impact-of-go-generics-on-the-compiler">4. The negative impact of Go generics on the compiler</h3>
<p>The introduction of Go generics has increased the expressiveness of the Go language, but it has also had a significant negative impact on the Go compiler, the biggest of which is compilation speed. From the Go 1.18 release notes documentation, Go 1.18 compiles 15% faster than Go 1.17, and this performance drop is there even if you don&rsquo;t use the generic syntax in your code at all. So <a href="https://github.com/golang/go/issues/49569">this is something the Go team is going to focus on in Go 1.19</a>.</p>
<h3 id="5-go-module-changes">5. go module changes</h3>
<p>As of Go 1.16, the Go module has reached maturity. However, there are still some minor issues that need to be fixed, one of which is which command has the right to modify go.mod and go.sum. Go 1.18 clarifies that there are only three commands that can modify go.mod and go.sum: go get, go mod tidy and go mod download. This allows developers to execute the This allows developers to execute the other commands provided by the go toolchain in the project root.</p>
<h3 id="6-introduction-of-go-workspace-workspace">6. Introduction of Go workspace (workspace)</h3>
<p>The introduction of Go module has greatly improved Go package dependency and build problems. However, there are still two problems that make Go module a poor experience in collaborative software development, and these two problems are difficult to be solved fundamentally under the original go module mechanism. These two problems are as follows.</p>
<ul>
<li>making its own modifications to dependency packages and building based on locally modified dependency packages.</li>
<li>Rely on locally unpublished mods.</li>
</ul>
<p>The original go module replace mechanism was a poor experience in collaborative situations and put some additional mental burden on developers. So Go developer Michael Matloob proposed a <a href="https://github.com/golang/proposal/blob/master/design/45713-workspace.md">proposal called &ldquo;Multi-Module Workspaces in cmd/go&rdquo;</a> in April 2021. This proposal introduces a go.work file to enable the Go workspace mode. go.work sets some local paths with the use indicator, and the go modules under these paths form a workspace, <strong>Go commands can manipulate the go modules under these paths, and will preferentially use the go modules in the workspace module</strong> . At the same time, go.work is local environment related and does not need to be committed to the code repository, each developer can have his own go.work file only according to his own development environment.</p>
<p>After looking at the compiler, let&rsquo;s briefly talk about the rest of the tool chain.</p>
<h2 id="3-go-toolchain-changes">3. Go toolchain changes</h2>
<h3 id="1-go-fuzzing">1. go fuzzing</h3>
<p>The biggest change in the Go toolchain is the introduction of native support for fuzzing, also known as fuzz testing, or random testing. It is essentially an automated testing technique, or more specifically, an automated testing technique based on random input, and is often used to find bugs and problems in code that handles user input.</p>
<p>Instead of using a predefined data set as program input like unit testing, Fuzzing will construct some random data by the data construction engine itself or based on the initial data provided by the developer and provide it as input to our program, and then monitor the program for panic, assertion failure, infinite loop, etc. These constructed random data are called <strong>corpus</strong>. In addition Fuzz testing is not a one-time execution test, if there is no limit on the number of executions and execution time, Fuzz testing will keep on executing, so it is also a continuous testing technique.</p>
<p>Go 1.18 incorporates fuzz testing into the go test toolchain, making it an important member of the Go native testing toolchain along with unit testing and performance benchmarking.</p>
<p>The test cases for go fuzzing test are placed in xx_test.go like normal test cases (TestXxx) and performance benchmark tests (BenchmarkXxx), but the corresponding function name of the case is changed to FuzzXxx. A simple Fuzzing test example is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">FuzzXxx</span><span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">F</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 设置种子语料(可选)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 执行Fuzzing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">f</span><span class="p">.</span><span class="nf">Fuzz</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Here you need to pay extra attention to the fact that although Fuzzing tests are written very similar to unit tests and benchmark tests and are also very simple, Fuzzing tests are run continuously and do not stop, so as the Go 1.18 release notes suggest: Fuzzing tests consume a lot of memory and may affect your machine when running performance. Note also that at runtime, the fuzzing engine writes the expanded test range values to the fuzz cache directory in $GOCACHE/fuzz. There is currently no limit to the number of files or total bytes written to the fuzz cache, so it can take up a lot of storage space (possibly several GB or more). Therefore it is recommended to get a dedicated high end machine to run the fuzzing test.</p>
<h3 id="2-go-get">2. go get</h3>
<p>In go module build mode, go get returns to its job of fetching go modules and their corresponding dependencies, and no longer performs compilation and installation work. In this way, go install, which had been stripped of its halo by go get, regains its original function in module-aware mode: installing the specified or latest version of the module and executable.</p>
<p>Finally, let&rsquo;s look at some other small changes.</p>
<h2 id="4-other-minor-changes">4. Other minor changes</h2>
<h3 id="1-gofmt-supports-concurrency">1. gofmt supports concurrency</h3>
<p>&ldquo;The gofmt code style is not someone&rsquo;s favorite, it&rsquo;s everyone&rsquo;s favorite&rdquo;. gofmt code style has become a consensus among Go developers and is integrated into the development culture of the Go language. go 1.18 brings concurrency support to Go developers with gofmt, and without a doubt, its biggest The biggest benefit of gofmt is that it is fast, especially on multi-core cpus. gofmt can use more computing power to quickly format the code style.</p>
<h3 id="2-the-built-in-function-append-changes-the-expansion-algorithm-for-slices">2. The built-in function append changes the expansion algorithm for slices</h3>
<p>We all know that when append operates on slices, once the slice is full (len==cap), append will reallocate a larger underlying array and then copy the current slice elements into the new underlying array. Usually in the case of smaller size, append is expanded by 2x cap, and in the case of larger size, for example, it is already 1024, then Go 1.17 will not double allocation. the algorithm in Go 1.18 has some changes, the purpose is to make the changes around a threshold more silky smooth. Specific algorithm you see the following $GOROOT/src/runtime/slice.go in the growslice function in part of the logic.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">growslice</span><span class="p">(</span><span class="nx">et</span> <span class="o">*</span><span class="nx">_type</span><span class="p">,</span> <span class="nx">old</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">cap</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">slice</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">newcap</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span>
</span></span><span class="line"><span class="cl">    <span class="nx">doublecap</span> <span class="o">:=</span> <span class="nx">newcap</span> <span class="o">+</span> <span class="nx">newcap</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">cap</span> <span class="p">&gt;</span> <span class="nx">doublecap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">const</span> <span class="nx">threshold</span> <span class="p">=</span> <span class="mi">256</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nx">old</span><span class="p">.</span><span class="nx">cap</span> <span class="p">&lt;</span> <span class="nx">threshold</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">doublecap</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Check 0 &lt; newcap to detect overflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// and prevent an infinite loop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="mi">0</span> <span class="p">&lt;</span> <span class="nx">newcap</span> <span class="o">&amp;&amp;</span> <span class="nx">newcap</span> <span class="p">&lt;</span> <span class="nx">cap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// Transition from growing 2x for small slices
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// to growing 1.25x for large slices. This formula
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="c1">// gives a smooth-ish transition between the two.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="nx">newcap</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">newcap</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="nx">threshold</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Set newcap to the requested cap when
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// the newcap calculation overflowed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="nx">newcap</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="nx">newcap</span> <span class="p">=</span> <span class="nx">cap</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Also from the code, and Go 1.17 use 1024 as the size boundary different, Go 1.18 use 256 as the threshold. this we should pay attention to.</p>
<h3 id="3-new-netnetip-package">3. New net/netip package</h3>
<p>The Go 1.18 standard library adds a new netip package under net. This comes from the original Go core developer <a href="https://github.com/bradfitz">Brad Fitzpatrick</a> in his <a href="https://tailscale.com/blog/netaddr-new-ip-type-for-go/">startup project tailscale problems</a>. Brad found that the existing net.IP in the standard library, which represents IP-related information, was deficient in so many ways.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/22/d2d4711b550a49a6b1a01e0965e7686e.png" alt="Brad Fitzpatrick"></p>
<p>So Brad proposes to add a new <a href="(https://github.com/golang/go/issues/46518)">representation</a> of IP that takes up less memory, is immutable and comparable, and can be used as a map key, which is netip.Addr and a set of types and methods around netip.</p>
<p>There is a lot more to the netip package, so check out <a href="https://pkg.go.dev/net/netip">netip package ref</a> to learn more about this package.</p>
<h3 id="4-two-important-security-changes">4. Two important security changes</h3>
<p>Security is a growing concern, and the Go standard library is keeping pace with security trends.</p>
<p>In Go 1.18, the tls client will use TLS version 1.2 by default. Of course if you want to explicitly set Config.MinVersion to VersionTLS10, TLS 1.0 and 1.1 will still work.</p>
<p>In addition, the crypto/x509 package in Go 1.18 will by default reject certificates signed with SHA-1 hash functions (except for self-issued ones). SHA-1 can be temporarily supported via GODEBUG=x509sha1=1, but as of Go 1.19 SHA-1 will be permanently kicked out.</p>
<h3 id="5-strings-package-and-bytes-package-added-cut-function">5. strings package and bytes package added Cut function</h3>
<p>The strings and bytes packages both add the utility function Cut (note: the strings and bytes packages have a long tradition of API consistency). Take strings as an example, the semantics of the Cut function is to &ldquo;cut&rdquo; a certain segment of the input string.</p>
<p>The prototype of the Cut function is as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Cut</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">sep</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">before</span><span class="p">,</span> <span class="nx">after</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">found</span> <span class="kt">bool</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>If the part to be cut off is not found, the final return value is false, before is the original string s, and after is &ldquo;&rdquo;.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="s">&#34;hello, golang&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">f</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Cut</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;java&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;before=%s, after=%s, found=%t\n&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// before=hello, golang, after=, found=false
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If the part to be cut off is found, the last return value is true, before is the string before the &ldquo;cut off part&rdquo;, after is the string after the &ldquo;cut off part&rdquo;.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">f</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Cut</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;lang&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;before=%s, after=%s, found=%t\n&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// before=hello, go, after=, found=true
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If there are multiple strings in the input string that match the part to be cut, the Cut function will only cut the first matching string.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">f</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Cut</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="s">&#34;o&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;before=%s, after=%s, found=%t\n&#34;</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="c1">// before=hell, after=, golang, found=true
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="6-runtimepprof-accuracy-improvement">6. runtime/pprof accuracy improvement</h3>
<p>Go 1.18 runtime/pprof uses a per-thread timer to drive sampling on Linux, with the goal of improving the accuracy of sampled data under high load and reducing <a href="https://github.com/golang/go/issues/35057">cases of lost or inaccurate data</a>.</p>
<h3 id="7-sync-package-adds-mutextrylock-rwmutextrylock-and-rwmutextryrlock">7. sync package adds Mutex.TryLock, RWMutex.TryLock and RWMutex.TryRLock</h3>
<p>The Go team has added Mutex.TryLock, RWMutex.TryLock and RWMutex.TryRLock to the sync package despite strong requests from the community, but to be honest, I have not personally encountered a scenario where I have to use TryLock. <strong>Note that while proper uses of TryLock do exist, they are rare, and uses of TryLock are often a sign of a deeper problem with a mutex in a particular use</strong>.</p>
<p>Just try not to use it!</p>
<h2 id="5-summary">5. Summary</h2>
<p>From the above, Go 1.18 is a really big change. Go 1.18 introduces generics, so I personally recommend holding off on using it in production environments. Just like go module was introduced and matured through go 1.11~go 1.16, the maturity of Go generic must take at least 2-3 versions. At this stage, we should first focus on learning about generics and how to use them to improve our code, but we should also pay attention to the fact that they increase the complexity of the code dramatically, and the code using them is bound to have a decrease in readability, so don&rsquo;t abuse them, and don&rsquo;t obviously use them like the C++ template. That runs counter to the design philosophy of the Go language.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/golang/">golang</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-04/rust-ruby-yjit/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Replacing the C version, the Ruby YJIT compiler implemented in Rust is complete</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-04/go-efficient/">
            <span class="next-text nav-default">Golang&#39;s efficient development model</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
