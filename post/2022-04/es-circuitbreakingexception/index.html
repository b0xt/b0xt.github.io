<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>CircuitBreakingException error raised by adding a new node to Elasticsearch - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Resolve CircuitBreakingException exception raised by adding a new node to Elasticsearch." /><meta name="keywords" content="Elasticsearch, CircuitBreakingException" />






<meta name="generator" content="Hugo 0.96.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/es-circuitbreakingexception/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="CircuitBreakingException error raised by adding a new node to Elasticsearch" />
<meta property="og:description" content="Resolve CircuitBreakingException exception raised by adding a new node to Elasticsearch." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/es-circuitbreakingexception/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-12T12:59:56+08:00" />
<meta property="article:modified_time" content="2022-04-12T12:59:56+08:00" />

<meta itemprop="name" content="CircuitBreakingException error raised by adding a new node to Elasticsearch">
<meta itemprop="description" content="Resolve CircuitBreakingException exception raised by adding a new node to Elasticsearch."><meta itemprop="datePublished" content="2022-04-12T12:59:56+08:00" />
<meta itemprop="dateModified" content="2022-04-12T12:59:56+08:00" />
<meta itemprop="wordCount" content="1450">
<meta itemprop="keywords" content="Elasticsearch," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CircuitBreakingException error raised by adding a new node to Elasticsearch"/>
<meta name="twitter:description" content="Resolve CircuitBreakingException exception raised by adding a new node to Elasticsearch."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="/ukraine/">
        <li class="mobile-menu-item">UKRAINE</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/ukraine/">UKRAINE</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">CircuitBreakingException error raised by adding a new node to Elasticsearch</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-12 12:59:56 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 1450 words </span>
          <span class="more-meta"> 3 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#an-error-occurred">An error occurred</a></li>
            <li><a href="#cause-of-error">Cause of error</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>I decided to add a few nodes to our Elasticsearch (ES) cluster because of business needs, the current ES cluster version is 7.5.2, and the nodes to be added are moved from the previous ES cluster version 1.5.2. The current 7.5.2 cluster already has 6 data nodes, and my job this time is to add 5 new data nodes to it.</p>
<p>Since these 5 nodes are all data nodes from the previous 1.5.2 ES cluster and have been running stably in the previous cluster for years without any problems, I am very confident about their configuration. This careless attitude set the stage for the tragedy that followed. Since these nodes had no problems in the previous cluster, I added all 5 nodes to the ES7 cluster at once and made them data nodes.</p>
<h3 id="an-error-occurred">An error occurred</h3>
<p>After the nodes were added, the ES cluster started to rebalance the slices, the whole cluster started to perform the relocation and replication operations of the slices, and it seemed that our work would soon be done. Soon this calm was shattered by the ringing of a cell phone text message alerting the business that it had suddenly started to experience a large number of read and write failure errors! At the same time, the alert group of enterprise WeChat also started to alert a large number of alerts, and the alert messages were all <code>CircuitBreakingException</code> type exceptions, and the specific error messages I excerpted partly as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">[parent] Data too large, data for [&lt;transport_request&gt;] would be [15634611356/14.5gb], which is larger than the limit of [15300820992/14.2gb], real usage: [15634605168/14.5gb], new bytes reserved: [6188/6kb], usages [request=0/0b, fielddata=0/0b, in_flight_requests=6188/6kb, accounting=18747688/17.8mb]
</span></span></code></pre></td></tr></table>
</div>
</div><p>In fact, the reason for the error is very simple: the current memory has triggered a circuit breaker at the parent level, which makes it impossible to continue the transport_request. Because if the transport_request continues, it may cause ES to generate an OutOfMemory error. ES will set some <a href="https://www.elastic.co/guide/en/elasticsearch/">circuit breaker (circuit breaker)</a> to avoid OOM. reference/7.5/circuit-breaker.html), the role of these circuit breakers is to actively reject the next operation when there is not enough memory, instead of allocating further memory to eventually generate OutOfMemoryError, the role of circuit breakers is to protect the entire process from going down.</p>
<p>We already know that the reason for the error is that the Java process is running out of heap memory, but what exactly is causing the memory to run out? At the moment I am not thinking about these issues, the 5 new nodes are frequently reporting insufficient memory, which is causing a lot of online read and write failures, and my primary goal is to solve these errors. This is the ambush I mentioned before, because I added all 5 nodes to the cluster at once, so at this time, the main slice and all replica slice of an index slice may be distributed on these newly added nodes, so I can&rsquo;t stop all these nodes at once, because this will lead to complete data loss of these slice and thus make the whole cluster turn red.</p>
<p>In fact, I did this because I was nervous about too many alarms, i.e. I stopped several nodes and the cluster status immediately turned red. The good thing is that these slices still existed on the disks of the stopped nodes, and after the cluster turned red, I rushed to get these nodes up again, and the cluster was out of the red state again. After that, I could only wait for the replication of the slices while enduring the alarms, and I could only stop the node after confirming that there was no unique slice of data on a node.</p>
<p>Anyway, I had to endure the alarms while stopping the nodes, and after some time, I finally stopped all 5 nodes, and the read/write alarms caused by insufficient memory finally stopped. The problem is that there are some unassigned slices in the cluster, i.e. these slices are not allocated successfully. We use the following command to find all the unassigned shards and explain why they were not allocated.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">GET /_cluster/allocation/explain
</span></span></code></pre></td></tr></table>
</div>
</div><p>The reason for the error is as follows/.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">shard has exceeded the maximum number of retries
</span></span></code></pre></td></tr></table>
</div>
</div><p>This means that a previous memory error caused the allocation of these slices to fail, and the maximum number of retries was reached after multiple failures, at which point ES aborts the allocation of these slices. In this case, we just need to execute the following command to manually start reallocating the slices.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">POST /_cluster/reroute?retry_failed=true
</span></span></code></pre></td></tr></table>
</div>
</div><p>The cluster will then start allocating these unallocated slices, and after waiting for some time for the slices to be allocated and replicated, the whole cluster is finally back to green again.</p>
<h3 id="cause-of-error">Cause of error</h3>
<p>The first thing we thought was that the memory was not recovered in time because of the GC problem, and there was not enough memory left to cause the error. We observed the GC logs of the G1 garbage collector, and the logs of G1 are roughly divided into three parts as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl"># 正常的YoungGC
</span></span><span class="line"><span class="cl">Pause Young (Normal) (G1 Evacuation Pause)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 伴随着YoungGC会有多次标记操作
</span></span><span class="line"><span class="cl">Pause Young (Concurrent Start) (G1 Humongous Allocation)
</span></span><span class="line"><span class="cl">Concurrent Cycle
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># MixedGC
</span></span><span class="line"><span class="cl">Pause Young (Prepare Mixed) (G1 Evacuation Pause)
</span></span><span class="line"><span class="cl">Pause Young (Mixed) (G1 Evacuation Pause)
</span></span></code></pre></td></tr></table>
</div>
</div><p>After observing the GC logs, we found that GCs are triggered only after the heap memory has reached a high occupancy rate, which is likely to lead to unrecovered memory and insufficient memory remaining. If we could make GCs happen earlier, we could reduce the probability of running out of memory (although this would reduce the throughput of the system by making GCs more frequent). By searching the ES source code in <a href="https://github.com/elastic/elasticsearch/pull/46169/commits/f4b587257ffd9c7f3d2eecc7096a100b72cb46d6">Pull requests</a> we found the following GC configuration we found the following GC configuration.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">-XX:G1ReservePercent=25
</span></span><span class="line"><span class="cl">-XX:InitiatingHeapOccupancyPercent=30
</span></span></code></pre></td></tr></table>
</div>
</div><p>The two parameters are explained in the <a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html">official documentation of the G1 garbage collector</a> as follows.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">-XX:G1ReservePercent=10
</span></span><span class="line"><span class="cl">Sets the percentage of reserve memory to keep free so as to reduce the risk of to-space overflows. The default is 10 percent. When you increase or decrease the percentage, make sure to adjust the total Java heap by the same amount. This setting is not available in Java HotSpot VM, build 23.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">-XX:InitiatingHeapOccupancyPercent=45
</span></span><span class="line"><span class="cl">Sets the Java heap occupancy threshold that triggers a marking cycle. The default occupancy is 45 percent of the entire Java heap.
</span></span></code></pre></td></tr></table>
</div>
</div><p>In short <code>-XX:G1ReservePercent</code> is the percentage of memory space reserved to avoid out-of-memory errors, the default value is 10, we raised it to 25. <code>-XX:InitiatingHeapOccupancyPercent</code> is the percentage of memory usage threshold to trigger a marking cycle, the default value is 45, we reduced it to 30. By modifying these two VM parameters, the VM will be able to GC earlier, which will greatly reduce the probability of out-of-memory errors.</p>
<p>After modifying the parameters, we restart the nodes, this time one by one, and wait for a few hours after starting one to make sure there is no problem before starting the next one. In addition, we set the <code>cluster.routing.allocation.enable</code> parameter to <code>none</code> before adding a new node, and then set it to <code>all</code> after the node is confirmed to be started, so that we can manually control the start and stop of slice allocation. After changing the parameter, the node does not have frequent out-of-memory errors anymore, so it can be seen that changing the configuration to advance the GC time does reduce the out-of-memory problem caused by too slow GC. Although there is no pressure on the node memory in general, there is another problem, that is, there is still a chance to trigger the node out of memory error when relocating the slice after joining the node, so we just need to slow down the slice relocation.</p>
<p>We change the value of <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/shards-allocation.html">cluster.routing.allocation.node_concurrent_recoveries</a> from the default value of 2 to 1, which reduces the number of relocated slices on a node at the same time. In addition, we set <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/recovery.html#_peer_recovery_settings">indices.recovery.max_bytes_per_sec</a> to reduce the slice relocation speed from 40mb/s to 20mb/s per node, which also reduces the memory pressure on the node during slice relocation. After changing these configurations, the node has never had an out-of-memory error again.</p>
<p>In fact, we can summarize the reasons for the problem as follows</p>
<ol>
<li>gc speed is too slow.</li>
<li>too fast memory growth</li>
</ol>
<p>The solutions are as follows.</p>
<ol>
<li>reduce the GC trigger threshold and increase the GC frequency.</li>
<li>reduce the speed of data synchronization, reduce the speed of memory increase.</li>
</ol>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/elasticsearch/">Elasticsearch</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-04/entgo/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Replace gorm with entgo</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-04/unable-to-allocate-memory/">
            <span class="next-text nav-default">Why do I get the error &#34;Unable to allocate memory&#34; when there is still plenty of memory?</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.64437849d125a2d603b3e71d6de5225d641a32d17168a58106e0b61852079683.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
