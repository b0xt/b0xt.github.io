<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>TUN Mode - SoByte</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6356451834813761" crossorigin="anonymous"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-E8GRRGBTEZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E8GRRGBTEZ');
</script>


<meta name="author" content="" /><meta name="description" content="Discover how to use TUN mode." /><meta name="keywords" content="Tun" />






<meta name="generator" content="Hugo 0.102.0 with theme even" />


<link rel="canonical" href="https://www.sobyte.net/post/2022-04/tun-mode/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="TUN Mode" />
<meta property="og:description" content="Discover how to use TUN mode." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.sobyte.net/post/2022-04/tun-mode/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-04-08T13:16:14+08:00" />
<meta property="article:modified_time" content="2022-04-08T13:16:14+08:00" />

<meta itemprop="name" content="TUN Mode">
<meta itemprop="description" content="Discover how to use TUN mode."><meta itemprop="datePublished" content="2022-04-08T13:16:14+08:00" />
<meta itemprop="dateModified" content="2022-04-08T13:16:14+08:00" />
<meta itemprop="wordCount" content="3172">
<meta itemprop="keywords" content="tun," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="TUN Mode"/>
<meta name="twitter:description" content="Discover how to use TUN mode."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">SOBYTE</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">SOBYTE</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">TUN Mode</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-04-08 13:16:14 </span>
        <div class="post-category">
            <a href="/categories/tutorials/"> tutorials </a>
            </div>
          <span class="more-meta"> 3172 words </span>
          <span class="more-meta"> 15 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#user-state-network-stack">User State Network Stack</a>
          <ul>
            <li><a href="#network-stack-implementation">Network stack implementation</a></li>
            <li><a href="#usage-flow">Usage flow</a></li>
          </ul>
        </li>
        <li><a href="#os-network-stack">OS network stack</a>
          <ul>
            <li><a href="#workflow">Workflow</a></li>
            <li><a href="#nat-policies">NAT Policies</a></li>
          </ul>
        </li>
        <li><a href="#prevent-loops">Prevent Loops</a>
          <ul>
            <li><a href="#fake-ip">Fake IP</a></li>
            <li><a href="#policy-routing">Policy Routing</a></li>
          </ul>
        </li>
        <li><a href="#some-other-knowledge">Some other knowledge</a>
          <ul>
            <li><a href="#difference-between-tun-and-tap">Difference between TUN and TAP</a></li>
            <li><a href="#ip-and-other-configurations">IP and other configurations</a></li>
            <li><a href="#difference-between-physical-nic-and-virtual-nic">Difference between physical NIC and virtual NIC</a></li>
            <li><a href="#how-to-create-a-tun-device">How to create a TUN device</a></li>
            <li><a href="#relationship-to-bpf">Relationship to BPF</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p><strong>TUN</strong> is a Layer 3 virtual network device provided by the kernel and implemented by software to replace the real hardware. It is equivalent to opening a port at the Layer 3 (network layer) location of the system network stack and handing over the eligible (route matching) Layer 3 packets to the corresponding user space software for processing, and the user space software can also inject packets into the system network stack through the TUN device. It can be said that the TUN device is a channel between the user space software and the system network stack.</p>
<blockquote>
<p><strong>TAP</strong> is a Layer 2 (Ethernet) virtual network device that handles Ethernet frames, and more information is available at a lower level, but is out of the scope of this article.</p>
</blockquote>
<p>If we want to do something with TUN, we actually have to write a user-state program that gets a TUN device handle, writes serialized IP packets to it, reads the data from it and reduces it to IP packets for processing, and if necessary, needs to remove its payload to continue parsing it into the appropriate transport layer protocol.</p>
<p>It is VPN and proxy programs that typically use TUN technology, however, these two types of programs typically have different behaviors when dealing with IP packets passed in TUNs.</p>
<ul>
<li><strong>VPN</strong> typically does <strong>network layer</strong> encapsulation: the IP packet is obtained, encrypted and encapsulated, and then transmitted over some connection to another network, to which it is sent after being decapsulated and decrypted. In this process, the modifications to the IP packet itself are very small and do not involve changes to the overall structure, usually only the source and destination IPs are modified and NAT is done.</li>
<li>The <strong>proxy</strong> is usually a proxy for the <strong>transport layer</strong>: after getting the IP packet from the TUN device, it needs to continue to parse the payload, restore the TCP or UDP structure, and then encrypt and encapsulate the transport layer (TCP or UDP) payload. The network layer IP and transport layer port information is typically handled as metadata for that connection, using additional encryption and encapsulation.</li>
</ul>
<p>In short, VPNs do not need to parse IP packet payloads, while proxies need to parse out and process transport layer information, especially for complex protocols such as TCP, which requires great care and rigor. If we use TUN technology, there are usually two modes for proxy programs: implementing the network stack in the user state, or directly using the OS network stack.</p>
<h2 id="user-state-network-stack">User State Network Stack</h2>
<p>The first option is to implement the network stack in the user state, which is not a small project, especially the implementation of the TCP protocol, because its protocol is very complex, there are many details to pay attention to, so their own implementation is very easy to make mistakes. So we generally look for ready-made implementations to use, there are a lot of mature and efficient implementations, I believe it must be orders of magnitude better than what I wrote myself.</p>
<h3 id="network-stack-implementation">Network stack implementation</h3>
<ul>
<li>If you use <strong>C</strong> language, <a href="https://savannah.nongnu.org/projects/lwip/"><strong>lwIP</strong></a> is a very good choice, open source by the Swedish Institute of Computer Science Academy, it is a lightweight TCP/IP stack implementation that implements full TCP, is widely used in embedded devices, and stability is guaranteed. Also, lwIP has bindings for many other languages, including go and rust, which allows us to choose lwIP as a user-state network stack implementation when developing in other languages as well.</li>
<li>If one chooses to develop a user-state application for TUN using the <strong>Go</strong> language (which is actually the choice of most people), one can choose the implementation in Google&rsquo;s open source <a href="https://github.com/google/gvisor/tree/master/pkg/tcpip"><strong>gVisor</strong></a>. The purpose of the gVisor project is to provide its own application kernel for containers, where the tcpip implementation is backed by Google and quality is guaranteed.</li>
<li>If we choose to use <strong>Rust</strong> for development, our choice is a bit more difficult, there is no weathered, time-tested implementation, and after extensive comparison I recommend <a href="https://github.com/smoltcp-rs/smoltcp"><strong>smoltcp</strong></a>, which is a standalone, event-driven TCP/IP implementation for bare-metal real-time systems. This is a standalone, event-driven TCP/IP stack developed for bare-metal real-time systems, designed for simplicity and robustness, and should be trusted.</li>
<li>Of course, I think another implementation to look forward to is Google&rsquo;s <a href="https://cs.opensource.google/fuchsia/fuchsia/+/master:src/connectivity/network/netstack3/"><strong>Netstack3</strong></a> for the Fuchsia OS , previously implemented by Go, but now Google has re-implemented a new one in Rust, with Google&rsquo;s endorsement, so you can look forward to it.</li>
</ul>
<h3 id="usage-flow">Usage flow</h3>
<p>After looking at the available implementations, let&rsquo;s look at how the network stack is used in the user space implementation. Although each library has different programming interfaces and usage methods under different implementations, the basic idea is the same, so we will only discuss the basic usage flow here.</p>
<h4 id="basic-idea">Basic idea</h4>
<p>In principle, the user-state network stack is to continuously parse the payload data in the TCP stream from the IPv4 packets through protocol parsing; the transport layer payload is continuously encapsulated through the protocol to get the final IPv4 packets.</p>
<h5 id="read-out-from-tun">Read out from TUN</h5>
<p>A sequence of bytes read from the handle corresponding to the TUN device is the IP packet that needs to be processed, usually for the IPv4 protocol, but it still needs to be judged based on the first byte of the byte sequence first.</p>
<p>If it is determined to be an IPv4 packet, the whole byte sequence is thrown into the Packet Parser implementation of IPv4 and the IPv4 packet structure is restored. Based on the protocol field in IPv4 Header, determine which upper layer protocol the payload should use to parse. <a href="https://datatracker.ietf.org/doc/html/rfc791#page-11">rfc791</a></p>
<p>Generally, we only need to deal with ICMP, TCP and UDP protocols, take TCP as an example, we just need to throw the IPv4 payload into TCP&rsquo;s Parser to get the transport layer load we want. (In reality, it&rsquo;s not as simple as that)</p>
<h5 id="write-data-to-tun">Write data to TUN</h5>
<p>The write process is actually the reverse of the read process, where you get the payload of a transport layer protocol.</p>
<p>Next, we build the IPv4 Header and stitch the UDP packet into the IPv4 payload. Once you have the IPv4 packet, you can serialize it into a byte sequence and write it to the TUN handle.</p>
<h4 id="practical-use">Practical Use</h4>
<p>The above read and write process looks simple, but in practice there are many things to consider, including but not limited to fragmentation, packet loss, retransmission, traffic control, etc. TCP is an extremely complex transport layer protocol with many scenarios to consider, so obviously using the above basic idea is very cumbersome and difficult to use.</p>
<p>Many user-state network stacks certainly take this into account, and implementations provide a very friendly and straightforward interface that allows you to create a TCP/IP network stack instance directly and get two handles, one for reading and writing network layer IP packets, and the other for receiving and writing transport layer loads, with all the complex conversion relationships and special cases in between shielded internally.</p>
<h2 id="os-network-stack">OS network stack</h2>
<p>For our needs, we are actually converting between IPv4 and TCP payload, which is exactly what the OS network stack does. We can&rsquo;t simply use the OS network stack code directly, but we can find a way to reuse the functionality provided by the OS network stack. TUN has already opened a port at the network layer, but we need to open a port at the transport layer, so we can use the socket provided by the operating system.</p>
<p>We use the socket provided by the OS to create a transport layer Listener, modify the target IP and target port of an IPv4 packet to the IP and port we are listening to, and then inject the IPv4 packet into the OS network stack through the TUN, and the OS will automatically parse it accordingly and send the required transport layer payload to the Listener. The OS will automatically parse the packet accordingly and send the required transport layer payload to the Listener via the socket created earlier, thus completing the &ldquo;read out&rdquo; operation using the OS network stack.</p>
<p>For the &ldquo;write in&rdquo; operation, you only need to write to the transport layer connection handle you just created, and the OS network stack will also perform the corresponding packet sealing to form the IPv4 packet. Obviously, the reverse packet needs to be considered. When writing to the transport layer connection handle and the OS network stack seals the packet, the source IP and source port will be considered as the new target IP and target port, because we need to make the returned IPv4 packet available for capture by the TUN interface. The source IP should be restricted to an IP in the TUN segment.</p>
<h3 id="workflow">Workflow</h3>
<p>When utilizing the OS network stack, the following steps are usually followed, here is an example of TCP protocol.</p>
<p>In our example, the TUN network is configured with <code>198.10.0.1/16</code>, the host IP is <code>198.10.0.1</code>, the proxy client listens to <code>198.10.0.1:1313</code>, the app wants to access <code>google.com:80</code>, and the custom DNS service returns the Fake IP of <code>google.com</code> <code>198.10.2.2</code> .</p>
<ol>
<li>
<p>Proxy Creating TCP Socket Listener</p>
<p>The first step here is to open a port in the transport layer of the system network stack and create a TCP Socket Listener that listens to <code>198.10.0.1:1313</code>.</p>
</li>
<li>
<p>An App initiates a connection</p>
<p>When an app that needs a proxy initiates a connection to <code>google.com:80</code>, we return a Fake IP ( <code>198.10.2.2</code>) via a custom DNS service to route the traffic to the TUN device.</p>
<blockquote>
<p>Of course, you can also capture traffic without using the Fake IP method. You can also direct traffic to the TUN device by configuring routing rules or traffic redirection, but Fake IP is the most common method, so it is used as an example here.</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/f17b6023c4804765a40f8b6dd6414de1.png" alt="tun"></p>
</li>
<li>
<p>Parsing the IPv4 read by the TUN into TCP load data</p>
<p>After the TUN device captures the traffic, that is, IPv4 packets, and reads them out, it needs to use the system network stack to parse out the TCP load data.</p>
<p>In this step, the read IPv4 packet needs to be modified, that is, the source IP, source port, destination IP and destination port as we mentioned above, and the corresponding checksum also needs to be recalculated. The purpose of the modification is to make the IPv4 packets injected into the OS network stack via TUN to be correctly routed and return the innermost TCP payload to us via the TCP socket we are listening to at the beginning.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/e840a3495909453dbec47a7983dd0861.png" alt="tun"></p>
<p>Here, for convenience, the source IP and source port are set directly to the initial target IP and target port, and there are more setup policies, or NAT policies, for actual programming.</p>
</li>
<li>
<p>Proxy client requesting proxy server</p>
<p>At this point, the proxy client has already got the real TCP payload of the request, and can get the source IP and source port modified in step 3 by getting the peer information of the TCP connection, through which it can get the IP and port that the App really wants to access by checking the NAT table (or even get the domain name information by checking the DNS request record), so the proxy client can encrypt and encapsulate according to its own Therefore, the proxy client can encrypt and encapsulate the information according to its own protocol, and then send it to the proxy server, which will perform the real request operation.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/2827db3d2c5e432c940c8283b5763cda.png" alt="tun"></p>
</li>
<li>
<p>Packetize return data back to IPv4 and write to TUN</p>
<p>Through the communication between proxy client and proxy server, proxy server and Google, we get the real return data from Google, now we need to re-encapsulate the IPv4 packet, or use the system network stack: write the data to TCP socket ( <code>198.10.0.1:1313</code> ), then we can get the encapsulated IPv4 on the TUN side, it&rsquo;s that easy.</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/7d6b76b673fb4656a99b8dd9aa623fa5.png" alt="tun"></p>
</li>
<li>
<p>App gets the return data</p>
<p><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/08/692f994705404d7189bc241f221b1392.png" alt="tun"></p>
<p>The above process is how the IPv4 to TCP load data and its reverse direction transformation is done using the OS network stack. With this approach, it is possible to take full advantage of operating system implementations that are well-tested, reliable, and meet a variety of complex situations. However, there are drawbacks in that the data needs to be copied multiple times, increasing performance loss and latency.</p>
</li>
</ol>
<h3 id="nat-policies">NAT Policies</h3>
<blockquote>
<p>You can of course implement different NAT types to meet a variety of needs, but that is a more in-depth topic and not discussed in this article.</p>
</blockquote>
<p>In step 3 of the process, you should have noticed that there are restrictions on the source IP and source port modification. We need to restrict the IP to the TUN segment so that the returned packets can be recaptured by the TUN device. But this restriction is very loose, and in our example configuration of the TUN device segment, you have 2^16 IPs to choose from, and 2^16 ports to choose from for each IP.</p>
<p>But if you look closely, you will see that the above example does not take full advantage of these resources, we just use the Fake IP as the source IP, the real target port as the source port, and all the other ports of this IP are left unused. Also I have found in some programs written by others that they choose only one IP to set as the source IP and by reasonably assigning the port of that IP as the source port, in this case the rest of the IP resources in the TUN segment are wasted.</p>
<p>The above two NAT policies are fine for personal computers, but if the proxy client is running on a gateway and the number of IPs accessed in the network exceeds the maximum number of IPs in the segment, or the number of hash(ip:port) exceeds the total number of ports (2^16), it will be difficult to continue assigning NAT entries. Therefore, we should write a special NAT management component to allocate IP and port resources reasonably to maximize utilization.</p>
<h2 id="prevent-loops">Prevent Loops</h2>
<p>Facts aside, if we want to proxy all traffic, it is the intuitive and plain idea of directing all traffic to our TUN device via routing rules, as simple as the following command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">sudo route add -net 0.0.0.0/0 dev tun0
</span></span></code></pre></td></tr></table>
</div>
</div><p>If you do write that, you&rsquo;ll find that you can&rsquo;t get on the Internet. This is because there is a loop.</p>
<p>If you think about it a little bit, you will find that although we want to proxy all traffic, the traffic between the proxy client and the proxy server is something that needs to be skipped, and if you use the above route, it will cause the traffic from the proxy client to go through the route and then from the TUN back to the proxy client, which is a dead loop, and no traffic can go out. The traffic is only near and not out, spinning back and forth, your file open count explodes, the OS stops assigning you more handles, data is copied back and forth, your CPU fan spins hard, and your computer starts to get stuck.</p>
<p>This is something we don&rsquo;t want to see and need to take some measures to avoid loops. In practice there are quite a few ways to avoid this, for example by configuring routing rules in a reasonable way so that the traffic connecting to the proxy server can be matched to the external network interface without any problems. However, this method is not flexible enough, and if the proxy server IP changes, you need to change the routing rules in time, which is very troublesome, so we will introduce other methods.</p>
<h3 id="fake-ip">Fake IP</h3>
<p>Fake IP is the method we used in the above example, which is a way to restrict incoming traffic. The basic idea is to implement a DNS server that returns a fake IP address for user queries, and we can restrict the returned IP address to the network segment of the TUN device, so that the traffic initiated by the application is actually the traffic sent to the TUN network and is naturally routed to match, without routing the entire traffic as before, and the rest of the traffic, including requests initiated by proxy clients, will not be The rest of the traffic, including requests from proxy clients, will not be routed, ensuring that no loops are created.</p>
<p>When the proxy client needs to know the address that the application really wants to request, it can do a reverse lookup to the DNS server it implements through some interfaces.</p>
<h3 id="policy-routing">Policy Routing</h3>
<p>From the previous analysis, we can find that the loop is caused by the traffic from the proxy client itself being routed to the TUN device, so we can find a way to make the traffic from the proxy client itself go out of the real physical network interface instead of the TUN.</p>
<p>In a (Unix-like) system, the traffic from the proxy client can be marked with the fwmark firewall, and then the marked traffic can be routed through a separate routing table via policy routing, thus bypassing the global traffic capture.</p>
<h4 id="cgroup">cgroup</h4>
<p><code>cgroup</code> is a Linux kernel feature that can be used to restrict and isolate resources from processes, where the <code>net_cls</code> subsystem can restrict access to the network. At the network control level, <code>class ID</code> can be used to determine if traffic belongs to a certain cgroup, so traffic from a specific cgroup can be fwmarked so that it can be controlled by policy routing.</p>
<p>We can create a cgroup for bypassing proxies and use the default routing rules for traffic from processes under that cgroup, while traffic from the rest of the processes that are not in that cgroup are routed to the TUN device for proxying.</p>
<h2 id="some-other-knowledge">Some other knowledge</h2>
<h3 id="difference-between-tun-and-tap">Difference between TUN and TAP</h3>
<p>TAP is at layer 2, the data read and written needs to be in an Ether frame structure.</p>
<p>TUN At layer 3, the data read and written needs to be in IP packet structure.</p>
<h3 id="ip-and-other-configurations">IP and other configurations</h3>
<p>When configuring IP for the NIC, you are actually modifying certain parameters in the kernel network stack, not the NIC. Although the NIC will also have some configuration items that can be modified, in general the case is modified by other methods (drivers).</p>
<h3 id="difference-between-physical-nic-and-virtual-nic">Difference between physical NIC and virtual NIC</h3>
<p>A physical NIC will have <strong>DMA</strong> capability, when DMA is enabled the communication between the NIC and the network stack (buffers in memory) is managed by the DMA controller, resulting in higher performance and lower latency.</p>
<h3 id="how-to-create-a-tun-device">How to create a TUN device</h3>
<p>Under Linux everything is a file, <code>/dev/net/tun</code> is a special character (char) device file, which is opened to get a file handle and then configured with the <code>ioctl()</code> system call. Here you can choose whether to open a TUN device or a TAP device, and you can set the device name.</p>
<p>See: <a href="https://www.kernel.org/doc/html/latest/networking/tuntap.html#network-device-allocation">Network device allocation</a></p>
<h3 id="relationship-to-bpf">Relationship to BPF</h3>
<p>BPF is an advanced packet filter that can be attached to an existing network interface, but does not provide a virtual network interface itself. The TUN/TAP driver provides a virtual network interface to which BPFs can be attached.</p>

    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/tun/">tun</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/2022-04/rust-proc-macro/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">I love Rust Procedural Macros</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/2022-04/rust-gat-async-trait/">
            <span class="next-text nav-default">Manually implement zero-overhead async trait in Rust with GAT</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
  <a href="https://www.sobyte.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2021 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
