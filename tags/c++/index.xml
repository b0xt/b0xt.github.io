<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on SoByte</title>
    <link>https://www.sobyte.net/tags/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on SoByte</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 28 Aug 2022 10:52:29 +0800</lastBuildDate><atom:link href="https://www.sobyte.net/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Property Reflection in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-08/cpp-prop-reflect/</link>
      <pubDate>Sun, 28 Aug 2022 10:52:29 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-08/cpp-prop-reflect/</guid>
      <description>1 Preface Java/Go languages have built-in reflection mechanism to support getting information about classes/methods/properties at runtime. Reflection mechanism has many application scenarios, such as the most common data serialization, if there is no reflection mechanism, either based on code generation, such as protobuf; or is a line of hand-written code that is pure manual work. C++ does not have a built-in set of reflection mechanisms, and implementing reflection mechanisms is</description>
    </item>
    
    <item>
      <title>Basic usage of std::expected</title>
      <link>https://www.sobyte.net/post/2022-05/cpp-std-expected/</link>
      <pubDate>Tue, 10 May 2022 13:01:46 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-05/cpp-std-expected/</guid>
      <description>When I looked at the compiler support for cppreference recently, I found that libstdc++ already implements &amp;lt;expected&amp;gt;, but unfortunately I didn&amp;rsquo;t find much information about it on the web. What is std::expected? It is similar to std::optional, but std::optional can only indicate a normal value or std::nullopt, i.e. a null value. In contrast, std::expected can indicate an expected value and an error value, which is equivalent to the two-member std::variant,</description>
    </item>
    
    <item>
      <title>const in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-05/cpp-const/</link>
      <pubDate>Tue, 10 May 2022 12:51:47 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-05/cpp-const/</guid>
      <description>C++ identifies a type as immutable with the keyword const. This is actually quite easy to understand. However, for C++, there is a lot to discuss about simple concepts. Let&amp;rsquo;s look at a problem.
Problem We know that const can be used to modify a member function to indicate that the function cannot modify the data of the class. Suppose a class has a member T *p of type pointer, and we want to get a reference to the object pointed to by p using the get() method.</description>
    </item>
    
    <item>
      <title>How to design a thread pool in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-05/design-a-thread-pool/</link>
      <pubDate>Sat, 07 May 2022 19:58:16 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-05/design-a-thread-pool/</guid>
      <description>In this post we explore the key techniques in thread pooling by implementing it step by step.
Preliminary discussion Why do I need thread pools? Using threads in C++ has been easy since C++11. At the most basic level, a thread can be managed with std::thread. For asynchronous execution of tasks, it is also convenient to use std::async and std::future. With all this infrastructure in place, why do we need a thread pool?</description>
    </item>
    
    <item>
      <title>In-depth understanding of OC/C&#43;&#43; closures</title>
      <link>https://www.sobyte.net/post/2022-05/occ-closures/</link>
      <pubDate>Fri, 06 May 2022 13:25:01 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-05/occ-closures/</guid>
      <description>Apple&amp;rsquo;s Objective-C compiler allows users to freely mix C++ and Objective-C in the same source file, and the resulting language is called Objective-C++. Compared to other languages (e.g. Swift, Kotlin, Dart, etc.) that use file isolation and bridge communication with C++ (e.g. Kotlin uses JNI and Dart uses FFI), Objective-C and C++&amp;rsquo;s same-file mashup is certainly comfortable. Although OC/C++ mashups can be written in a single file, there are some</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Standard Library: Concurrency (2) -- Low-level interfaces thread and promise</title>
      <link>https://www.sobyte.net/post/2022-05/cpp-concurrency-2-thread-promise/</link>
      <pubDate>Thu, 05 May 2022 13:52:24 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-05/cpp-concurrency-2-thread-promise/</guid>
      <description>The thread-related api can be introduced via #include &amp;lt;thread&amp;gt;, and the promise-related api is in #include &amp;lt;future&amp;gt;. std::thread&amp;rsquo;s join and detach Unlike the std::async method of starting asynchronous tasks, std::thread will unconditionally start a task in a separate thread and begin execution If you want the current thread to wait until it knows that thread t has finished executing, then call t.join() If the intention is to detach thread t</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Standard Library: Concurrency (1) -- High-level interfaces async() and futrue</title>
      <link>https://www.sobyte.net/post/2022-05/cpp-concurrency-1-async-future/</link>
      <pubDate>Thu, 05 May 2022 13:37:47 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-05/cpp-concurrency-1-async-future/</guid>
      <description>future is a high-level API provided in the c++ standard library for performing asynchronous tasks. Its related API can be introduced via #include &amp;lt;future&amp;gt;. Create concurrent tasks using future It is simple to create an asynchronous task using future&amp;rsquo;s API. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30</description>
    </item>
    
    <item>
      <title>GCC 12 introduces more C&#43;&#43;23-oriented implementations</title>
      <link>https://www.sobyte.net/post/2022-05/gcc-12-cpp-features/</link>
      <pubDate>Mon, 02 May 2022 10:25:00 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-05/gcc-12-cpp-features/</guid>
      <description>As with every major GCC release, GCC 12.1, which will be released this week, brings many new features, improvements, and bug fixes. In a recent blog post, Red Hat&amp;rsquo;s Marek Polacek outlines some of the C++ language improvements that have been made in this major GNU Compiler Collection update.
Polacek notes that a total of several C++23 proposals are implemented in GCC 12. The default dialect in GCC 12 is -std=gnu++17; to enable C++23 features, you need to use the -std=c++23 or -std=gnu++23 command-line option, the latter of which allows GNU extensions.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Asynchronous Programming in gRPC</title>
      <link>https://www.sobyte.net/post/2022-05/grpc-cpp-async/</link>
      <pubDate>Sun, 01 May 2022 18:04:33 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-05/grpc-cpp-async/</guid>
      <description>Overview Since gRPC&amp;rsquo;s asynchronous call code is rather convoluted, this article is mainly used to document gRPC&amp;rsquo;s asynchronous calls. Note that gRPC uses the CompletionQueue binding for RPC calls in order to implement asynchronous calls, which can feel strange when writing the actual code. The response, because it is asynchronous, calls CompletionQueue::Next to wait for the packet return operation. Leave an impression here first, it will be clearer when talking</description>
    </item>
    
    <item>
      <title>Conditional compilation using if constexpr </title>
      <link>https://www.sobyte.net/post/2022-03/if-constexpr/</link>
      <pubDate>Sat, 19 Mar 2022 18:30:32 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-03/if-constexpr/</guid>
      <description>In project development, we usually use conditional compilation to trim code and selectively exclude code that is not needed, for example, if a feature is not supported at all under a certain platform, then that feature should not be compiled. Generally we use macros to determine the code, selectively pick the parts that need to be compiled, and turn on such conditions in the build system. 1 2 3 4</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Standard Library Explanation - Unordered Associative Containers</title>
      <link>https://www.sobyte.net/post/2022-02/unordered-set-and-map/</link>
      <pubDate>Sat, 19 Feb 2022 12:02:18 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/unordered-set-and-map/</guid>
      <description>Starting with C++11, the standard library has been extended for associative containers to provide associative containers based on hash table implementations. A hash table will take up more memory than the stored elements in exchange for evenly spreading O(1) performance. Hash Tables There are many strategies for resolving conflicts, the standard library chooses to use the separate linking method, where conflicting elements are placed in one location and stored in</description>
    </item>
    
    <item>
      <title>std::move() and std::forward()</title>
      <link>https://www.sobyte.net/post/2022-02/move-and-forward/</link>
      <pubDate>Sat, 19 Feb 2022 11:52:33 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/move-and-forward/</guid>
      <description>Move Semantics Move semantics is a new concept introduced in C++11 for the case when an object is assigned to another object and is no longer used by itself. Instead of calling the copy constructor of the new object and then destroying the original object, with move semantics, the resources of the original object are &amp;ldquo;moved&amp;rdquo; to the new object, e.g. std::vector assigns a pointer to an array to the</description>
    </item>
    
    <item>
      <title>Type derivation in modern C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-02/type-deduction/</link>
      <pubDate>Sat, 19 Feb 2022 11:41:19 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/type-deduction/</guid>
      <description>Template Type Derivation The following is a common function template. 1 2 template&amp;lt;typename T&amp;gt; void func(ParamType p); When we call it as func(x), the compiler will automatically derive the types T and ParamType for us, and they may not be the same because ParamType may have a const or &amp;amp; reference modifier. Parameter type is a reference or pointer 1 2 template&amp;lt;typename T&amp;gt; void func(T&amp;amp; p); This case does not</description>
    </item>
    
    <item>
      <title>Elegant use of #include</title>
      <link>https://www.sobyte.net/post/2022-02/include/</link>
      <pubDate>Tue, 15 Feb 2022 10:38:29 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/include/</guid>
      <description>#include is not just for referencing header files. Proper use of #include can make the code more elegant.
Usually we use #include to include header files, as follows.
1 #include &amp;lt;stdio.h&amp;gt; Understand that the purpose of #include is to copy the specified file to the reference as is during the pre-compilation phase. There is actually some logic that can be handled elegantly using #include.
Referencing code blocks Suppose there is a C file that contains different blocks of code.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; implementation for friendly handling of Json data</title>
      <link>https://www.sobyte.net/post/2022-02/cpp-json/</link>
      <pubDate>Sat, 12 Feb 2022 11:20:29 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/cpp-json/</guid>
      <description>Background C/C++ client needs to receive and send JSON format data to the backend to achieve communication and data interaction, but there is no ready-made interface for handling JSON format data in C++, so we can&amp;rsquo;t avoid splitting and splicing by directly referring to third-party libraries. Considering that there will be a lot of JSON data to be processed in this project, we can&amp;rsquo;t avoid the repetitive splitting and splicing.</description>
    </item>
    
    <item>
      <title>Communicating with C&#43;&#43; code in NodeJS</title>
      <link>https://www.sobyte.net/post/2022-02/communicate-with-cpp-code-in-node/</link>
      <pubDate>Wed, 09 Feb 2022 13:17:53 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/communicate-with-cpp-code-in-node/</guid>
      <description>I recently encountered a problem in my project where I needed to call C++ code in NodeJS, so here&amp;rsquo;s a quick summary.
The main options In NodeJS, there are two main options for communicating with code written in other languages.
Using the AddOn technique, write an extension to NodeJS using C++ and then call the source code or dynamic libraries written in other languages in the code using the FFI (Foreign Function Interface) technique, which brings in dynamic libraries written in other languages directly in Node A comparison of these two approaches shows that each has its own advantages and disadvantages.</description>
    </item>
    
    <item>
      <title>The underlying implementation of pointers and references in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-02/cpp-pointers-references/</link>
      <pubDate>Wed, 09 Feb 2022 13:09:45 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-02/cpp-pointers-references/</guid>
      <description>References are an important feature introduced in C++ as opposed to C. They make the syntax much more concise in many places, but how are they actually implemented underneath? In Wikipedia, pointers are described as follows. In computer science, a pointer is a programming language object that stores the memory address of another value located in computer memory. A pointer references a location in memory, and obtaining the value stored</description>
    </item>
    
    <item>
      <title>High Performance C&#43;&#43; HTTP Client Principles and Implementation</title>
      <link>https://www.sobyte.net/post/2022-01/cpp-http-client/</link>
      <pubDate>Thu, 13 Jan 2022 15:05:23 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/cpp-http-client/</guid>
      <description>1. What is Http Client The Http protocol, a common language across the Internet, and the Http Client, arguably the most basic method we need to get data from the Internet world, is essentially a URL to a webpage conversion process. And with the basic Http Client functionality, paired with the rules and policies we want, everything from content retrieval down to data analysis can be implemented.
Today we&amp;rsquo;re giving you a high-performance Http client in C++, and it&amp;rsquo;s easy!</description>
    </item>
    
    <item>
      <title>Basic usage of std::thread in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2022-01/cpp-threads-usage/</link>
      <pubDate>Tue, 04 Jan 2022 17:15:15 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/cpp-threads-usage/</guid>
      <description>C++11 introduces std::thread to make it easier to create and manage multiple threads, and this note briefly documents my learning process. This note is a brief record of my learning process, including the management of thread creation and related usage in classes. requirement In order to use std::thread we need to add &amp;lt;thread&amp;gt; as a header file, and if we use cmake for project compilation management, we need to add</description>
    </item>
    
    <item>
      <title>How to build a c/c&#43;&#43; development environment in Linux/MacOS using vscode</title>
      <link>https://www.sobyte.net/post/2022-01/how-to-build-a-c-c-development-environment-using-vscode-on-linux-macos/</link>
      <pubDate>Sat, 01 Jan 2022 17:02:53 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2022-01/how-to-build-a-c-c-development-environment-using-vscode-on-linux-macos/</guid>
      <description>Whether you&amp;rsquo;re a fan of the Lord of the Rings movies or not, you&amp;rsquo;ll agree that almost everyone loves unity, and having a unified development experience is something that developers have always strived for and welcomed.
Development environments have long been tightly coupled with specific technologies, such as Visual Studio, for primarily .NET-based development. We&amp;rsquo;ve seen heated debates among developers who endlessly argue for one tool over another. This will never end, nor should it, because many times these arguments result in the awesome tools we are using today.</description>
    </item>
    
    <item>
      <title>Type conversion in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2021-12/cpp-type-conversions/</link>
      <pubDate>Fri, 31 Dec 2021 14:36:30 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-12/cpp-type-conversions/</guid>
      <description>Introduction This blog is about the four type conversions in C++: static_cast, const_cast, reinterpret_cast, const_cast, their usage and some usage scenarios.
static_cast The reference scenario of static_cast compares conversions, according to CppReference, to perform static type conversions from the expression e to T in the following cases.
Common types for the expression e can be converted from an implicit type to T If a standard conversion sequence exists for types from T to e, a static type conversion can perform the inverse of that implicit type conversion sequence.</description>
    </item>
    
    <item>
      <title>Basic usage of smart pointers in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2021-12/cpp-smart-pointers/</link>
      <pubDate>Fri, 31 Dec 2021 14:09:44 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-12/cpp-smart-pointers/</guid>
      <description>Introduction Smart pointers are mainly used to automate the management of resources. There are std::unqiue_ptr, std::shared_ptr and std::weak_ptr according to their usage.
unique_ptr unique_ptr is mainly used to implement exclusive management of a resource object whose life cycle will end at the end of the unique_ptr declaration cycle or when it is pointed to another resource. A resource managed by unique_ptr can be transferred to another unqiue_ptr via std::move.
The following are some simple examples.</description>
    </item>
    
    <item>
      <title>Understand declval and decltype</title>
      <link>https://www.sobyte.net/post/2021-10/cplusplus-std-declval-and-decltype/</link>
      <pubDate>Thu, 21 Oct 2021 22:20:27 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/cplusplus-std-declval-and-decltype/</guid>
      <description>std::declval and decltype About decltype decltype(expr) is a new keyword added to C++11 to type out entities or expressions.
1 2 3 4 5 6 #include &amp;lt;iostream&amp;gt; int main() { int i = 33; decltype(i) j = i * 2; std::cout &amp;lt;&amp;lt; j; } It is simple and needs no additional explanation.
But how can something so simple require such a big thing as a new keyword? It&amp;rsquo;s metaprogramming! In the world of metaprogramming, a long string of template class declarations is crippling, and writing them repeatedly is even more tedious.</description>
    </item>
    
    <item>
      <title>Pipeable Programming in C&#43;&#43;</title>
      <link>https://www.sobyte.net/post/2021-10/cplusplus-pipeable/</link>
      <pubDate>Tue, 05 Oct 2021 16:46:28 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/cplusplus-pipeable/</guid>
      <description>Pipeable Pipeable is perhaps a rather controversial way of programming C++.
There is pipeable in Boost: pipeable - Boost.HigherOrderFunctions 0.6 documentation - master. It is a part of the hof library
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &amp;lt;boost/hof.hpp&amp;gt; #include &amp;lt;cassert&amp;gt; using namespace boost::hof; struct sum { template&amp;lt;class T, class U&amp;gt; T operator()(T x, U y) const { return x+y; } }; int main() { assert(3 == (1 | pipable(sum())(2))); assert(3 == pipable(sum())(1, 2)); } The HOF library stands for Higher-order functions for C++, and its author Paul Fultz II is also a celebrity.</description>
    </item>
    
    <item>
      <title>Cplusplus 17 Visitor Pattern</title>
      <link>https://www.sobyte.net/post/2021-10/cplusplus-17-visitor-pattern/</link>
      <pubDate>Tue, 05 Oct 2021 16:38:23 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/cplusplus-17-visitor-pattern/</guid>
      <description>Visitor Pattern The accessor pattern is a behavioral pattern that allows arbitrary detached visitors to be able to access managed elements under the control of the manager. The visitor cannot change the definition of the object (but this is not mandatory, you can agree to allow changes). For the manager, it does not care how many visitors there actually are, it only cares about a defined order of access to the elements (for example, for a binary tree, you can provide multiple access orders such as mid-order, pre-order, etc.</description>
    </item>
    
    <item>
      <title>Observer mode in C&#43;&#43;17</title>
      <link>https://www.sobyte.net/post/2021-10/cplusplus-17-observer-pattern/</link>
      <pubDate>Tue, 05 Oct 2021 16:25:37 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/cplusplus-17-observer-pattern/</guid>
      <description>Observer Pattern The Observer pattern is a behavioral pattern that is a subscription-publishing mechanism. Objects are able to make announcements, and anyone who has registered observer status with the object will be able to receive notifications when such announcement events occur. Registering an identity means subscribing, and the event occurs means publishing. There can be many observers doing subscriptions, at which point an observer chain is held in the observed</description>
    </item>
    
    <item>
      <title>The Strategy pattern in C&#43;&#43;17</title>
      <link>https://www.sobyte.net/post/2021-10/the-strategy-pattern-in-cplusplus17/</link>
      <pubDate>Mon, 04 Oct 2021 18:24:19 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-10/the-strategy-pattern-in-cplusplus17/</guid>
      <description>Strategy Pattern Route planning for two points on a map is a typical strategy mode application scenario. When we do a start to finish route planning, we expect the map to give us the best route for these modes: walking. Public transit, driving. Sometimes it may be subdivided into several strategies such as transit (rail priority), bus (transfer priority), etc.
Standard work Following our construction convention, here is a framework code for path planning</description>
    </item>
    
    <item>
      <title>Sorting using the standard library std::sort function </title>
      <link>https://www.sobyte.net/post/2021-09/cpp-sort/</link>
      <pubDate>Thu, 16 Sep 2021 14:23:29 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-09/cpp-sort/</guid>
      <description>The sort method of std accepts two iterators, begin and end, and abstracts access to the elements through the iterators, hiding the internal implementation.
This is a simple example:
1 2 3 4 5 6 7 8 9 std::list&amp;lt;int&amp;gt; list { 0, 4, 2, 1, 3, }; std::sort(list.begin(), list.end()); The result is that the list is sorted, and we don&amp;rsquo;t need to care about what sorting algorithm is used. In fact, the standard library decides what algorithm to use by the number of elements, based on Introspective Sorting.</description>
    </item>
    
    <item>
      <title>The Pitfalls of Cpp Projects</title>
      <link>https://www.sobyte.net/post/2021-09/the-pitfalls-of-cpp-projects/</link>
      <pubDate>Tue, 14 Sep 2021 16:22:22 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-09/the-pitfalls-of-cpp-projects/</guid>
      <description>This article records some of the problems and optimization methods of C++ in these years&amp;rsquo; projects. It is important to note that there is no one-size-fits-all method for code optimization, and you can only see what you can do, and you have to avoid problems such as premature optimization, code optimization must be done in the middle and late stages, and don&amp;rsquo;t optimize for the sake of optimization. const and</description>
    </item>
    
    <item>
      <title>Intel fully adopts LLVM for its C/C&#43;&#43; compiler</title>
      <link>https://www.sobyte.net/post/2021-08/intel-adoption-of-llvm-complete-icx/</link>
      <pubDate>Wed, 11 Aug 2021 10:07:46 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-08/intel-adoption-of-llvm-complete-icx/</guid>
      <description>In a blog post, James Reinders, Intel&amp;rsquo;s long-time compiler expert, revealed that they will be using the LLVM open source infrastructure for the next generation of Intel C/C++ compilers; and shared some information about it.
&amp;ldquo;LLVM helps us achieve our goal of providing the best C/C++ compiler for the Intel architecture. The latest Intel C/C++ compilers use LLVM to provide faster compile times, better optimizations, enhanced standards support, and support for GPU and FPGA offloading &amp;hellip;&amp;hellip; The benefits of using LLVM are many and I will provide recommendations for upgrading from a classic compiler to an LLVM-based compiler.</description>
    </item>
    
    <item>
      <title>Opencv4 C&#43;&#43; Compilation</title>
      <link>https://www.sobyte.net/post/2021-06/opencv4-c&#43;&#43;-compilation/</link>
      <pubDate>Mon, 14 Jun 2021 15:59:20 +0800</pubDate>
      
      <guid>https://www.sobyte.net/post/2021-06/opencv4-c&#43;&#43;-compilation/</guid>
      <description>1. Download https://github.com/opencv/opencv/releases https://github.com/opencv/opencv_contrib/releases Download the two zip packages and unzip them.
2. Cmake 1 2 cd opencv-4.2.0 mkdir build &amp;amp;&amp;amp; cd build If you are simply using the C++ version of opencv for cpu, you can use the following cmake command
1 2 3 4 5 6 7 8 9 10 11 12 13 cmake -D CMAKE_BUILD_TYPE=RELEASE \ -D CMAKE_INSTALL_PREFIX=/home/test/opt/opencv \ -D WITH_CUDA=OFF \ -D WITH_IPP=OFF \ -D OPENCV_EXTRA_MODULES_PATH=/home/test/opencv/opencv_contrib-4.2.0/modules \ -D OPENCV_GENERATE_PKGCONFIG=ON \ -D BUILD_opencv_python3=OFF \ -D BUILD_opencv_python2=OFF \ -D BUILD_opencv_hdf=OFF \ -D BUILD_EXAMPLES=ON .</description>
    </item>
    
  </channel>
</rss>
